

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Groovy 对 JDK 的拓展 - Mr.Li want to say</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="6. GDK 拓展本专题主要讨论 Groovy 如何在...">
  <meta name="author" content="俊虎 李">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '/images/theme/loading.gif'
      },
      donate: {
        enable: false,
        alipay: '',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">Groovy 对 JDK 的拓展</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/md/groovy_slogan.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Groovy 对 JDK 的拓展</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>May 08, 2021</span>
      
        <span class="post-info-item">
          <i class="iconfont iconeye"></i><span id="/2021/05/08/Groovy-%E5%AF%B9-JDK-%E7%9A%84%E6%8B%93%E5%B1%95/" class="leancloud" data-flag-title="Groovy 对 JDK 的拓展"></span>
        </span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>11621</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h1 id="6-GDK-拓展"><a href="#6-GDK-拓展" class="headerlink" title="6. GDK 拓展"></a>6. GDK 拓展</h1><p>本专题主要讨论 Groovy 如何在 “枯燥” 的 JDK 基础之上增加 “甜度”  —— 首先，我们最好了解一下统一访问原则，第二，简单了解 GDK 在 JDK 之上做的拓展；第三，基于 SPI 来手动实现对 JDK 的拓展，以此来增加 Groovy 开发效率。</p>
<h2 id="6-1-统一访问原则"><a href="#6-1-统一访问原则" class="headerlink" title="6.1 统一访问原则"></a>6.1 统一访问原则</h2><p>回到不久前的话题，我们现在知道通过访问 <code>execute().text</code> 属性就能够直接取出某个进程的流信息：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 访问这个 Process 的 text 属性</span><br>println <span class="hljs-string">&quot;...&quot;</span>.execute().text<br></code></pre></td></tr></table></figure>

<p>然而，笔者在试图了解 <code>.text</code> 属性的内部细节时却发现：<code>text</code> 根本就不是一个属性，它实际上被链接到一处 <code>.getText()</code> 方法。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 来自反编译软件。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String getText(File file) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> IOGroovyMethods.getText(newReader(file));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Groovy 提供这样的语法糖，一切以 <code>get[Name]</code> 为命名的方法，外部都可以 <code>.[Name]</code> 的形式像访问属性一样去调用它。就像这样：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span>&#123;</span><br>    <span class="hljs-keyword">def</span> getWeight()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Apple 没有 weight 属性。</span><br><span class="hljs-keyword">new</span> Apple().weight<br></code></pre></td></tr></table></figure>

<p>其实，这处设计灵感源自于统一访问原则 ( Uniform Access Principle ) 。设计这个原则的原因是：<strong>供给方和需求方看待产品的角度是不同的</strong>。在程序交付中，数据供给方为了提供可靠的数据，往往需要经过一系列 ( 甚至很复杂的 ) 处理过程，但这个过程对于需求方是完全透明的。这也是为什么编程语言要引入函数 —— 除了代码复用以外，另一个目的就是隐藏掉那些调用者 ( 即数据需求方 ) 毫不关心，或者不应触碰的内部处理细节。</p>
<p>访问一致原则更进一步：数据的需求方或许压根没有必要关注数据是通过 <em>访问字段</em> 还是通过 <em>函数计算</em>  获得的。需求方仅需要记住一件事情，那就是在需要的时候访问某一个变量名就可以了，就像我们之前直接从 <code>.text</code> 那里获取进程信息流那样。</p>
<p>这个设计原则的一个反例是：Java 的 <code>List</code> 接口的 <code>Size()</code> 方法 ( 可怜的 Java ，为了烘托小弟 Groovy 的 “妙”，几乎在笔者整个 Groovy 专题中充当着 “反派” )。这相当于告诉用户：”想要获取序列的长度，那就必须通过方法调用的方式获得”。或许我们早已习惯如此，并撇嘴说：”统一访问原则也没什么大不了的嘛”。但是，Groovy 坚信，<strong>一些善意的谎言或许可以让你我的生活更加美好</strong>。</p>
<p>有关于统一访问原则的概念在笔者的 Scala 学习文章中也曾出现过：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6886336268385550349#heading-9">Scala 之：函数式编程之始 (juejin.cn)</a></p>
<h2 id="6-2-GDK-的拓展方法"><a href="#6-2-GDK-的拓展方法" class="headerlink" title="6.2 GDK 的拓展方法"></a>6.2 GDK 的拓展方法</h2><p>Groovy 的存在不仅为 JVM 带来了动态语言的优势，它还增强了存在已久的 JDK 的性能，用户得以使用 Groovy 来享受更轻量级，更优雅的 Java API。Groovy 对 JDK 的拓展被称之为 Groovy JDK 开发包，即我们为使用 Groovy 而安装的 GDK。</p>
<p>文章不会事无巨细地介绍 SDK 的所有拓展，这里仅介绍一些简单的例子来体验通过闭包 + GDK 来提高开发效率的快感。尤其是下文介绍的 <code>with()</code> 和间接访问方式，它们在未来的动态编程中会很有用。</p>
<h3 id="6-2-1-上下文绑定：with-方法"><a href="#6-2-1-上下文绑定：with-方法" class="headerlink" title="6.2.1 上下文绑定：with 方法"></a>6.2.1 上下文绑定：with 方法</h3><p>在方法闭包中曾提到过这个方法：给某个对象 “挂载” 一个闭包，闭包内的所有方法调用将优先路由到对象的实例方法，这个实例充当该闭包的上下文。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span>&#123;</span><br>    <span class="hljs-keyword">def</span> func1()&#123;<br>        println <span class="hljs-string">&quot;func1 of $&#123;this.getClass()&#125;@$&#123;this.hashCode()&#125;&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">def</span> func2()&#123;<br>        println <span class="hljs-string">&quot;func2 of $&#123;this.getClass()&#125;@$&#123;this.hashCode()&#125;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这两个方法不会被优先调用，通过 this 能够体现出来。</span><br><span class="hljs-keyword">def</span> func1()&#123;println <span class="hljs-string">&quot;func1 of $&#123;this.getClass()&#125;@$&#123;this.hashCode()&#125;&quot;</span>&#125;<br><span class="hljs-keyword">def</span> func2()&#123;println <span class="hljs-string">&quot;func2 of $&#123;this.getClass()&#125;@$&#123;this.hashCode()&#125;&quot;</span>&#125;<br><br><span class="hljs-keyword">new</span> Context().with &#123;<br>    func1()<br>    func2()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再次强调，它和设置闭包 <code>delegate</code> 的方式存在不同，两者路由方法的优先顺序是相反的。</p>
<h3 id="6-2-2-间接访问属性和方法"><a href="#6-2-2-间接访问属性和方法" class="headerlink" title="6.2.2 间接访问属性和方法"></a>6.2.2 间接访问属性和方法</h3><p>假定一个学生类 <code>Student</code> 有两种信息 <code>id</code> 和 <code>name</code>。当我们明确用户要访问姓名字段时，仅需要调用 <code>.name</code> 就可以了。但如果事先不知道用户请求访问哪个字段，因为这些内容可能来自网络另一方提交的表单，我们不可能根据用户所有的可能输入去硬编码一个个分支出来。一个解决方案是使用反射，那既然如此，就先引入个 <code>java.lang.Reflect.*</code> 全家桶再说吧。</p>
<p>好在 Groovy 天生就建立在 Java 的反射机制之上，它让事情变得简单了：使用 <code>[]</code> 操作符可以直接动态地访问用户的某一个属性。这本质上是 Groovy 为对象绑定了 <code>getAt()</code> 方法，然后通过操作符重载来实现的。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student_</span> &#123;</span><br>    <span class="hljs-keyword">int</span> id<br>    String name<br>    <span class="hljs-keyword">def</span> info()&#123;println <span class="hljs-string">&quot;student $&#123;id&#125; : $&#123;name&#125;&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> s = <span class="hljs-keyword">new</span> Student_(<span class="hljs-attr">id:</span><span class="hljs-number">1</span>,<span class="hljs-attr">name:</span><span class="hljs-string">&quot;Wang Fang&quot;</span>)<br><br><span class="hljs-comment">// 这个 key 可能来自于外部输入。</span><br><span class="hljs-keyword">def</span> key = <span class="hljs-string">&#x27;id&#x27;</span><br>println(s[key])<br></code></pre></td></tr></table></figure>

<p>同样地，既然 Groovy 支持在屏蔽一大串反射调用的前提下提供间接属性访问，那么间接方法访问也差不多。 Groovy 中，任何一个对象都支持通过 <code>invokeMethod()</code> 来动态调用方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">student.invokeMethod(<span class="hljs-string">&#x27;info&#x27;</span>,<span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure>

<p>想想我们之前是怎么做的：首先获取元对象 <code>Class</code>，然后调用 <code>getMethod</code> 方法访问 <code>Method</code> 实例，最后在该实例上调用 <code>invoke</code> 方法，当然，还要抛出一大批不知如何处理的异常。</p>
<h3 id="6-2-3-对-Thread-的拓展"><a href="#6-2-3-对-Thread-的拓展" class="headerlink" title="6.2.3 对 Thread 的拓展"></a>6.2.3 对 Thread 的拓展</h3><p>在 Groovy 里通过 <code>Thread.start</code> 就能够启动一个线程，然后直接在闭包内部告诉每一个线程它的任务是什么。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 两个线程是否能并行执行，取决于机器是否有多个逻辑核心，以及两个线程是否存在数据竞态。</span><br><span class="hljs-comment">// 注，start 只是表明该线程进入就绪状态，实际运行的时机取决于 JVM 的调度。</span><br>Thread.start &#123;<br>    <span class="hljs-keyword">def</span> name = Thread.currentThread().name<br>    <span class="hljs-keyword">for</span> (;;)&#123;<br>        println(<span class="hljs-string">&quot;thread:$&#123;name&#125; : is running....&quot;</span>)<br>        Object.sleep(<span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br><br>Thread.start &#123;<br>    <span class="hljs-keyword">def</span> name = Thread.currentThread().name<br>    <span class="hljs-keyword">for</span> (;;)&#123;<br>        println(<span class="hljs-string">&quot;thread:$&#123;name&#125; : is running....&quot;</span>)<br>        Object.sleep(<span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Thread.startDaemon</code> 能够开启守护线程，相当于后台线程。当程序所有的其它非守护线程执行 ( 包括主线程 ) 完毕之后，守护线程会自动退出。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs groovy">Thread.start &#123;<br>    <span class="hljs-keyword">def</span> name = Thread.currentThread().name<br>    println(<span class="hljs-string">&quot;thread:$&#123;name&#125; : is running....&quot;</span>)<br>    Object.sleep(<span class="hljs-number">3000</span>)<br>    println(<span class="hljs-string">&quot;thread:$&#123;name&#125; has done.&quot;</span>)<br>&#125;<br><br>Thread.start &#123;<br><br>    <span class="hljs-keyword">def</span> name = Thread.currentThread().name<br>    println(<span class="hljs-string">&quot;thread:$&#123;name&#125; : is running....&quot;</span>)<br>    Object.sleep(<span class="hljs-number">4000</span>)<br>    println(<span class="hljs-string">&quot;thread:$&#123;name&#125; has done.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 在上面两个线程执行完毕后，该守护线程自动退出。</span><br>Thread.startDaemon &#123;<br>    <span class="hljs-keyword">def</span> name = Thread.currentThread().name<br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        println <span class="hljs-string">&quot;thread:$&#123;name&#125; is waiting... $&#123;Thread.activeCount()&#125; is alive.&quot;</span><br>        Object.sleep(<span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 主线程在开启这三个线程之后就相当于退出了。</span><br></code></pre></td></tr></table></figure>

<p>既然提到了线程，这里再顺便介绍一下 Groovy 为 <code>Object</code> 绑定的 <code>sleep()</code> 方法。该方法可以让执行到此处的线程陷入睡眠状态 —— 说得更准确一些，应该是昏睡 ( soundSleep ) 状态。当其它线程通过 <code>interrupt()</code> 打断它的睡眠时，在默认情况下 <code>InterurptedException</code> 会被压制下来，这是和 <code>Thread.sleep</code> 不同的一点。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.currentTimeMillis <span class="hljs-keyword">as</span> now<br><br><span class="hljs-comment">// 实际运行时间 ~ 2000 ms，说明中断没有起效果。</span><br><span class="hljs-keyword">def</span> t = Thread.start &#123;<br>    <span class="hljs-keyword">def</span> l1 = now()<br>    <span class="hljs-keyword">new</span> Object().sleep(<span class="hljs-number">2000</span>)<br>    println now() - l1<br>&#125;<br><br><span class="hljs-comment">// 主线程在休眠一秒后尝试中断 t 的运行。</span><br><span class="hljs-keyword">new</span> Object().sleep(<span class="hljs-number">1000</span>)<br>t.interrupt()<br></code></pre></td></tr></table></figure>

<p>如果想要该线程允许被中断，那么就要在调用 <code>sleep</code> 方法之后再补充一个闭包，它表明捕获到中断异常之后该做如何处理，如果打算继续忽略中断，那么闭包最终返回一个 <code>false</code> ( 或者返回值是 <code>void</code> ) ，否则返回一个 <code>true</code>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> t = Thread.start &#123;<br>    <span class="hljs-keyword">def</span> l1 = now()<br>    <span class="hljs-keyword">new</span> Object().sleep(<span class="hljs-number">2000</span>)&#123;<br>        <span class="hljs-comment">// 这里的 it 指代捕获到了 InterruptedException 异常。</span><br>        println <span class="hljs-string">&quot;谁叫醒了我???$&#123;it&#125;&quot;</span><br>        <span class="hljs-literal">true</span><br>    &#125;<br>    println now() - l1<br>&#125;<br><br><span class="hljs-keyword">new</span> Object().sleep(<span class="hljs-number">1000</span>)<br>t.interrupt()<br>println <span class="hljs-string">&quot;打断睡眠 ...&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="6-2-4-对-java-io-的拓展"><a href="#6-2-4-对-java-io-的拓展" class="headerlink" title="6.2.4 对 java.io 的拓展"></a>6.2.4 对 java.io 的拓展</h3><p>Groovy 向 <code>java.io</code> 类添加了许多实用的拓展方法 ( 在之前我们已经体验过一些方法了，比如 <code>withWriter</code>，<code>withStream</code> … 等 )。而对于一些轻量级的 IO 需求，Groovy 支持我们直接在 <code>File</code> 当中进行 ( Groovy 是如何在不修改 JDK 的前提下拓展方法的？下文的 “手动拓展 JDK 方法” 或许能提供思路 )。</p>
<p>比如说：在一个 <code>File</code> 实例中调用 <code>eachFile()</code> 查看当前路径下的所有文件，或者是通过 <code>eachDir()</code> 查看当前路径下的所有文件夹。所有的操作以闭包的方式传入，下面的代码演示了如何在 Groovy 中利用递归和 <code>eachFile()</code> 方法遍历文件夹下的所有内容。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> seek(File file, <span class="hljs-keyword">int</span> layout = <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (file.file) &#123;<br>        println <span class="hljs-string">&quot;\t&quot;</span> * layout + file.name<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.directory) &#123;<br>        println <span class="hljs-string">&quot;\t&quot;</span> * layout + file.name<br>        file.eachFile &#123; seek(it, layout + <span class="hljs-number">1</span>) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>又或者是，我们想把某个文件的文本内容一次性加载到程序中 ( <code>text</code> 内部设有 8M 的缓存空间，结合 StringBuilder，虽然字符串常量仅支持 65535 的长度，但是一个字符串对象可以占用 2G 的空间 )。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 统一访问原则 .text =&gt; .getText() 方法</span><br>prtinln <span class="hljs-keyword">new</span> File(<span class="hljs-regexp">/C:\Users\i\Desktop\武林秘籍.txt/</span>).text<br></code></pre></td></tr></table></figure>

<p>当然，也可以选择逐行处理文本内容。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">new</span> File(<span class="hljs-regexp">/C:\Users\i\Desktop\武林秘籍.txt/</span>).eachLine &#123;<br>    <span class="hljs-comment">// 在这里可插入对每一行的任何处理。</span><br>    println it<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果想要过滤文本内容，可以借助 <code>fitlerLine</code> 方法，结合正则表达式对内容进行筛选：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\liJunhu\\Desktop\\群起指令.txt&quot;</span>).filterLine &#123;<br>    <span class="hljs-comment">// 过滤掉 # 开头表示的注释行，注意取反</span><br>    !(it =~ <span class="hljs-regexp">/^#/</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于写入文件，Groovy 几乎是将语法简练到了极致：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 这里支持 append 追加,或者 write 复写。</span><br><span class="hljs-comment">// 在写二进制文件时，绝大部分情况是复写。</span><br><span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\liJunhu\\Desktop\\aa.txt&quot;</span>).append(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">	Hello Groovy, this is the 5th day of learning groovy.</span><br><span class="hljs-string">	I wouldn&#x27;t miss Java anymore.s</span><br><span class="hljs-string">	&quot;&quot;&quot;</span>,<span class="hljs-string">&quot;UTF-8&quot;</span><br>)<br><br><span class="hljs-comment">// 等同于 append 方法。</span><br><span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\liJunhu\\Desktop\\aa.txt&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;...&quot;</span><br></code></pre></td></tr></table></figure>

<p>即使我们想遵循 Java 传统的模式 ( 比如希望手动调节缓冲流的大小 )，<code>withXXXX</code> 方法也能给我们提供极大的方便，我们只需在闭包里编写逻辑，至于一些<code>IOException</code> 或是 <code>flush()</code>，<code>close()</code> 等云云，Groovy 会基于环绕方法模式 ( Execute Around Method ) 把这些琐事全部解决。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;...&quot;</span>)),<span class="hljs-number">4096</span>).withStream &#123;<br>    <span class="hljs-comment">// 这里的 it 就是指代 BufferedOutputStream。</span><br>    it.write(...)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-3-手动拓展-JDK-类方法"><a href="#6-3-手动拓展-JDK-类方法" class="headerlink" title="6.3 手动拓展 JDK 类方法"></a>6.3 手动拓展 JDK 类方法</h2><p>或许有一天，我们会觉得 <code>java.lang.String</code> 的功能有些欠缺，希望能够根据项目需求给它绑定一些定制化的静态或实例方法。只是很可惜，<code>String</code> 被标记为了 <code>final</code> 类，这表明 JDK 不希望我们对 <code>String</code> 动手动脚。</p>
<p>我们或许想要强制实现一个没有任何继承关系的装饰器，这意味着一旦需要调用 <code>String</code> 的原生方法，要么拆箱，比如 <code>new StringHandler(&quot;long long code&quot;).getBind().toUpperCase()</code>；要么就干脆在此之前手动地把所有原生的 <code>String</code> 方法全部包裹一遍 ( 代价太大，令人难以接受 )。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 我们需要一种无缝植入的方式。</span><br>        System.out.println(StringHandler.bracket(<span class="hljs-string">&quot;hello&quot;</span>));<br>        <span class="hljs-keyword">new</span> StringHandler(<span class="hljs-string">&quot;looooog loooog code&quot;</span>).writeTo(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Uses\\liJunhu\\Desktop\\aa.txt&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringHandler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String bind;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下面密密麻麻的代码只想表达一件事：将字符串直接写到一个文本内，将这个过程封装成一个方法。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target 传入目标的文件，必须满足 file 类型，否则断言失败。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> charset 传入字符集的字符串表达。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeTo</span><span class="hljs-params">(File target,String charset)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">assert</span> target.isFile();<br>        <span class="hljs-keyword">try</span>(FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(target,<span class="hljs-keyword">true</span>))&#123;<br>            <span class="hljs-comment">// 这里没有用 FileWriter，因为笔者认为调节它的 charset 有点费劲。</span><br>            OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(fos,charset);<br>            BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(osw);<br>            bw.newLine();<br>            bw.append(bind);<br>            bw.flush();<br>        &#125;<span class="hljs-keyword">catch</span> (IOException ioe)&#123;<br>            ioe.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为字符串添加一对括号。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> self 静态方法，需要从外部传入字符串。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回处理后的字符串。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">bracket</span><span class="hljs-params">(String self)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + self + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>	<br>    <span class="hljs-comment">// 出于阅读体验，这里省略了 GET，SET，以及构造器方法。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>尽管笔者尽力说服自己 “<code>StringHandler</code> 就是包装的 <code>String</code>“，但此刻是多么希望 Java 能够引入 Scala 的隐式类特性啊 …… 难道就没有将拓展方法<strong>无缝植入</strong>到 <code>String</code> 的途径了吗？Groovy 提供了一种解决之道。简单来说，这就像 “冰箱装大象一样”，只需要三步：</p>
<ol>
<li>编写容器类承载 <code>String</code> 的拓展实例方法以及静态方法。这些容器可以是通过任意一个 JVM 语言编写的，包括 Groovy，Java 。</li>
<li>把这些容器打包成一个 <code>jar</code> 。</li>
<li>想办法让 Groovy 识别到该 <code>jar</code> 包的拓展内容 ( 通过 SPI 实现，见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/wangjie5540/article/details/105342462">java-spi编程实践（Service Provider Interface+maven）</a>。</li>
</ol>
<p>上文提到了两个方法，一个是将字符串写入到文本的 <code>writeTo</code> 实例方法，另一个则是为字符串添加括号的 <code>bracket</code> 静态方法。这里选择使用 Groovy 类去实现，并且将静态方法和实例方法分别存储到两个容器类当中。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> com.i.extension<br><span class="hljs-keyword">import</span> groovy.transform.CompileStatic<br><br><span class="hljs-meta">@CompileStatic</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringExtension</span> &#123;</span><br>    <span class="hljs-comment">// &quot;HELLO WORLD&quot;.writeTo(new File(&quot;...&quot;))</span><br>    <span class="hljs-comment">// 这里的 self 指调用此实例方法的那个 String 。</span><br>    <span class="hljs-comment">// 在调用时，writeTo 只接收 file, charset 两个参数。</span><br>    <span class="hljs-keyword">static</span> String writeTo(String self,File file,String charset)&#123;<br>        <span class="hljs-keyword">assert</span> file.file<br>        file.withWriterAppend(charset)&#123;<br>            it.writeLine(self)<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//------ 两个类文件 -----------//</span><br><br><span class="hljs-keyword">package</span> com.i.extension<br><span class="hljs-keyword">import</span> groovy.transform.CompileStatic<br><br><span class="hljs-meta">@CompileStatic</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringStaticExtension</span> &#123;</span><br>    <span class="hljs-comment">// String.brackt(&quot;hello&quot;) -&gt; &quot;(hello)&quot;</span><br>    <span class="hljs-comment">// 这里的 selfType 表示此方法会和 String 类型绑定。</span><br>    <span class="hljs-comment">// 在调用时，bracket 只接收 target 参数。</span><br>    <span class="hljs-keyword">static</span> String bracket(String selfType,String target)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;($&#123;target&#125;)&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，无论我们要为目标绑定实例方法还是静态方法，它们在容器内必须全部声明为<strong>静态方法</strong>。其次，如果这个方法要被绑定为目标的实例方法，那么它接收的第一个参数代表了目标自身 ( 相当于 <code>this</code> )，反之，第一个参数用于绑定静态类型。</p>
<p>也就是说，每个方法的<strong>第一个参数都有特殊的含义</strong>，它们将来并不会直接出现在方法的参数列表内 ( 详情见注解 )。</p>
<p>接下来将这些容器装入到一个 <code>jar</code> 包。但是！ Groovy 不会平白无故就将这个 <code>jar</code> 实别为 String ( 或者是其它 JDK 类 ) 的拓展工具。在此之前，我们需要利用 SPI ( 服务发现接口，用于打破传统的双亲委派模型，JDBC 就是基于它实现的 ) 接口，在 <code>META-INF/services</code> 下注册拓展服务。这样，当这个拓展包将来被引入到其它项目内时，Groovy 就会知道我们对 <code>String</code> 做了拓展。</p>
<p>注，如果是 Maven 项目，<code>META-INF/services</code> 应该被放置在 <code>resoucre</code> 文件夹下。进入到 <code>META-INF/services</code> 下创建 <code>org.codehaus.groovy.runtime.ExtensionModule</code> 文件，留下以下信息：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">moduleName</span>=<span class="hljs-string">GString_extension</span><br><span class="hljs-attr">moduleVersion</span>=<span class="hljs-string">1.0</span><br><span class="hljs-attr">extensionClasses</span>=<span class="hljs-string">com.i.extension.StringExtension</span><br><span class="hljs-attr">staticExtensionClasses</span>=<span class="hljs-string">com.i.extension.StringStaticExtension</span><br></code></pre></td></tr></table></figure>

<p><code>moduleName</code> 是我们为这个拓展模块命名的逻辑名称，<code>moduleVersion</code> 用于声明该模块的版本 ( 这两项可自定义 )。<code>extensionClasses</code> 指明了我们的实例方法拓展容器的全限定名，<strong>如果有多个项，那么就使用逗号分割</strong>；<code>staticExtensionClasses</code> 则指明了我们的静态方法拓展容器的全限定名。</p>
<p>现在，可以借助 IDE 或者是 Maven 插件将整个项目导出为一个 <code>jar</code> 包了。在其它 Groovy 项目中，只要将刚才这个 <code>jar</code> 包导入到依赖，然后就能使用由我们自己为 <code>String</code> 类拓展的方法了。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 一段 &quot;由我们实现&quot; 的 String 方法诞生了。</span><br><span class="hljs-comment">// 所有的方法调用好像真的来自于 String 类型。</span><br><span class="hljs-string">&quot;hello&quot;</span>.writeTo(<span class="hljs-keyword">new</span> File(<span class="hljs-regexp">/C:\Users\i\Desktop\greet.txt/</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><br><span class="hljs-comment">// (hello)                </span><br>println String.bracket(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>不仅如此，IDE 现在完全能够基于我们绑定的方法给出代码提示。到现在为止，之前关于 “GDK 如何在不违背 OCP 原则的前提下拓展 JDK” 的疑惑，我们应该有些许的眉目了 ……</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>俊虎 李</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2021/05/08/Groovy-%E5%AF%B9-JDK-%E7%9A%84%E6%8B%93%E5%B1%95/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;05&#x2F;08&#x2F;Groovy-%E5%AF%B9-JDK-%E7%9A%84%E6%8B%93%E5%B1%95&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;05&#x2F;08&#x2F;Groovy-%E5%AF%B9-JDK-%E7%9A%84%E6%8B%93%E5%B1%95&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Groovy/" rel="tag">Groovy</a></li></ul> 

        
  <nav class="nav">
    <a href="/2021/05/11/Groovy-%E5%85%83%E5%AF%B9%E8%B1%A1%E5%8D%8F%E8%AE%AE/"><i class="iconfont iconleft"></i>Groovy 元对象协议</a>
    <a href="/2021/05/08/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/">关于学习编程语言的小总结<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<div id="valine"></div>
<script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  window.onload = function () {
    var loadValine = function () {
      new Valine({
        el: '#valine',
        app_id: "lo31ya7dNEzOUP6eDXbzcCX0-gzGzoHsz",
        app_key: "wqwR6SN2VWjAelsbnbJQQbl1",
        placeholder: "雁过留痕",
        avatar: "retro",
        pageSize: "10",
        lang: "zh-CN",
      });
    }
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        loadValine();
      });
    } else {
      loadValine();
    }
  };
</script>

</section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#6-GDK-%E6%8B%93%E5%B1%95"><span class="toc-text">6. GDK 拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%BB%9F%E4%B8%80%E8%AE%BF%E9%97%AE%E5%8E%9F%E5%88%99"><span class="toc-text">6.1 统一访问原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-GDK-%E7%9A%84%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-text">6.2 GDK 的拓展方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%91%E5%AE%9A%EF%BC%9Awith-%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.1 上下文绑定：with 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.2 间接访问属性和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-%E5%AF%B9-Thread-%E7%9A%84%E6%8B%93%E5%B1%95"><span class="toc-text">6.2.3 对 Thread 的拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-%E5%AF%B9-java-io-%E7%9A%84%E6%8B%93%E5%B1%95"><span class="toc-text">6.2.4 对 java.io 的拓展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%89%8B%E5%8A%A8%E6%8B%93%E5%B1%95-JDK-%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">6.3 手动拓展 JDK 类方法</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="mailto:376781642@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
    <div class="fab fab-daovoice">
      <i class="iconfont iconcomment"></i>
    </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>



  <script>
  $.getScript("//cdn.jsdelivr.net/npm/leancloud-storage@4.1.0/dist/av-min.js", () => {

    AV.init({
      appId: 'cm4TfuLppOBC3NTYFvId9VnS-gzGzoHsz',
      appKey: '131vEEATPOGJzo5QMKYH06wu',
      serverURLs: 'https://leancloud.cn/',
    });

    const showCount = (Counter) => {
      const asyncLimit = new AsyncLimit(2);
      $(".leancloud").each(async (e) => {
        const url = $(".leancloud").eq(e).attr('id').trim();
        const query = new AV.Query("Counter");
        query.equalTo("words", url);
        let count = await asyncLimit.run(() => query.count());
        $(".leancloud").eq(e).text(count ? count : '--');
      });
    }

    const addCount = (Counter) => {
      const url = $(".leancloud").length === 1 ? $(".leancloud").attr('id').trim() : 'http://example.com';
      var query = new Counter;
      query.save({
        words: url
      });
    }

    $(function () {
      const Counter = AV.Object.extend("Counter");
      addCount(Counter);
      showCount(Counter);
    });

  });
</script>



  

<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", "https://widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: "cf1dbde1"
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>