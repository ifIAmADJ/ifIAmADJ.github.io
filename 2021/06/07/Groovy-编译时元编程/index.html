

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Groovy 编译时元编程 - Mr.Li want to say</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="8. 编译时元编程编译器在将我们的源码编译成字节码之前...">
  <meta name="author" content="俊虎 李">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '/images/theme/loading.gif'
      },
      donate: {
        enable: false,
        alipay: '',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">Groovy 编译时元编程</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/md/groovy_slogan.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Groovy 编译时元编程</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>June 07, 2021</span>
      
        <span class="post-info-item">
          <i class="iconfont iconeye"></i><span id="/2021/06/07/Groovy-%E7%BC%96%E8%AF%91%E6%97%B6%E5%85%83%E7%BC%96%E7%A8%8B/" class="leancloud" data-flag-title="Groovy 编译时元编程"></span>
        </span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>33573</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h1 id="8-编译时元编程"><a href="#8-编译时元编程" class="headerlink" title="8. 编译时元编程"></a>8. 编译时元编程</h1><p>编译器在将我们的源码编译成字节码之前，会率先将源代码转换为 AST ( Abstract Syntax Tree，抽象语法树 )，以便于语义分析。而 Groovy 提供的编译时元编程工具使得<strong>我们能够在编译器产出真正的字节码之前截获源代码的 AST，并对其修改</strong>。从用户的视角而言，和运行时元编程相比，编译时元编程的修改是 “潜移默化” 的。并且由于编译器早在编译期间就做了一些额外的注入工作，这也使得 Groovy 代码在运行期的效率得到一定提升 ( 用户不需要在运行期间做一些动态注入 ) 了。</p>
<p>我们早就体验过编译期元编程为我们带来的便捷：比如笔者在 Groovy 开篇提到的各种懒人注解：<code>@Lazy</code>，<code>@Immutable</code>，以及 Groovy 默默为我们生成的各种 GET/SET 方法。对了，或许你还会联想到注入 Lombok 这样的工具，它虽并非 Groovy 实现的，但是也一定使用到了其它的编译时元编程技术。</p>
<p>在本专题中，所有的源代码都是 <code>Groovy</code> 脚本形式。我们将在 <code>Groovy</code> 脚本的编译期间实现代码导航，方法拦截，乃至方法注入。下面有一些可供参考的链接：</p>
<p><a target="_blank" rel="noopener" href="http://groovy-lang.org/metaprogramming.html#xform-ASTTest">Groovy doc 官方教程</a> | <a target="_blank" rel="noopener" href="http://melix.github.io/ast-workshop/">Groovy 元编程练习教程:melix.github.io</a> | <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=GVfrNwTBpUM">youtube 视频教程 (自备梯子)</a></p>
<p>笔者在一个 Maven 项目中演示例子，且项目的 JDK 为 8+，为了兼容 Groovy 的运行，需添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-runtime<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="8-1-Groovy-AST"><a href="#8-1-Groovy-AST" class="headerlink" title="8.1 Groovy AST"></a>8.1 Groovy AST</h2><p>在 Groovy 中，某个 Groovy 脚本的 AST 可以包含：ClassNode ( 代表脚本自身的编译类节点)，Constructors ( 构造器 )，Methods ( 方法 )。</p>
<p>Methods 包含了众多 Method 节点。节点本身记载了关于此方法所有必要的信息。Method 的语句块由各种类型的 Statement 聚合而成，并最终以 BlockStatement 的形式保存 ( 根据 Groovy 源代码的描述，BlockStatement 被认为是 Statement 的一种子类继承 )。综上所述，语句可以大致分为以下内容：</p>
<ol>
<li>表达一个普通表达式调用语句的 ExpressionStatement。</li>
<li>分支语句 IfStatement，</li>
<li>选择语句 SwitchStatement。</li>
<li>循环语句 ForStatement。</li>
<li>表示返回语句的 ReturnStatement。</li>
<li>以任意形式聚合以上各种语句的语句块 BlockStatement。</li>
<li>特殊的空语句块 Empty Statement。</li>
</ol>
<p>IfStatement，SwitchStatement，ForStatement，ReturnStatement 可以理解成以特定结构聚合 ExpressionStatement 的语句块，而 BlockStatement 则是广义的语句块。那么显然 <strong>ExpressionStatement 是构建其它 Statement 的基础</strong>，也是最常见的语句形式。每一条 ExpressionStatement 都可以由各种 Expression ( 表达式 ) 组合而成。 这些表达式又可以细化为：</p>
<ol>
<li>PropertyExpression，用于表示一个属性访问的表达式。</li>
<li>UnaryExpression，表示一个一元表达式，如 <code>!</code>，<code>~</code>。</li>
<li>BinaryExpression，表示一个二元表达式。</li>
<li>TenaryExpression，表示一个三元表达式，如 <code>?:</code>。</li>
<li>MethodCallExpression，表示一个方法调用，比较常见。</li>
<li>Declaration Expression，表示一个赋值运算。</li>
</ol>
<p>若再向下细分，Expression 便是各种类型的 Variable ( 变量 )，Constant ( 常量 ) ，Token ( 操作符 ) ，或者其它多个 Expression 的组合。</p>
<p>比如说，每一个方法是一个 MethodCallExpression，它向下拥有一个表示方法调用者的 Variable 节点，表示调用方法名的 Constant 节点，表示参数列表的 ArgumentList 节点。显然，ArgumentList 是一个 X 叉子树，X 是参数的个数。参数本身可以是表达式，可以是变量，或者是常量。</p>
<p>其它 Expression 根据自身的语义不同，各种常量变量的组合方式也各不相同。但是，审视这些内容，我们可以发现它们是语言无关的，因此易得 AST 语法树本身也是语言无关的。任何源代码总是能抽象成 AST 的形式。只要你愿意，甚至可以从一段 Groovy 的逻辑中提取出 AST ，然后利用元编程技术将它翻译成等价的 C++ 代码，以此来提高程序的运行速度 ( 这个过程可以描述为 Groovy CST -&gt; AST -&gt; C++ CST )。</p>
<p><strong>在 Groovy 的 AST 中，上述的所有 AST 节点有一个共同基类，那就是 org.codehaus.groovy.ast.ASTNode</strong>。</p>
<p>上文提到了太多的 Statement 或者是 Expression 类型，这一定程度上增加了设计 AST 的难度，但我们不需要对这些概念死记硬背。有一个实用工具 GroovyConsole：它是安装 Groovy 的 “赠品”，存放在 Groovy PATH 的 <code>bin</code> 目录下。</p>
<p>笔者发现 Groovy 3.0.8 版本的 GroovyConsole 在更高版本的 JDK 环境中启动会出现错误：<code>Could not find or load main class org.codehaus.groovy.tools.GroovyStarter</code> 。为了解决这个问题，这里通过修改本机环境变量的方式暂时将本机 JDK 版本回退到 8。</p>
<p>解决了以上小麻烦之后，只需要在控制台输入 <code>groovyConsole</code> 就可以唤起其 GUI 。可以在面板中粘贴一段代码，然后通过 <code>Ctrl</code>  + <code>T</code> 的方式打开 AST 分析窗口 Groovy AST Browser。当 GroovyConsole 面板的代码更新时，只需要按 <code>F5</code> 刷新即可。<strong>利用这个工具，我们后期就不需要自己在纸上写写画画来手动构建一段 AST 。</strong>在设计复杂的 AST 变换时，这尤为有用。</p>
<p>面板代码对应的 AST 结构可以在 <code>ClassNode -&gt; Methods -&gt; MethodNode - run -&gt; BlockStatement</code> 那里找到。</p>
<p><img    class="lazyload" data-original="https://i.im5i.com/2021/06/11/v8SYm.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">Groovy AST Browser 面板</span></p>
<p>这是一个平平无奇的控制台输出：<code>print shout?msg.toUpperCase():msg</code>。从语句类型来看，它是一个普通的 ExpressionStatement。这个语句只涉及一个简单的 MethodCallExpression，因为外层是一个对 <code>this.prinln</code> 方法的调用[^为什么不是System.out？]。 <code>print</code> 方法的参数是一个较为复杂的三元表达式。在 Groovy Console 工具中，它是这样显示的：</p>
<p><img    class="lazyload" data-original="https://i.im5i.com/2021/06/11/v8g7s.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">语句对应的 AST 结构</span></p>
<h2 id="8-2-从进行-AST-树检查开始"><a href="#8-2-从进行-AST-树检查开始" class="headerlink" title="8.2 从进行 AST 树检查开始"></a>8.2 从进行 AST 树检查开始</h2><blockquote>
<p>先不要着急想着对 AST 进行一番魔改，不如首先通过一个简单的 AST 检查的例子一窥 Groovy 脚本的 AST 结构 —— 在修改 AST 之前，至少得学会如何定位到想要修改的部分。</p>
</blockquote>
<p>从一个例子开始直接说起。我们受够了同事在团队项目中制造的代码异味[^味道有多大？]。与其在事后人工 review 代码，不如让编译器提前进行异味检查，如检测一些不规范的方法命名，参数命名 ( 尤其是使用一个字母 <code>a</code> 或 <code>b</code> 命名方法这种令其它同事深恶痛绝的行为) ，并对这些不规范的行为施加惩戒 —— 比如说抛出异常并拒绝执行。</p>
<p>举个例子，现在随手创建一个 Groovy 脚本，然后随手在里面定义一个方法。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// a for what?</span><br><span class="hljs-comment">// p for what?</span><br><span class="hljs-keyword">def</span> a(p)&#123;<br>    println p<br>&#125;<br><br><span class="hljs-comment">// 这段 Groovy 脚本可以正常编译，执行，但是毫无语义可言。</span><br>a(<span class="hljs-string">&quot;bad job&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>我们的目标是让编译器拦截这个随意的，语义不明的 Groovy 脚本。接下来就是利用 Groovy 的编译时元编程技术实现目标了。这分为两步：</p>
<ol>
<li>找出 Groovy 脚本源代码内的所有 ClassNode 节点 ( 注意，脚本本身也是一个 ClassNode 节点 )。</li>
<li>在每个 ClassNode 节点内安插守卫或称观察者 Visitor，检查有关于此 ClassNode 的 Methods，Constructor，Field 等信息。</li>
</ol>
<p>除此之外，我们希望这个代码异味检查是全局性的，因此要对其**进行一个全局的 AST 变换 ( 或称检查 )**。</p>
<p>对于第一个目标，需要创建出一个 <code>ASTTransformation</code> 接口的实现。额外的，<strong>除非使用 ASTBudiler 工具，该接口可以使用任何一门 JVM 语言来实现</strong>。对于第二个目标，可以创建出一个 <code>GroovyClassVisitor</code> 接口的实现。</p>
<h3 id="8-2-1-ASTTransformation"><a href="#8-2-1-ASTTransformation" class="headerlink" title="8.2.1 ASTTransformation"></a>8.2.1 ASTTransformation</h3><p>该接口预留了一个用于 AST 变换的 <code>visit</code> 方法，同时还有一个配套的 <code>@GroovyASTTransformation</code> 注解，该注解告知编译器在哪个阶段发起 AST 变换。</p>
<p>实际上，一共有九个阶段可供选择，它们分别是：初始化，解析，转换，语义分析，规范化，指令选择，class 生成，输出，结束。其中：转换 <code>CONVERSION</code>，语义分析 <code>SEMANTIC_ANALYSIS</code> 和 <code>CANONICALIZATION</code> 规范化是三个不错的时机，因为这三个阶段处于 “既不太晚，也不太早” 的状态。<strong>但是，如果想要更丰富的 AST 信息，就必须在越靠后的阶段进行介入</strong>。</p>
<p>有关于 <code>visit</code> 的简单介绍，可以参考 Groovy Doc。<a target="_blank" rel="noopener" href="http://www.groovy-lang.org/api.html">The Apache Groovy programming language - Groovy Development Kit (groovy-lang.org)</a></p>
<p>根据 Groovy Doc 的解释，<code>sourceUnit</code> 表示任意一个 <code>.groovy</code> 文件的源码。一份脚本内可以有多个类定义，故该参数称为“源单元”。<code>ASTNode[]</code> 参数一般用于基于注解的局部变换，后文会提到，在当前例子中可以放心地忽略它。</p>
<p>在下面的例子中，程序从源单元中获取了 Groovy 脚本内部定义的所有的类的节点 <code>classNode</code>，并对准备每一个节点使用一个检查器 <code>MyClassVisitor</code> 来进行代码检查。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ASTNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.CompilePhase<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.SourceUnit<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.ASTTransformation<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.GroovyASTTransformation<br><br><span class="hljs-meta">@GroovyASTTransformation</span>(phase = CompilePhase.SEMANTIC_ANALYSIS)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeCheck</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ASTTransformation</span> &#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visit(ASTNode[] astNodes, SourceUnit sourceUnit) &#123;<br>        sourceUnit.getAST().classes.each &#123;<br>            classNode -&gt;<br>                <span class="hljs-comment">// 在源单元内定义的每一个类节点定义全部安插一个 &quot;导航助手&quot; 。</span><br>                <span class="hljs-comment">// MyClassVisitor 的实现见后文。</span><br>                classNode.visitContents(<span class="hljs-keyword">new</span> MyClassVisitor())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-2-2-GroovyClassVisitor"><a href="#8-2-2-GroovyClassVisitor" class="headerlink" title="8.2.2 GroovyClassVisitor"></a>8.2.2 GroovyClassVisitor</h3><p><code>MyClassVisitor</code> 内置了五个用于检查 ( 或变换 ) 的方法，它们分别用于类，构造器，字段 Field，属性 Property。如果变换的内容涉及到方方面面，那显然把不同的 AST 变换按照分类存放到这里能让代码的可读性更强一些。在 Groovy 中，Field 和 Property 两者的概念几乎重合了，两者的差异来自 Groovy 的元编程协议 MOP 带来的动态性。细微的差别可以参考 <a target="_blank" rel="noopener" href="https://blog.kazaff.me/2016/04/01/groovy%E4%B8%8B%E7%9A%84field%E5%92%8Cproperty/">Groovy下的field和property | kazaff’s blog</a> 。</p>
<p>IntelliJ IDE 提供的代码提示足够我们利用已有的线索去实现目标。在此处设定：如果检查到方法名称的长度为 1，那么就抛出一个 <code>SyntaxException</code> 异常，并在控制台中给出相应信息。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ClassNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ConstructorNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.FieldNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.GroovyClassVisitor<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.MethodNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.PropertyNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.syntax.SyntaxException<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GroovyClassVisitor</span>&#123;</span><br>    <span class="hljs-comment">// 如果检查出单个字母命名的方法，就报错。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visitMethod(MethodNode methodNode) &#123;<br>        <span class="hljs-keyword">if</span>(methodNode.name.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SyntaxException(<br>                <span class="hljs-string">&quot;single letter is forbidden&quot;</span>,<br>                methodNode.lineNumber,<br>                methodNode.columnNumber<br>        )<br>    &#125;<br>    <br>    <span class="hljs-comment">// 在这个例子中，我们没有应用到这些方法，因此只保留空实现。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visitClass(ClassNode classNode) &#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visitConstructor(ConstructorNode constructorNode) &#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visitField(FieldNode fieldNode) &#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visitProperty(PropertyNode propertyNode) &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="8-2-3-注册-SPI-全局变换必须注册"><a href="#8-2-3-注册-SPI-全局变换必须注册" class="headerlink" title="8.2.3 注册 SPI (全局变换必须注册)"></a>8.2.3 注册 SPI (全局变换必须注册)</h3><p>和前述的拓展 JDK 的做法类似，为了令 groovyc 编译器能够在编译期间发现这个 AST 变换，需要在 Maven  <code>resources</code> 目录下新建一个 <code>META-INF/services</code> 目录，并创建一个名为 <code>org.codehaus.groovy.transform.ASTTransformation</code> 的清单。</p>
<p>在该清单中补充 <code>CodeCheck</code> 的全限定名，它必须是实现了 <code>ASTTransformation</code> 的类，否则就不会被识别。清单内可以存在多个转换。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">com</span>.i.CodeCheck<br></code></pre></td></tr></table></figure>

<p>现在，如果试着重新编译开头的那段脚本，能发现：由于方法命名的不规范，这次编译被拦截了：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Caught: BUG! exception <span class="hljs-keyword">in</span> phase <span class="hljs-string">&#x27;semantic analysis&#x27;</span> <span class="hljs-keyword">in</span> source unit <span class="hljs-string">&#x27;C:\Users\i\IdeaProjects\groovyInJdk11\src\main\java\groovy_script.groovy&#x27;</span> single letter is forbidden @ line <span class="hljs-number">2</span>, column <span class="hljs-number">1</span>.<br>BUG! exception <span class="hljs-keyword">in</span> phase <span class="hljs-string">&#x27;semantic analysis&#x27;</span> <span class="hljs-keyword">in</span> source unit <span class="hljs-string">&#x27;C:\Users\i\IdeaProjects\groovyInJdk11\src\main\java\groovy_script.groovy&#x27;</span> single letter is forbidden @ line <span class="hljs-number">2</span>, column <span class="hljs-number">1</span>.<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke0</span>(Native Method)<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">62</span>)<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">43</span>)<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke0</span>(Native Method)<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">62</span>)<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">43</span>)<br>	at com<span class="hljs-selector-class">.intellij</span><span class="hljs-selector-class">.rt</span><span class="hljs-selector-class">.execution</span><span class="hljs-selector-class">.application</span><span class="hljs-selector-class">.AppMainV2</span><span class="hljs-selector-class">.main</span>(AppMainV2<span class="hljs-selector-class">.java</span>:<span class="hljs-number">131</span>)<br>Caused by: org<span class="hljs-selector-class">.codehaus</span><span class="hljs-selector-class">.groovy</span><span class="hljs-selector-class">.syntax</span><span class="hljs-selector-class">.SyntaxException</span>: single letter is forbidden @ line <span class="hljs-number">2</span>, column <span class="hljs-number">1</span>.<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeConstructorAccessorImpl</span><span class="hljs-selector-class">.newInstance0</span>(Native Method)<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeConstructorAccessorImpl</span><span class="hljs-selector-class">.newInstance</span>(NativeConstructorAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">62</span>)<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingConstructorAccessorImpl</span><span class="hljs-selector-class">.newInstance</span>(DelegatingConstructorAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">45</span>)<br>	at astTest<span class="hljs-selector-class">.MyClassVisitor</span><span class="hljs-selector-class">.visitMethod</span>(MyClassVisitor<span class="hljs-selector-class">.groovy</span>:<span class="hljs-number">25</span>)<br>	at astTest.CodeCheck$_visit_closure1<span class="hljs-selector-class">.doCall</span>(CodeCheck<span class="hljs-selector-class">.groovy</span>:<span class="hljs-number">15</span>)<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke0</span>(Native Method)<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">62</span>)<br>	at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">43</span>)<br>	at astTest<span class="hljs-selector-class">.CodeCheck</span><span class="hljs-selector-class">.visit</span>(CodeCheck<span class="hljs-selector-class">.groovy</span>:<span class="hljs-number">13</span>)<br>	...<br></code></pre></td></tr></table></figure>

<p>这是一个全局的 AST 变换，它对于项目内的所有 Groovy 代码全部生效。</p>
<h2 id="8-3-基于-AST-全局变换的方法拦截"><a href="#8-3-基于-AST-全局变换的方法拦截" class="headerlink" title="8.3 基于 AST 全局变换的方法拦截"></a>8.3 基于 AST 全局变换的方法拦截</h2><p>下面是另一个全局 AST 变换的演示，还是直接从例子开始讲起。有这样一段 Groovy 脚本，脚本内有一处 <code>CheckingAccountUsing</code> 的类定义：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckingAccountUsing</span> &#123;</span><br>    <span class="hljs-keyword">def</span> audit(<span class="hljs-keyword">int</span> amount)&#123;println <span class="hljs-string">&quot;audit...&quot;</span>&#125;<br>    <span class="hljs-comment">// 希望当执行的金额 &gt;10000 时，进行 audit 审计。</span><br>    <span class="hljs-keyword">def</span> deposit(<span class="hljs-keyword">int</span> amount)&#123;println <span class="hljs-string">&quot;deposit \$$amount.&quot;</span>&#125;<br>    <span class="hljs-keyword">def</span> withdraw(<span class="hljs-keyword">int</span> amount)&#123;println <span class="hljs-string">&quot;withdraw \$$amount.&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> account = <span class="hljs-keyword">new</span> CheckingAccountUsing()<br><span class="hljs-comment">// 取出一万零一块钱。</span><br>account.withdraw(<span class="hljs-number">10001</span>)<br></code></pre></td></tr></table></figure>

<p>我们希望 <code>CheckingAccountUsing</code> 内定义的任何方法 ( 除了 <code>audit</code> 方法本身 ) 当检测到操作的金额大于 10000 时，实例能够自动调用 <code>audit</code> 方法进行审计。基于之前各种 Execute Method Around 模式，运行时方法注入等手段，实现这个目的已经不是什么难事。不过这一次，这个 AOP 的实现将交付给编译器。</p>
<p>首先另创建一个 <code>ASTTransformation</code> 的实现类，然后进入到 <code>visit</code> 方法内实现我们的思路。第一步，从源单元 <code>sourceUnit</code> 中定位到脚本内定义的 <code>CheckingAccountUsing</code> 类，然后从它的 Methods 节点中翻找出所有除了 <code>auduit</code> 以外的方法节点 MethodNode 。注意，如果不小心对 <code>audit</code> 方法节点注入了 <code>audit</code> 方法，这会无意中设置一个无限循环的程序陷阱。</p>
<p>注入的详细步骤被封装成了 <code>injectMethodWithAudit</code> 方法，见下文。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> targetClass = sourceUnit.getAST().classes.find &#123;<br>    <span class="hljs-comment">// 找出想要变换的类</span><br>    it.name == <span class="hljs-string">&quot;astTest.CheckingAccountUsing&quot;</span><br>&#125;<br><span class="hljs-keyword">def</span> nonAuditMethods = targetClass?.methods?.findAll &#123;<br>    <span class="hljs-comment">// 找出想要变换的方法</span><br>    it.name != <span class="hljs-string">&quot;audit&quot;</span><br>&#125;<br>nonAuditMethods?.each &#123; injectMethodWithAudit(it) &#125;<br></code></pre></td></tr></table></figure>

<p>现在进入到了待实现的 <code>injectMethodWithAudit</code> 方法内部。后面的思路是，我们需要在每个 MethodNode 的 BlockStatement 节点内部，安插一段这样的逻辑：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// amount 来自于 deposit 或者是 withdraw 方法的参数。</span><br><span class="hljs-keyword">if</span>(amount&gt;<span class="hljs-number">10000</span>)&#123;<br>    audit(amount)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    println(<span class="hljs-string">&quot;no need to audit&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段语句的 AST 树该如何表示呢？人工分析一定会比较麻烦，尤其是对于初学 AST 的开发者而言。一个投机的办法就是 —— 将这段代码直接复制到 Groovy Console 内，然后 “照葫芦画瓢”。</p>
<p><img    class="lazyload" data-original="https://i.im5i.com/2021/06/11/v8KVQ.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">语句对应的 AST 结构</span></p>
<p>将这个结构稍微整理一下，给出伪代码结构。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lisp">IfStatement(<br>	BooleanStatement(<span class="hljs-name">BinaryStatement</span>(<span class="hljs-name">Variable</span>(<span class="hljs-name">amount</span>),Token(<span class="hljs-string">&quot;&gt;&quot;</span>),Constant(<span class="hljs-number">10000</span>)))，<br>	// 表示条件为 true<br>	ExpressionStatement(<br>		MethodCallStatement(<br>			&#x27;this&#x27;,&#x27;audit&#x27;,Variable(&#x27;amount&#x27;)<br>		)<br>	)<br>	// 表示条件为 false<br>	ExpressionStatement(<br>		MethodCallStatement(<br>			&#x27;this&#x27;,&#x27;print&#x27;,Variable(&#x27;No need to audit&#x27;)<br>		)<br>	)<br>)<br></code></pre></td></tr></table></figure>

<p>由于 if 和 else 块内只有一行语句，因此在这里可以直接传入 ExpressionStatement。在更一般的情形中，如果块内包含了多条语句，那么就必须要选择 BlockStatement，然后将多条 ExpressionStatement 组织为链表的形式放入其中。或者，条件分支没有 else 时，那么 else 块实际上为空。此时需要选择 EmptyStatement，而不是直接传入一个 <code>null</code>。</p>
<p>这些节点都是 <code>org.codehaus.groovy.ast.*</code> 包中确切存在的类 ( 在构建的过程中，IDE 可能还会提供其他包的同名类，不要选错了 ) 。当构建好一个蓝图之后，剩下的工作就是将这段逻辑使用源代码去实现。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// condition</span><br><span class="hljs-keyword">def</span> condition = <span class="hljs-keyword">new</span> BooleanExpression(<br>    <span class="hljs-keyword">new</span> BinaryExpression(<br>        <span class="hljs-keyword">new</span> VariableExpression(<span class="hljs-string">&#x27;amount&#x27;</span>),<br>        <span class="hljs-comment">// org.codehaus.groovy.syntax.Types</span><br>        <span class="hljs-comment">// org.codehaus.groovy.syntax.Token</span><br>        <span class="hljs-comment">// 经过实践证明，startLine 和 startColumn 的设置不会影响构建 AST，在此处全部设置为 -1.</span><br>        Token.newSymbol(Types.COMPARE_GREATER_THAN, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>),<br>        <span class="hljs-keyword">new</span> ConstantExpression(<span class="hljs-number">10000</span>, <span class="hljs-literal">true</span>)<br>    )<br>)<br><br><span class="hljs-comment">// 构造 this.audit(amount)</span><br><span class="hljs-keyword">def</span> ifBlock = <span class="hljs-keyword">new</span> ExpressionStatement(<br>    <span class="hljs-keyword">new</span> MethodCallExpression(<br>        <span class="hljs-keyword">new</span> VariableExpression(<span class="hljs-string">&#x27;this&#x27;</span>),<br>        <span class="hljs-string">&#x27;audit&#x27;</span>,<br>        <span class="hljs-keyword">new</span> ArgumentListExpression(<br>            <span class="hljs-keyword">new</span> VariableExpression(<span class="hljs-string">&#x27;amount&#x27;</span>)<br>        )<br>    )<br>)<br><br><span class="hljs-comment">// 没有 else 块则使用 EmptyStatement() 代替。</span><br><span class="hljs-comment">// def elseBlock = new EmptyStatement()</span><br><span class="hljs-comment">// this.println(&quot;No need to audit&quot;)</span><br><span class="hljs-keyword">def</span> elseBlock = <span class="hljs-keyword">new</span> ExpressionStatement(<br>    <span class="hljs-keyword">new</span> MethodCallExpression(<br>        <span class="hljs-keyword">new</span> VariableExpression(<span class="hljs-string">&#x27;this&#x27;</span>),<br>        <span class="hljs-string">&#x27;println&#x27;</span>,<br>        <span class="hljs-keyword">new</span> ArgumentListExpression(<br>            <span class="hljs-keyword">new</span> ConstantExpression(<span class="hljs-string">&quot;No need to audit&quot;</span>)<br>        )<br>    )<br>)<br><br><span class="hljs-keyword">def</span> insert = <span class="hljs-keyword">new</span> IfStatement(condition , ifBlock, elseBlock)<br></code></pre></td></tr></table></figure>

<p>其中，二元符号 ( 这里需要一个表示大于的 <code>&gt;</code> 符号 ) 需要借助 <code>org.codehaus.groovy.syntax</code> 包下的 <code>Types</code> 和 <code>Token</code> 类创建。如果需要其它表达符号，可以进入到源代码内进行查看。</p>
<p>初次尝试 AST 语法变换是比较困难的事情，但是 IntelliJ IDE 给出的代码提示也足够用了。在创建各个 XXXStatement 实例时，可以多加留意每个 Statement 的创建需要哪些内容。最终的 <code>insert</code> 代表了我们想要插入的那段 <code>if</code> 语句块。最后的工作则是将它插入到原方法节点的 BlockStatement 内部。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">((BlockStatement)methodNode.code).statements.add(<span class="hljs-number">0</span>, insert)<br><span class="hljs-comment">// 更偷懒的写法是:</span><br><span class="hljs-comment">// methodNode.code.statements.add(0,insert)，不过 IDE 无法对此给出代码提示。</span><br></code></pre></td></tr></table></figure>

<p><code>.statements</code> 实际上获得的是一组存储方法原语句块的 <code>List&lt;Statement&gt;</code> 链表，我们后文总是通过修改它来实现编译时方法注入或变换。这里将 <code>insert</code> 语句块头插入到原语句块，以此实现一个前置通知。反之，实现的则是后置通知。</p>
<p>最后，不要忘记到 <code>META-INF/services/org.codehaus.groovy.transform.ASTTransforamtion</code> 那里注册这个 AST 变换。当然，这个演示有明显的不合理之处：这个全局变换实际上只应用在了特定类 <code>CheckAccountUsing</code> 上，我们应用全局变换后还得特地花些功夫重新将它从源单元 <code>sourceUnit</code> 挑出来，颇有买椟还珠之嫌。在后文会介绍如何结合<strong>注解实现一个局部 AST 变换</strong>。</p>
<p>从这个例子可以看出来，手动实现 AST 转换其实并非一件易事，编译时元编程明显要比运行时元编程要来的复杂。然而，它为用户提供带来的便捷可以说是一劳永逸的。</p>
<h2 id="8-4-编译期注入属性"><a href="#8-4-编译期注入属性" class="headerlink" title="8.4 编译期注入属性"></a>8.4 编译期注入属性</h2><p>注，<code>ASTTransformation</code> 的实现者可以是任何一门 JVM 语言。如果想要增强编译器的执行效率，那么也可以使用原生的 Java 语言来实现它，或者在 Groovy Class 上加上 <code>@ComplieStatic</code> ( 但是这样就写不了动态代码了，那还不如直接使用 Java ) 。注入属性只需要两步：</p>
<ol>
<li>找到目标 ClassNode 节点，调用其提供的 <code>addField</code> 增加属性方法。</li>
<li>构造方法的名称，修饰符，类型 ( 需要 ClassHelper 类辅助构造，详细可以翻阅源代码 )，初始值 ( Expression ) 。</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ASTNode;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ClassHelper;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ClassNode;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.expr.ConstantExpression;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.CompilePhase;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.SourceUnit;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.ASTTransformation;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.GroovyASTTransformation;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> groovyjarjarasm.asm.Opcodes.ACC_FINAL;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> groovyjarjarasm.asm.Opcodes.ACC_PUBLIC;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> groovyjarjarasm.asm.Opcodes.ACC_STATIC;<br><br><span class="hljs-comment">// build from YouToBe</span><br><span class="hljs-meta">@GroovyASTTransformation</span>(phase = CompilePhase.SEMANTIC_ANALYSIS)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ASTTransformation</span> &#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> visit(ASTNode[] astNodes, SourceUnit sourceUnit) &#123;<br>        <span class="hljs-comment">// 增加字段，相当于 public static final String AUTHOR = me;</span><br>        List&lt;ClassNode&gt; classes = sourceUnit.getAST().getClasses();<br>        classes.forEach(classNode -&gt; classNode.addField(<br>                <span class="hljs-string">&quot;AUTHOR&quot;</span>,<br>                ACC_PUBLIC | ACC_FINAL | ACC_STATIC,<br>                ClassHelper.STRING_TYPE,<br>                <span class="hljs-keyword">new</span> ConstantExpression(<span class="hljs-string">&quot;me&quot;</span>)<br>        ));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-5-编译期注入方法"><a href="#8-5-编译期注入方法" class="headerlink" title="8.5 编译期注入方法"></a>8.5 编译期注入方法</h2><p>我们已经了解如何利用 AST 对已有的方法进行改造。结合编译期注入属性章节，现在不妨尝试着在编译期为目标构建一个全新的方法。这需要三个步骤：</p>
<ol>
<li>找到目标 ClassNode 节点，调用 <code>addMethod</code> 插入方法。</li>
<li>设置方法的修饰符，返回值，参数列表，异常抛出列表等。</li>
<li>准备好方法对应函数体的 AST。</li>
</ol>
<p>或者说，和编译期注入属性相比，额外的工作就是准备一个符合语义[^怎样算符合语义？]的 AST 以及方法的其它信息一起传入到 <code>addMethod</code> 方法内。</p>
<p>这个例子演示了如何为所有类注入一个 <code>getAuthor</code> 方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> groovyjarjarasm.asm.Opcodes<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ASTNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ClassHelper<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ClassNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.Parameter<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.expr.ConstantExpression<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.BlockStatement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.ExpressionStatement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.ReturnStatement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.CompilePhase<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.SourceUnit<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.ASTTransformation<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.GroovyASTTransformation<br><br><span class="hljs-meta">@GroovyASTTransformation</span>(phase = CompilePhase.SEMANTIC_ANALYSIS)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">getMethodInserter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ASTTransformation</span>&#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visit(ASTNode[] nodes, SourceUnit source) &#123;<br><br>        <span class="hljs-comment">// 为编译期注入的方法准备语句块部分</span><br>        BlockStatement code = <span class="hljs-keyword">new</span> BlockStatement()<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        *  &#123; return &quot;author:me&quot; &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">def</span> returnString = <span class="hljs-keyword">new</span> ReturnStatement(<br>            <span class="hljs-keyword">new</span> ExpressionStatement(<br>                    <span class="hljs-keyword">new</span> ConstantExpression(<span class="hljs-string">&quot;author:me&quot;</span>)<br>            )<br>        )<br><br>        <span class="hljs-comment">// 将语句插入到语句块内</span><br>        code.addStatement(returnString)<br><br>        <span class="hljs-comment">// 向各个 ClassNode 注入一个新的 Method 节点。</span><br>        source.getAST().classes.each &#123;<br>            classNode -&gt; classNode.addMethod(<br>                    <span class="hljs-comment">// 表示注入的方法名称</span><br>                    <span class="hljs-string">&quot;getAuthor&quot;</span>,<br>                    <span class="hljs-comment">// 修饰符</span><br>                    Opcodes.ACC_PUBLIC,<br>                    <span class="hljs-comment">// 表示返回值类型。</span><br>                    ClassHelper.STRING_TYPE,<br>                    <span class="hljs-comment">// 表示不接受参数</span><br>                    Parameter.EMPTY_ARRAY,<br>                    <span class="hljs-comment">// 表示不抛出异常</span><br>                    ClassNode.EMPTY_ARRAY,<br>                    code<br>            )<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将它注册到 SPI 之后，任何一个类都可以在不改动源代码的情况下直接获得 <code>getAuthor</code> ：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println <span class="hljs-keyword">new</span> Foo().getAuthor()<br></code></pre></td></tr></table></figure>

<p>当然，根据 Groovy 的统一访问原则，对于 <code>getXXX</code> 方法可以直接作为一个属性访问：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println <span class="hljs-keyword">new</span> Foo().author<br></code></pre></td></tr></table></figure>

<h2 id="8-6-基于注解的局部变换"><a href="#8-6-基于注解的局部变换" class="headerlink" title="8.6 基于注解的局部变换"></a>8.6 基于注解的局部变换</h2><blockquote>
<p>本章需要对 Java 注解的创建有一个基本认识，具体可查阅笔者的 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904164988813325#heading-6">简单回顾Java注解 (juejin.cn)</a> 。</p>
</blockquote>
<p>到目前为止，所有的案例全都是全局的 AST 变换。如果这个 AST 并不是通用的，那么它最好是局部变换而非全局变换。</p>
<p>一个好的解决方案是将一个 AST 变换和一个标记型注解关联起来 ( 后文为了方便叙述，称这样的注解为 trigger 注解 )。这样，编译器如果在解析类的过程中发现了这些注解，那么就能够根据线索对标记类进行指定的 AST 变换，而被未标记的类则不会受到任何影响。和全局 AST 变换的另一个显著区别是：<strong>局部变换不需要注册到 SPI 接口</strong>，<strong>如果不小心这么做了，那么程序反而会报错</strong>。</p>
<p>现在创建一个 <code>Messenger</code> 注解，并为它赋予这样的功能：一旦类的定义被该注解标记，那么编译期这个类就会新增一个 <code>message</code> 方法。该方法接收一个字符串，并将它输出到控制台。同时，<code>Messenger</code> 注解有一个 <code>boolean</code> 类型的选项：<code>shout</code>。如果该值为 <code>true</code>，那么 <code>message</code> 方法在输出到控制台之前，会将字符串内的英文全部转换为大写形式，否则，不采取任何额外操作。</p>
<p>一个 Java 注解至少需要两个元注解 <code>@Retention</code> 和 <code>@Target</code>。除此之外，这里需要额外标记一个元注解 <code>GroovyASTTransformClass</code> 去关联指定的 AST 变换。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 这个注解仅在编译期用于生成方法，因此生命周期保持到源码级别即可。</span><br><span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)<br><span class="hljs-comment">// 指定这是个标记在类上面的注解。</span><br><span class="hljs-meta">@Target</span>(ElementType.TYPE)<br><span class="hljs-comment">// 将该注解和指定的 AST 变换关联起来。</span><br><span class="hljs-meta">@GroovyASTTransformationClass</span>(classes = MessageAdderAstTransformation.<span class="hljs-keyword">class</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Messenger &#123;<br>    <span class="hljs-keyword">boolean</span> shout() <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下一步便是实现这个 <code>MessageAdderAstTransformation</code> 。再次提醒，在局部变换中，这个 AST 变换不需要注册到 SPI 接口。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> groovyjarjarasm.asm.Opcodes;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.*;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.expr.*;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.ExpressionStatement;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.CompilePhase;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.SourceUnit;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.AbstractASTTransformation;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.GroovyASTTransformation;<br><br><span class="hljs-meta">@GroovyASTTransformation</span>(phase = CompilePhase.SEMANTIC_ANALYSIS)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageAdderAstTransformation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractASTTransformation</span> &#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> visit(ASTNode[] astNodes, SourceUnit sourceUnit) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        `nodes` - The ASTnodes when the call was triggered.</span><br><span class="hljs-comment">        Element 0 is the AnnotationNode that triggered this annotation to be activated.</span><br><span class="hljs-comment">        Element 1 is the AnnotatedNode decorated, such as a MethodNode or ClassNode.</span><br><span class="hljs-comment">        For global transformations it is usually safe to ignore this parameter.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 这里的类型来自 org.codehaus.groovy.ast.* .</span><br>        AnnotationNode msgAnnotation = (AnnotationNode) astNodes[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-comment">// 从注解中获取 shout 选项的值并设定为常量 (因为是编译期就设定好的值)。</span><br>        <span class="hljs-comment">// 它将决定 message 如何操作。</span><br>        ConstantExpression shout = (ConstantExpression) msgAnnotation.getMember(<span class="hljs-string">&quot;shout&quot;</span>);<br>        ClassNode annotatedClass = (ClassNode) astNodes[<span class="hljs-number">1</span>];<br>		<br>        <span class="hljs-comment">//TODO </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在以往全局变换的例子中，我们总是从源单元 <code>sourceUnit</code> 获取源码的 AST 树。但在局部变换中，使用第一个参数更合适一些。<code>astNodes</code> 参数只有固定的两个元素，下面是 Groovy Doc 的提供的解释：</p>
<ol>
<li><code>astNodes[0]</code> 代表了能够引发 AST 变换的 trigger 注解，可以从该元素中提取 trigger 注解内部的信息。</li>
<li><code>astNodes[1]</code> 代表了被 trigger 注解标记的 ClassNode，可以从该元素中提取出被 trigger 注解标记的类的 AST 树并施加变换。</li>
</ol>
<p>显然，每一个局部 AST 变换只会和一个 trigger 注解关联，这是 <code>@GroovyASTTransformationClass</code> 元注解里定义的。这里为了方便操作，将 <code>astNodes[0]</code> 强制转换为 AnnotationNode，将 <code>astNodes[1]</code> 强制转换成 ClassNode。</p>
<p>剩下的步骤大概都比较明确了：那就是分析下面这段程序的 AST。类似的套路，如果觉得手动分析内部 AST 太过麻烦，可以直接使用 GroovyConsole 工具进行生成。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 标识符: ACC_PUBlIC,</span><br><span class="hljs-comment">// 返回值: ClassHelper.VOID_TYPE</span><br><span class="hljs-comment">// 参数: [Parameter(ClassHelper.STRING_TYPE,&quot;message&quot;)]</span><br><span class="hljs-comment">// 抛出异常: ClassNode.EMPTY_ARRAY ( 表示不抛出异常 )</span><br><span class="hljs-comment">// 语法块: &#123;this.println(shout?message.toUpperCase:message)&#125;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> message(String message)&#123;<br>    <span class="hljs-comment">// shout 是一个 boolean 值，源自于 Messengers 注解。</span><br>    <span class="hljs-built_in">this</span>.println(shout?message.toUpperCase:message)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>完整的代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> astTest.javaImpl;<br><br><span class="hljs-keyword">import</span> groovyjarjarasm.asm.Opcodes;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.*;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.expr.*;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.ExpressionStatement;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.CompilePhase;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.SourceUnit;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.AbstractASTTransformation;<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.GroovyASTTransformation;<br><br><span class="hljs-meta">@GroovyASTTransformation</span>(phase = CompilePhase.SEMANTIC_ANALYSIS)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageAdderAstTransformation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractASTTransformation</span> &#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> visit(ASTNode[] astNodes, SourceUnit sourceUnit) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        `nodes` - The ASTnodes when the call was triggered.</span><br><span class="hljs-comment">        Element 0 is the AnnotationNode that triggered this annotation to be activated.</span><br><span class="hljs-comment">        Element 1 is the AnnotatedNode decorated, such as a MethodNode or ClassNode.</span><br><span class="hljs-comment">        For global transformations it is usually safe to ignore this parameter.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 这里的类型来自 org.codehaus.groovy.ast.* .</span><br>        AnnotationNode msgAnnotation = (AnnotationNode) astNodes[<span class="hljs-number">0</span>];<br>        ConstantExpression shout = (ConstantExpression) msgAnnotation.getMember(<span class="hljs-string">&quot;shout&quot;</span>);<br>        ClassNode annotatedClass = (ClassNode) astNodes[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 这个局部变量 message 和构造的函数体的 message 变量相对应。</span><br>        VariableExpression message = <span class="hljs-keyword">new</span> VariableExpression(<span class="hljs-string">&quot;message&quot;</span>);<br>        MethodCallExpression toUpperCaseCall = <span class="hljs-keyword">new</span> MethodCallExpression(message, <span class="hljs-string">&quot;toUpperCase&quot;</span>, ArgumentListExpression.EMPTY_ARGUMENTS);<br><br>        <span class="hljs-comment">// 构造了一个这样的一条语句 statement：</span><br>        <span class="hljs-comment">// this.println(shout?message.toUpperCase:message)</span><br>        ExpressionStatement code = <span class="hljs-keyword">new</span> ExpressionStatement(<br>                <span class="hljs-keyword">new</span> MethodCallExpression(<span class="hljs-keyword">new</span> VariableExpression(<span class="hljs-string">&quot;this&quot;</span>),<br>                        <span class="hljs-string">&quot;println&quot;</span>,<br>                        <span class="hljs-keyword">new</span> TernaryExpression(<span class="hljs-keyword">new</span> BooleanExpression(shout), toUpperCaseCall, message))<br>        );<br><br><br>        <span class="hljs-comment">// 创建 message</span><br>        annotatedClass.addMethod(<span class="hljs-string">&quot;message&quot;</span>,<br>                Opcodes.ACC_PUBLIC,<br>                ClassHelper.VOID_TYPE,<br>                <span class="hljs-keyword">new</span> Parameter[]&#123;<br>                        <span class="hljs-comment">// 参数 message 和局部变量的 message 相对应。</span><br>                        <span class="hljs-keyword">new</span> Parameter(ClassHelper.STRING_TYPE,<span class="hljs-string">&quot;message&quot;</span>)<br>                &#125;,<br>                <span class="hljs-comment">// 指代不抛出任何异常</span><br>                ClassNode.EMPTY_ARRAY,<br>                code<br>                );<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         最终相当于构造了这样的函数：</span><br><span class="hljs-comment">         public void message(String message)&#123;</span><br><span class="hljs-comment">            // shout 是一个 boolean 值，源自于 Messengers 注解。</span><br><span class="hljs-comment">            this.println(shout?message.toUpperCase:message)</span><br><span class="hljs-comment">         &#125;</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-7-AST-杀手锏：AstBuilder"><a href="#8-7-AST-杀手锏：AstBuilder" class="headerlink" title="8.7 AST 杀手锏：AstBuilder"></a>8.7 AST 杀手锏：AstBuilder</h2><p><strong>注意，一但使用 AstBuilder，那么 AST 变换就必须选择 Groovy 语言进行实现</strong>。</p>
<p>AstBuilder 提供了三种风格的 AST 辅助转换：<code>nuildFromSpec</code>，<code>buildFromString</code>，<code>buildFromCode</code>。我们将在一个例子中对这三种 AST 构建方式做出对比：</p>
<p>创建一个局部 AST 变换，使得所有被名为 <code>@InjectAOP</code> 的 trigger 注解标记的类，它内部所有其它方法块内部会被注入一条调用自身 <code>before</code> 方法的语句。为了确保目标类实现了 <code>before</code> 方法，这里可以使用接口做一些强制性约束。</p>
<p>给出 trigger 注解的实现：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> astBuilderTest<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.GroovyASTTransformationClass;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)<br><span class="hljs-meta">@Target</span>(ElementType.TYPE)<br><span class="hljs-meta">@GroovyASTTransformationClass</span>(classes = InjectAopASTTransformation.<span class="hljs-keyword">class</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> InjectAOP &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>给出目标脚本的实现：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> astBuilderTest<br><br><span class="hljs-meta">@InjectAOP</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AOP</span>&#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> before() &#123;println(<span class="hljs-string">&quot;这段逻辑会被注入到其它方法&quot;</span>)&#125; <span class="hljs-comment">// 通过接口强制令该类实现 before 方法。</span><br>    <span class="hljs-keyword">void</span> run()&#123;println(<span class="hljs-string">&quot;测试的方法&quot;</span>)&#125;<br>&#125;<br><br><span class="hljs-comment">// 目标:执行此脚本，控制台应当输出：</span><br><span class="hljs-comment">// 这段逻辑会被注入到其它方法</span><br><span class="hljs-comment">// 测试的方法</span><br><span class="hljs-keyword">new</span> Foo().run()<br></code></pre></td></tr></table></figure>

<p>核心目标是 <code>InjectAopASTTransformation</code> 的实现。首先给出传统实现：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> astBuilderTest<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ASTNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ClassNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.expr.ArgumentListExpression<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.expr.MethodCallExpression<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.expr.VariableExpression<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.BlockStatement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.ExpressionStatement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.CompilePhase<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.SourceUnit<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.ASTTransformation<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.GroovyASTTransformation<br><br><span class="hljs-meta">@GroovyASTTransformation</span>(phase = CompilePhase.SEMANTIC_ANALYSIS)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InjectAopASTTransformation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ASTTransformation</span> &#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visit(ASTNode[] nodes, SourceUnit source) &#123;<br>        <span class="hljs-keyword">def</span> classNode = nodes[<span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> ClassNode<br><br>        <span class="hljs-comment">// 确保它实现了 AOP 接口。</span><br>        <span class="hljs-comment">// 在 AST 内部，所有信息全部是 ASTNode 形式，因此需要将等待判断的 AOP 接口类型转换为 ClassNode 并比较。</span><br>        <span class="hljs-comment">// 这和一般的判别方式有所不同。</span><br>        <span class="hljs-keyword">def</span> c = <span class="hljs-keyword">new</span> ClassNode(AOP.<span class="hljs-keyword">class</span>)<br>        println classNode.interfaces.contains(c)<br><br>        <span class="hljs-comment">// 找出所有其它方法</span><br>        <span class="hljs-keyword">def</span> methods = classNode.methods.findAll &#123;<br>            it.name != <span class="hljs-string">&quot;before&quot;</span><br>        &#125;<br><br>        <span class="hljs-comment">// -------------AstBuilder 主要负责重构的部分------------------//</span><br>        <span class="hljs-keyword">def</span> beforeCall = <span class="hljs-keyword">new</span> ExpressionStatement(<br>                <span class="hljs-keyword">new</span> MethodCallExpression(<br>                        <span class="hljs-keyword">new</span> VariableExpression(<span class="hljs-string">&#x27;this&#x27;</span>),<br>                        <span class="hljs-string">&#x27;before&#x27;</span>,<br>                        ArgumentListExpression.EMPTY_ARGUMENTS<br>                )<br>        )<br><br>        methods.each &#123;<br>            ((BlockStatement) it.code).statements.add(<span class="hljs-number">0</span>, beforeCall)<br>        &#125;<br>        <span class="hljs-comment">// ---------------------------------------------------------//</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一种：<code>buildFromSpec</code>。它本质上是创建了一个内部 DSL，使我们在创建各种 ASTNode 的过程中免去了频繁的 <code>new</code> 关键字声明。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> astBuilderTest<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ASTNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ClassNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.builder.AstBuilder<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.BlockStatement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.Statement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.CompilePhase<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.SourceUnit<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.ASTTransformation<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.GroovyASTTransformation<br><br><span class="hljs-meta">@GroovyASTTransformation</span>(phase = CompilePhase.SEMANTIC_ANALYSIS)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InjectAopASTTransformation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ASTTransformation</span> &#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visit(ASTNode[] nodes, SourceUnit source) &#123;<br>        <span class="hljs-keyword">def</span> classNode = nodes[<span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> ClassNode<br><br>        <span class="hljs-comment">// 确保它实现了 AOP 接口。</span><br>        <span class="hljs-comment">// 在 AST 内部，所有信息全部是 ASTNode 形式，因此需要将等待判断的 AOP 接口类型转换为 ClassNode 并比较。</span><br>        <span class="hljs-comment">// 这和一般的判别方式有所不同。</span><br>        <span class="hljs-keyword">def</span> c = <span class="hljs-keyword">new</span> ClassNode(AOP.<span class="hljs-keyword">class</span>)<br>        <span class="hljs-keyword">assert</span> classNode.interfaces.contains(c)<br><br>        <span class="hljs-comment">// 找出所有其它方法</span><br>        <span class="hljs-keyword">def</span> methods = classNode.methods.findAll &#123;<br>            it.name != <span class="hljs-string">&quot;before&quot;</span><br>        &#125;<br><br>        <span class="hljs-comment">// -------------AstBuilder 主要负责重构的部分------------------//</span><br>        <span class="hljs-keyword">def</span> beforeCall = <span class="hljs-keyword">new</span> AstBuilder().buildFromSpec &#123;<br>            <span class="hljs-comment">// ExpressionStatement</span><br>            expression &#123;<br>                methodCall &#123;<br>                    variable <span class="hljs-string">&#x27;this&#x27;</span><br>                    constant <span class="hljs-string">&#x27;before&#x27;</span><br>                    argumentList &#123;&#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">as</span> List&lt;Statement&gt;<br><br>        methods.each &#123;<br>            ((BlockStatement) it.code).statements.add(<span class="hljs-number">0</span>, beforeCall[<span class="hljs-number">0</span>])<br>        &#125;<br>        <span class="hljs-comment">// ---------------------------------------------------------//</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其 DSL 的构建方式只是在写法上减少了一点构建 AST 的负担，但是仍然要求我们熟练掌握 Groovy 提供的各种 AST 节点及其构建方式。对于不熟悉 <code>org.codehaus.groovy.ast</code> 包下各种类型的开发者而言，构建 AST 仍然是一个繁琐且困难的工作。</p>
<p>假如有这样一个工具，能够允许我们按照日常的习惯编写源代码，然后由它自动转换为 AST 树就好了 ( 这样的话，我们甚至都不用深入了解 AST 树了! )。AstBuilder 正好解决了这个痛点。下面介绍 AstBuilder 第二种使用方式：<code>buildFromCode</code>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> astBuilderTest<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ASTNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ClassNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.builder.AstBuilder<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.BlockStatement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.Statement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.CompilePhase<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.SourceUnit<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.ASTTransformation<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.GroovyASTTransformation<br><br><span class="hljs-meta">@GroovyASTTransformation</span>(phase = CompilePhase.SEMANTIC_ANALYSIS)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InjectAopASTTransformation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ASTTransformation</span> &#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visit(ASTNode[] nodes, SourceUnit source) &#123;<br>        <span class="hljs-keyword">def</span> classNode = nodes[<span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> ClassNode<br><br>        <span class="hljs-comment">// 确保它实现了 AOP 接口。</span><br>        <span class="hljs-comment">// 在 AST 内部，所有信息全部是 ASTNode 形式，因此需要将判断的 AOP 接口类型装入到 ClassNode 并比较。</span><br>        <span class="hljs-comment">// 这和一般的判别方式有所不同。</span><br>        <span class="hljs-keyword">def</span> c = <span class="hljs-keyword">new</span> ClassNode(AOP.<span class="hljs-keyword">class</span>)<br>        <span class="hljs-keyword">assert</span> classNode.interfaces.contains(c)<br><br>        <span class="hljs-comment">// 找出所有其它方法</span><br>        <span class="hljs-keyword">def</span> methods = classNode.methods.findAll &#123;<br>            it.name != <span class="hljs-string">&quot;before&quot;</span><br>        &#125;<br><br>        <span class="hljs-comment">// -------------AstBuilder 主要负责重构的部分------------------//</span><br>        <span class="hljs-comment">// AstBuilder 独立于 InjectAopASTTransformation 进行编译。</span><br>        <span class="hljs-keyword">def</span> beforeCall = <span class="hljs-keyword">new</span> AstBuilder().buildFromCode(CompilePhase.SEMANTIC_ANALYSIS)&#123;<br>            <span class="hljs-built_in">this</span>.before()<br>        &#125; <span class="hljs-keyword">as</span> List&lt;Statement&gt;<br>        <br>        methods.each &#123;<br>            <span class="hljs-comment">// ((BlockStatement) it.code).statements.addAll(0,beforeCall)</span><br>            ((BlockStatement) it.code).statements.add(<span class="hljs-number">0</span>,beforeCall[<span class="hljs-number">0</span>])<br>        &#125;<br>       <span class="hljs-comment">// ---------------------------------------------------------//</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里有很多细节需要说明。如我们所见，<code>buildFromCode</code> 方法的闭包内允许直接放入一段代码块，我们不再需要在各种复杂的 AST 结构当中挣扎。除此之外，该方法还指明 AstBuilder 在某个阶段 ( 此处是 <code>CompilePhase.SEMANTIC_ANALYSIS</code> ) <strong>将闭包的内代码转为等价的 AST</strong> ( 笔者推测 AstBuilder 的 AST 变换过程和 <code>InjectAopASTTransformation</code> 的 AST 变换是分开且独立的，但是 Groovy Doc 给出的解释令我云里雾里，网上也没有足够资料 ) 。</p>
<p>实际上，<code>buildFromCode</code> 返回的是一个抽象的 <code>List&lt;ASTNode&gt;</code> 类型。为了便于操作，这里通过 <code>as</code> 符号将其转换为了 <code>List&lt;Statement&gt;</code> 类型 。 注，<code>as</code> 操作符依赖调用者的 <code>asType</code> 方法，和强制转换的概念有区别。无论我们在 <code>buildFromCode</code> 内创建了多少语句块，它们最终总是被包装为一个 BlockStatement，然后再装入到一个 List 内部。</p>
<p>换句话说，通过访问 <code>beforeCall[0]</code> 就可以获取到 AstBuilder 为我们转换好的 AST 了。注意，一旦进入到 <code>buildFromCode</code> ( 还有后文的 <code>buildFromString</code> ) 方法的闭包内部，<strong>IntelliJ IDE 就无法再为我们提供有效的代码提示</strong>，甚至有时还会出现 “误导” 的情况。比如：上述代码块内的 <code>this</code> 可不是指代这个 AST 变换类本身，而是指代上下文中被注入的那个对象 “that”，调用的是 “that” 的 <code>before</code> 方法。</p>
<p>第三种，<code>buildFromString</code>。这种方式和 <code>buildFromCode</code> 非常接近，只不过 AstBuilder 这一次转化的目标是 <code>String</code> 类型。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> astBuilderTest<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ASTNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.ClassNode<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.builder.AstBuilder<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.BlockStatement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.ast.stmt.Statement<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.CompilePhase<br><span class="hljs-keyword">import</span> org.codehaus.groovy.control.SourceUnit<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.ASTTransformation<br><span class="hljs-keyword">import</span> org.codehaus.groovy.transform.GroovyASTTransformation<br><br><span class="hljs-meta">@GroovyASTTransformation</span>(phase = CompilePhase.SEMANTIC_ANALYSIS)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InjectAopASTTransformation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ASTTransformation</span> &#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> visit(ASTNode[] nodes, SourceUnit source) &#123;<br>        <span class="hljs-keyword">def</span> classNode = nodes[<span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> ClassNode<br><br>        <span class="hljs-comment">// 确保它实现了 AOP 接口。</span><br>        <span class="hljs-comment">// 在 AST 内部，所有信息全部是 ASTNode 形式，因此需要将等待判断的 AOP 接口类型转换为 ClassNode 并比较。</span><br>        <span class="hljs-comment">// 这和一般的判别方式有所不同。</span><br>        <span class="hljs-keyword">def</span> c = <span class="hljs-keyword">new</span> ClassNode(AOP.<span class="hljs-keyword">class</span>)<br>        <span class="hljs-keyword">assert</span> classNode.interfaces.contains(c)<br><br>        <span class="hljs-comment">// 找出所有其它方法</span><br>        <span class="hljs-keyword">def</span> methods = classNode.methods.findAll &#123;<br>            it.name != <span class="hljs-string">&quot;before&quot;</span><br>        &#125;<br><br>        <span class="hljs-comment">// -------------AstBuilder 主要负责重构的部分------------------//</span><br>        <span class="hljs-comment">// AstBuilder 独立于 InjectAopASTTransformation 进行编译。</span><br>        <span class="hljs-keyword">def</span> info = <span class="hljs-string">&quot;println \&quot;this source build by AstBuilder\&quot; &quot;</span><br>        <span class="hljs-keyword">def</span> beforeCall = <span class="hljs-keyword">new</span> AstBuilder().buildFromString(CompilePhase.SEMANTIC_ANALYSIS,<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            this.before()</span><br><span class="hljs-string">            $&#123;info&#125;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>) <span class="hljs-keyword">as</span> List&lt;Statement&gt;<br>        <br>        methods.each &#123;<br>            ((BlockStatement) it.code).statements.add(<span class="hljs-number">0</span>,beforeCall[<span class="hljs-number">0</span>])<br>        &#125;<br>        <span class="hljs-comment">// -------------等待 AstBuilder 重构的部分------------------//</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>和 <code>buildFromCode</code> 相比，它的优势是允许我们能够像拼凑 GString 一样自由地组合源代码 ( 并且不再需要关心它的 AST 结构，因为 AstBuilder 会替我们搞定 )，而缺点则是可能会遇到一些字符串转义的烦恼。</p>
<h2 id="8-8-补充：部分-AST-节点表示为-“空”-的方式"><a href="#8-8-补充：部分-AST-节点表示为-“空”-的方式" class="headerlink" title="8.8 补充：部分 AST 节点表示为 “空” 的方式"></a>8.8 补充：部分 AST 节点表示为 “空” 的方式</h2><p>如果要构造一个空语句块，则需要创建 EmptyStatement 实例。</p>
<p>当构造 MethodCallExpression 时，如果遇到空括号方法的调用，那么参数列表应表示为 <code>ArgumentListExpression.EMPTY_ARGUMENTS</code>。</p>
<p>当进行编译期方法构造 ( 对某个 ClassNode 调用 <code>addMethod</code> 方法 ) 时，如果此方法是空括号方法，那么参数列表应表示为 <code>Parameter.EMPTY_ARRAY</code>。如果此方法不抛出任何异常，那么应表示为 <code>ClassNode.EMPTY_ARRAY</code>。如果该方法不返回值，应表示为 <code>ClassHelper.VOID_TYPE</code>。</p>
<p>在构造方法返回值类型，或是属性类型时，使用 Groovy 提供 ClassHelper 去完成。</p>
<p>[^为什么不是System.out？]: Groovy 给所有的 GroovyObject 都绑定了 print 方法，因此调用者自然就是 this 。<br>[^味道有多大？]: 常见的代码异味包括 Duplicated Code，Long Method，Switch Statement，以及其它可以想到的不良代码，详情可见<a target="_blank" rel="noopener" href="http://www.nowamagic.net/librarys/veda/detail/2053">一些常见的代码异味 Code Smell – 简明现代魔法 (nowamagic.net)</a>。<br>[^怎样算符合语义？]: 比如插入方法时设定返回值为 <code>String</code>，那么该方法的 BlockStatement 的最后一个元素应当是返回字符串类型的 ReturnStatement。</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>俊虎 李</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2021/06/07/Groovy-%E7%BC%96%E8%AF%91%E6%97%B6%E5%85%83%E7%BC%96%E7%A8%8B/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;06&#x2F;07&#x2F;Groovy-%E7%BC%96%E8%AF%91%E6%97%B6%E5%85%83%E7%BC%96%E7%A8%8B&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;06&#x2F;07&#x2F;Groovy-%E7%BC%96%E8%AF%91%E6%97%B6%E5%85%83%E7%BC%96%E7%A8%8B&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Groovy/" rel="tag">Groovy</a></li></ul> 

        
  <nav class="nav">
    <a href="/2021/06/11/Groovy-DSL-%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93/"><i class="iconfont iconleft"></i>Groovy DSL 设计之道</a>
    <a href="/2021/05/16/%E4%B8%80%E6%96%87%E9%80%9A%E8%AF%BB-Groovy-MOP/">一文通读 Groovy MOP<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<div id="valine"></div>
<script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  window.onload = function () {
    var loadValine = function () {
      new Valine({
        el: '#valine',
        app_id: "lo31ya7dNEzOUP6eDXbzcCX0-gzGzoHsz",
        app_key: "wqwR6SN2VWjAelsbnbJQQbl1",
        placeholder: "雁过留痕",
        avatar: "retro",
        pageSize: "10",
        lang: "zh-CN",
      });
    }
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        loadValine();
      });
    } else {
      loadValine();
    }
  };
</script>

</section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%BC%96%E8%AF%91%E6%97%B6%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-text">8. 编译时元编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Groovy-AST"><span class="toc-text">8.1 Groovy AST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E4%BB%8E%E8%BF%9B%E8%A1%8C-AST-%E6%A0%91%E6%A3%80%E6%9F%A5%E5%BC%80%E5%A7%8B"><span class="toc-text">8.2 从进行 AST 树检查开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-ASTTransformation"><span class="toc-text">8.2.1 ASTTransformation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-GroovyClassVisitor"><span class="toc-text">8.2.2 GroovyClassVisitor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E6%B3%A8%E5%86%8C-SPI-%E5%85%A8%E5%B1%80%E5%8F%98%E6%8D%A2%E5%BF%85%E9%A1%BB%E6%B3%A8%E5%86%8C"><span class="toc-text">8.2.3 注册 SPI (全局变换必须注册)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%9F%BA%E4%BA%8E-AST-%E5%85%A8%E5%B1%80%E5%8F%98%E6%8D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA"><span class="toc-text">8.3 基于 AST 全局变换的方法拦截</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7"><span class="toc-text">8.4 编译期注入属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95"><span class="toc-text">8.5 编译期注入方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E6%8D%A2"><span class="toc-text">8.6 基于注解的局部变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-AST-%E6%9D%80%E6%89%8B%E9%94%8F%EF%BC%9AAstBuilder"><span class="toc-text">8.7 AST 杀手锏：AstBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E8%A1%A5%E5%85%85%EF%BC%9A%E9%83%A8%E5%88%86-AST-%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA%E4%B8%BA-%E2%80%9C%E7%A9%BA%E2%80%9D-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">8.8 补充：部分 AST 节点表示为 “空” 的方式</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="mailto:376781642@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
    <div class="fab fab-daovoice">
      <i class="iconfont iconcomment"></i>
    </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>



  <script>
  $.getScript("//cdn.jsdelivr.net/npm/leancloud-storage@4.1.0/dist/av-min.js", () => {

    AV.init({
      appId: 'cm4TfuLppOBC3NTYFvId9VnS-gzGzoHsz',
      appKey: '131vEEATPOGJzo5QMKYH06wu',
      serverURLs: 'https://leancloud.cn/',
    });

    const showCount = (Counter) => {
      const asyncLimit = new AsyncLimit(2);
      $(".leancloud").each(async (e) => {
        const url = $(".leancloud").eq(e).attr('id').trim();
        const query = new AV.Query("Counter");
        query.equalTo("words", url);
        let count = await asyncLimit.run(() => query.count());
        $(".leancloud").eq(e).text(count ? count : '--');
      });
    }

    const addCount = (Counter) => {
      const url = $(".leancloud").length === 1 ? $(".leancloud").attr('id').trim() : 'http://example.com';
      var query = new Counter;
      query.save({
        words: url
      });
    }

    $(function () {
      const Counter = AV.Object.extend("Counter");
      addCount(Counter);
      showCount(Counter);
    });

  });
</script>



  

<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", "https://widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: "cf1dbde1"
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>