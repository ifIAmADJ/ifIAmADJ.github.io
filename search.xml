<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>配置 Hexo 到远程仓库的简明思路</title>
    <url>/2021/03/13/%E9%85%8D%E7%BD%AE-Hexo-%E5%88%B0-Github-%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="欢迎"><a href="#欢迎" class="headerlink" title="欢迎"></a>欢迎</h1><p>在使用 Hexo 之前，需要在本机安装操作系统对应的 Node.js 和 git 工具。 Hexo 及插件的依赖包会通过 Node.js 中的 npm 工具下载并安装，git 则用于保管博客代码。使用 Hexo 不需要很了解 JavaScript ，但是需要至少了解有关 git 的一些基本操作。这些前置工作非常简单，<a href="https://hexo.io/zh-cn/docs/">官方文档</a>已经给出足够详细的说明。</p>
<p>对于 Windows 用户，各种 <code>hexo ...</code> 以及 <code>git ...</code> ，<code>npm ....</code> 等命令都是通过在 Hexo 根目录下右键 <code>Git Bash Here</code> 打开的伪 Linux 终端进行的。</p>
<p>Hexo 的工作原理是：我们在 <code>source =&gt; _posts</code> 目录杜撰的 Markdown 文章以及根目录 <code>_config.yml</code> 配置文件最终被 Hexo 统一解析，最终在根目录下生成一个名为 <code>public </code> 文件夹。如果直接在本机通过 <code>hexo s</code> 命令启动站点服务，则 Hexo 会基于根目录下的 <code>public</code> 文件夹内的静态文件渲染出博客站点。</p>
<p>但通常情况下，<code>hexo s</code> 命令仅用于本地调试，因为我们需要在一个随时保持运行的服务器中部署站点。如果没有私人服务器，那么就需要 <code>hexo d</code> 命令将渲染好的静态文件迁移到远程仓库 ( Github，Gitee 等)，再由这些远程仓库提供的静态网页渲染服务实现远程部署 (<strong>这要求仓库命名符合一定格式</strong>，详细请见后文)。</p>
<p>执行 <code>hexo d</code> 需要这个插件，直接运行即可。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">$ npm install <span class="hljs-comment">--save hexo-deployer-git</span><br></code></pre></td></tr></table></figure>

<p><code>hexo d</code> 的工作原理是：在根目录下额外生成一个 <code>.deploy_git</code> 文件夹，而它是 <code>public</code> 目录的拷贝。而 Hexo 替我们完成对这个文件夹的一系列 <code>git</code> 操作：<code>add</code>，<code>commit</code> 然后 <code>push</code> 。</p>
<p>这需要在根目录的 <code>_config.yml</code> =&gt; <code>deploy</code> 选项中配置一个我们提前准备好的，一个新创建的远程仓库地址和分支名，并且要求<strong>本机在对应的远程仓库配置了 ssh key</strong>，这样 Hexo 才能替我们进行免密提交。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># username 指我们的 GitHub 用户名。</span><br><span class="hljs-meta"># branch 一般是 master 。</span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> git@github.com:username/username.github.io.git  <br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure>

<p>远程仓库仅负责保管并渲染本地提交的 <code>.deploy_git</code> 文件夹 ( 即本地 <code>public</code> 的副本 ) 。而 Hexo 根目录下的各种诸如 <code>_config.yml</code> ，<code>theme</code>，<code>scaffolds</code> 等其它文件 (夹) 如有需要请另行存储。</p>
<p>GitHub 和 Gitee 都提供基于 Hexo 的静态网页渲染服务，并且会提供诸如 <code>xxxxx.github.io</code> ，<code>xxxxxx.gitee.io</code> 格式的域名供外界访问，免去了购买云服务器的成本。 </p>
<p>选择 GitHub 的一大优势是：简单。假设我们的 GitHub 账户名是 <code>username</code>，那么远程仓库名称应当直接以 <code>username.io</code> 命名。这样，GitHub 会自动根据仓库内的静态文件渲染出博客站点页面 ( 在第一次渲染完成后，GitHub 会通过账号邮箱向你发送提示邮件)。并且，每当我们通过 <code>hexo d</code> 部署时，GitHub 会主动地重新渲染，不需要额外的操作就可以通过浏览器收到反馈。</p>
<p>选择 Gitee 的一大优势是：稳定。国内访问 GitHub 的速度非常不稳定，甚至有时候需要用户科学上网才能浏览我们的博客，体验极差。但是 Gitee 平台的操作要比 GitHub 稍微繁琐一些。</p>
<p>首先，我们需要在服务栏中，主动通过 Gitee Pages 开启静态页面渲染服务：</p>
<p><img  src="https://i.im5i.com/2021/03/16/hmQh5.png"  ><span class="image-caption">Gitee Pages 按钮.png</span></p>
<p>其次，Gitee 本身不会对仓库名做强制要求。但是，假设我们的 Gitee 账户名是 <code>username</code>，而远程仓库也被命名为 <code>username</code>，那么 Gitee 会直接提供 <code>username.gitee.io</code> 格式的访问域名 ( 建议这样做，避免因路径问题导致渲染网页所需要的 js，css 文件丢失 ) 。</p>
<p>另一个要注意的点是，即便在本地通过 <code>hexo d</code> 将更新提交到了 Gitee 仓库，<strong>它也并不会像 GitHub 那样自动地重新渲染页面</strong>。我们需要通过个人账户重新登录到 Gitee 仓库，然后再一次点击刚才的 Gitee Pages 按钮，跳转页面后点击<strong>更新</strong>按钮令 Gitee 重新部署 ( 如果你希望 Gitee 能够像 GitHub 那样 “聪明”，应该是要向平台支付一点点服务费 )。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Groovy 优雅地 FP 编程</title>
    <url>/2021/04/30/Groovy-FP/</url>
    <content><![CDATA[<h1 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h1><p>闭包的通俗解释，就是内部状态与外部隔离，仅通过参数列表和返回值与外界进行交互的<strong>高阶函数</strong>，用于保护内部的函数不受外界影响。其概念派生自 Lambda 表达式。对于 Java 这类 OOP 语言来说，”闭包” 的概念则被 “类” 所代替：闭包的局部变量变成了 “属性”，而内部函数变成了 “方法”。方法的结果往往取决于属性，而属性又通常是不对外开放的 ( <code>private </code> )。</p>
<p>FP 的一些基本概念或术语，笔者其实主要是从 Scala 的角度切入的。详情见：<a href="https://juejin.cn/post/6886336268385550349">Scala 之：函数式编程之始</a></p>
<h2 id="4-1-Groovy-中的闭包"><a href="#4-1-Groovy-中的闭包" class="headerlink" title="4.1 Groovy 中的闭包"></a>4.1 Groovy 中的闭包</h2><p>Groovy 允许我们以函数式风格使用闭包 ( 至少看起来是那样 ) 并在各处传递。换句话说，Groovy 也支持函数式编程 FP，并具备所有 FP 应当具备的特性。我们在 Java 中曾感慨过 Lambda 表达式的简洁，而在 Groovy 中，它已是家常便饭。假定我们想自定义一个对数组进行遍历操作的 <code>foreach</code> 函数，该函数对内部的元素操作取决于传入的闭包 <code>action</code>：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">nums = <span class="hljs-number">1.</span><span class="hljs-number">.10</span><br><br><span class="hljs-comment">// 这段代码完全没有声明任何类型，我好像在写 javaScript.......</span><br><span class="hljs-keyword">void</span> foreach(nums ,action)&#123;<br>    <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> nums)&#123;<br>        <span class="hljs-comment">// 这个传入的 i 就是 i-&gt; print &quot;$&#123;i&#125;&quot; 当中的那个 i。</span><br>        action(i)<br>    &#125;<br>&#125;<br><br>foreach(nums,&#123;i -&gt; print <span class="hljs-string">&quot;$&#123;i&#125; &quot;</span>&#125;)<br></code></pre></td></tr></table></figure>

<p>前面的文章曾提到过，如果参数列表的最后几个参数是闭包，可以选择性的将这些闭包移动到函数调用后面，英语老师管这种表达方法叫 “定语后置”。尤其是当闭包较长时，这种表述方式要更加优雅。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//对那个数组进行 foreach 操作 | 怎么操作</span><br>foreach(nums) &#123;i -&gt; print <span class="hljs-string">&quot;$&#123;i&#125; &quot;</span>&#125;<br><br>foreach(nums) &#123;<br>	i-&gt;<br>	print i<br>	print <span class="hljs-string">&quot;当闭包很长时，这种写法看起来可读性更高&quot;</span><br>	print <span class="hljs-string">&quot;这个写法已经很接近平日所用的 for-each 循环了。&quot;</span><br>	print <span class="hljs-string">&quot;这就是闭包后置带来的惊喜。&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>甚至可以再抽象一点，将 <code>nums</code> 数组本身也看作是一个 <code>&#123;()-&gt;nums&#125;</code> 的闭包：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">static</span> foreach(nums,action)&#123;<br>    <span class="hljs-comment">// nums() 表示它是一个 ()-&gt;nums 的 supplyer.</span><br>    <span class="hljs-keyword">def</span> seq = nums()<br>    <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> seq) &#123;action(i)&#125;<br>&#125;<br><span class="hljs-comment">// &#123;nums&#125; 实际上是 &#123;-&gt;nums&#125;，这里可以省略掉 -&gt; 箭头。</span><br>foreach &#123;nums&#125; &#123;i-&gt;print(<span class="hljs-string">&quot;$&#123;i&#125; &quot;</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们隐约能感受到由 Groovy 创建出的 DSL 将是何其优雅而强大。其中，<code>foreach</code> 接收 <code>action</code> 闭包 ( 也可以称作是函数 )，因此 <code>foreach</code> 也被称作是<strong>高阶函数</strong> 。高阶函数的更直接解释是：一个接收函数，或者是返回另一个函数的函数。</p>
<p>在 Java 中，一个 Lambda 表达式的写法是这样的：<code>(...) -&gt; &#123;...&#125;</code>，即便在没有任何参数的情况下，也得写成 <code>()-&gt;&#123;...&#125;</code> 的形式。而在 Groovy 中，闭包的参数不需要小括号括起来，形式上类似 <code>&#123; p1,p2 -&gt;...&#125;</code> 。</p>
<p>当这个闭包不需要任何参数时，写法形如 <code>&#123; -&gt; ...&#125;</code>，或者是省略掉箭头符号而直接写成 <code>&#123;...&#125;</code> 。</p>
<p>小小的特殊情况：如果闭包只需要一个参数，我们就可以在内部以 <code>it</code> 来称呼它，然后忽略掉参数命名和小箭头。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// &#123;i -&gt; print&#123;&quot;$&#123;i&#125;&quot;&#125; =====&gt; &#123;print &quot;$&#123;it&#125;&quot;&#125;</span><br><span class="hljs-comment">// foreach nums, print it. </span><br>foreach &#123;nums&#125; &#123;print(<span class="hljs-string">&quot;$&#123;it&#125; &quot;</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，如果闭包确实没有接收参数，但是写法却形如 <code>&#123;...&#125;</code>，那么 Groovy 还是会隐式地赋予这个闭包一个值为 <code>null</code> 的 <code>it</code> 参数。这会影响到程序在运行期对闭包的动态判断，见后文的动态闭包。</p>
<p>闭包的参数可以声明严格的类型，比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">foreach &#123;nums&#125; &#123;Integer i -&gt; print <span class="hljs-string">&quot;$&#123;i&#125; &quot;</span>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-2-Execute-Around-Method-amp-AOP"><a href="#4-2-Execute-Around-Method-amp-AOP" class="headerlink" title="4.2  Execute Around Method &amp; AOP"></a>4.2  Execute Around Method &amp; AOP</h2><p>在 JVM 语言当中，只要我们能够将不需要的对象标记为不可达，那么它们就可以在适当的时机被 GC 回收。但是在 I/O 密集型任务中，我们希望 InputStream 和 OutputStream 在完成任务之后<strong>马上关闭</strong>，否则它们占据的文件句柄就仍然会在 GC 主动回收之前一直处于打开状态。</p>
<p>这也是为什么 Java ( 以及其它语言的 ) I/O 工具要设计 <code>close()</code> 或者是 <code>destory()</code> 这样的方法。然而，偶尔我们可能过分专注于功能业务，而忘记主动地调用这些方法 ……</p>
<p>这种琐碎的劳动不如交给程序来解决。假定所有需要主动关闭的资源都实现了 <code>MustClosed()</code> 接口：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MustClosed</span> &#123;</span><br>    <span class="hljs-keyword">def</span> close()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，定义一个高阶函数，它接收 <code>MustClosed</code> 的实现类，并保证总是在最后调用其 <code>close()</code> 方法关闭资源，无论在使用过程中是否发生异常。至于使用这个 <code>MustClosed</code> 资源的具体细节，将它封装到另一个闭包 <code>action</code> 当中。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// r 指 Resource,指必须要主动关闭的 I/O 型资源。</span><br><span class="hljs-keyword">def</span> <span class="hljs-keyword">static</span> safeUse(MustClosed r, action) &#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        action(r)<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace()<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>        r.close()<br>        print <span class="hljs-string">&quot;$&#123;r.getClass().typeName&#125; 实例已经被关闭。&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个简单的测试：自定义一个 <code>MustClosed</code> 的简单实现，传入 <code>safeUse</code> 函数当中观察控制台的打印顺序：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">MustClosed resource = [<br>        <span class="hljs-symbol">close:</span> &#123; println <span class="hljs-string">&quot;doing close()...&quot;</span> &#125;<br>] <span class="hljs-keyword">as</span> MustClosed<br><br><span class="hljs-keyword">def</span> action = &#123; MustClosed r -&gt;<br>    println <span class="hljs-string">&quot;use resource r to do something...&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 演示了如何调用一个闭包变量</span><br>safeUse(re) &#123;action(re)&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	等价于... 这里的 re 和 r 其实都指代一个引用。</span><br><span class="hljs-comment">	safeUse(re)&#123;</span><br><span class="hljs-comment">		MustClosed r -&gt;</span><br><span class="hljs-comment">			println &quot;use resource r to do something...&quot;</span><br><span class="hljs-comment">	&#125;	</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>一个更加真实的测试：将 Java 提供的 <code>OutputStream</code> 视作是一个 <code>MustClosed</code> 的实现类传入进去，然后感受一下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;README.md&quot;</span>))<br><br><span class="hljs-comment">// 依赖于 Groovy 的动态类型判断</span><br>safeUse(fos <span class="hljs-keyword">as</span> MustClosed)&#123;r -&gt; r.write(<span class="hljs-string">&quot;Groovy!&quot;</span>.bytes)&#125;<br></code></pre></td></tr></table></figure>

<p>现在，我们无需再手动关闭传入的各种 I/O 资源，<code>safeUse</code> 会帮助搞定一切。诸如这种闭包的使用风格就是 Execute Around Method ( 环绕执行 ) 模式。把思维再发散一些，假设我们在完成一系列业务之前和之后总是要进行一些重复处理，则可以利用这种模式设计出一个模板，只需要替换掉中间不一样的业务。</p>
<p>这种方式有点似曾相识 …… 直觉是正确的。它的设计理念和 Spring 框架中的面向切面编程 AOP 没有什么不同，凡是支持 FP 的语言都可以通过环绕执行模式来实现切面化编程。</p>
<h2 id="4-3-可利用闭包自动清理资源"><a href="#4-3-可利用闭包自动清理资源" class="headerlink" title="4.3 可利用闭包自动清理资源"></a>4.3 可利用闭包自动清理资源</h2><p>Groovy 鉴于 I/O 资源类工具的这些 “痛点” 给出了相当体面的实现：它在原有的 I/O 工具类的基础上做了一些包装，我们可以在 FileOutputStream / FileInputStream 工具中，直接调用 <code>withWriter</code> 或者 <code>withReader</code> ( 字符操作 )，<code>withStream</code> ( 字节操作 ) 方法，并直接以闭包的形式告知 FileOutputStream 或者是 FileInputStream 作为 Reader / Writer / Stream 处理数据，并免去原来的装饰者模式带来的一个副作用 —— 不断地创建包装对象。在执行完之后，I/O流会自行关闭。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;README.md&quot;</span>)<br><span class="hljs-keyword">assert</span> f.exists()<br><br>fos = <span class="hljs-keyword">new</span> FileOutputStream(f)<br>String data = <span class="hljs-string">&quot;&quot;&quot;&#123;</span><br><span class="hljs-string">    status:200,</span><br><span class="hljs-string">    msg:&quot;ok&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment">// need no more fuxking close() and flush()</span><br>fos.withWriter &#123;<br>    <span class="hljs-comment">// 其实 w -&gt; w.write(data) 可以一次将长字符串全写进去。</span><br>    <span class="hljs-comment">// 这里主要是为了演示闭包的嵌套调用。</span><br>    w -&gt;<br>        data.eachLine &#123;<br>            w.write(<span class="hljs-string">&quot;$&#123;it&#125;\n&quot;</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>尤其是使用<strong>带缓冲的输出流</strong>时，我们再也不用担心因为忘记 <code>close()</code> 或者 <code>flush()</code> 而导致内容丢失的问题了。</p>
<h2 id="4-4-闭包柯里化"><a href="#4-4-闭包柯里化" class="headerlink" title="4.4 闭包柯里化"></a>4.4 闭包柯里化</h2><p>凡是涉及函数式编程的语言都能进行柯里化 ( Curry ) 变换。我们对函数 ( 或称之闭包 ) 进行柯里化变换的的目的有二：要么是希望记忆 ( 缓存) 一些参数，要么是希望推迟执行某个闭包。举个例子，下面是一个平平无奇的表达式：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">Closure&lt;Integer&gt; expr = &#123; x, y, z -&gt; (x + y) * z &#125;<br></code></pre></td></tr></table></figure>

<p>假设在实际的运行当中，我们发现参数 <code>z</code> 相较 <code>x</code> 和 <code>y</code> 而言，它的值似乎不总是变化：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// z 不总是变化</span><br>expr(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br>expr(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>)<br>expr(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)<br>expr(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<p>因此，我们希望闭包 <code>expr</code> 在一段时间之内记住 <code>z</code> 的值，以此来避免枯燥的重复传参。于是 <code>expr</code> 首先被改写成了这个样子：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">Closure&lt;Closure&lt;Integer&gt;&gt; expr = &#123;<br>    z -&gt;<br>        <span class="hljs-comment">// 对于这个闭包而言，z 是自由变量。</span><br>        <span class="hljs-keyword">return</span> &#123; x, y -&gt;<br>            (x + y) * z<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，<code>expr</code> 首先要求提供 <code>z</code>，然后再返回一个参数是 <code>x</code> 和 <code>y</code> 的子闭包，根据描述来看，赋值的过程显然是被拆分成了两步。同时，<code>expr</code> 演变成了一个高阶函数 ( 高阶闭包 ) 。如果将求值过程比作是开箱子，那么原本只需要一次开箱的取值操作变成了两次。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 之前:expr(2,3,3)</span><br><span class="hljs-comment">// 之后: </span><br><span class="hljs-keyword">def</span> result = expr(<span class="hljs-number">3</span>)(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<p>事情变得更麻烦了吗？并不是如此。如果我们率先获取 <code>expr(3)</code> ，就能提前获取被保存的 <code>z</code>  的状态。因此在后续调用中，我们只管传入不同的 <code>x</code> 和 <code>y</code> 即可。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// (x + y) * 3</span><br><span class="hljs-keyword">def</span> memoried_z = expr <span class="hljs-number">3</span><br>memoried_z(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)  <span class="hljs-comment">// expr(2,3,3)</span><br>memoried_z(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)  <span class="hljs-comment">// expr(1,6,3)</span><br>memoried_z(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)  <span class="hljs-comment">// expr(1,5,3)</span><br>memoried_z(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>)  <span class="hljs-comment">// expr(5,9,3)</span><br></code></pre></td></tr></table></figure>

<p>对于更加深层次的柯里化函数而言，随着函数参数不断被记忆，后续的调用将会变得越来越简单，所需的参数越来越少。而传递的参数越是复杂，或者传参的条目越多，函数柯里化体现出的优势就会越大。在获得所有的参数之前，柯里化函数总是返回闭包，而非真正执行，因此我们也称柯里化函数被推迟调用了。</p>
<h3 id="4-4-1-便捷的柯里化转换方法"><a href="#4-4-1-便捷的柯里化转换方法" class="headerlink" title="4.4.1 便捷的柯里化转换方法"></a>4.4.1 便捷的柯里化转换方法</h3><p>如果函数的功能再复杂一些，那么手动重构一个柯里化实现可能要花上一点时间 ( 更多的是思绪上的混乱 )。好在 Groovy 提供了一系列便捷的方法来代替我们完成柯里化转换。对于一个参数个数为 n 的函数，如果想将其前 k 个参数进行柯里化，可以调用<code>curry()</code> 方法来完成，其中 <code>0 &lt;= k &lt;= n</code>。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">expr = &#123;x, y, z -&gt; (x + y) * z&#125;<br><br><span class="hljs-comment">// 返回一个新的表达式： ( 3 + 2 ) * z =&gt; 5z</span><br>expr1 = expr.curry(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 10</span><br>println expr1(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 返回一个新的表达式: (1 + 2) * 3 = 9</span><br>println expr.curry(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)()<br></code></pre></td></tr></table></figure>

<p>如果要从后向前开始柯里化，则需使用 <code>rcurry()</code> 方法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">expr = &#123;x, y, z -&gt; (x + y) * z&#125;<br><br><span class="hljs-comment">// expr = (x + 3) * 2</span><br>expr1 = expr.rcurry(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 12</span><br>println expr1(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<p>如果要从前面的第 k 个参数开始柯里化，则需要使用 <code>ncurry()</code> 方法，其中 <code>0 &lt;= k &lt;= n</code>，当 <code>k = 0</code> 时，指从第一个参数开始柯里化，此时等价于 <code>curry()</code> 方法。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">expr = &#123;x,y,z -&gt; (x + y) * z&#125;<br><br><span class="hljs-comment">// expr1 = (x + 3) * 2</span><br>expr1 = expr.ncurry(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 10</span><br>println expr1(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<h2 id="4-5-动态闭包"><a href="#4-5-动态闭包" class="headerlink" title="4.5 动态闭包"></a>4.5 动态闭包</h2><p>Groovy 可以在程序运行时动态地判断传入闭包的参数列表长度，甚至是参数类型，我们可以利用这个特性赋予程序动态决策的能力。比如：假定公司要根据营收额来统计交税额。我们想以闭包的形式将税额计算方法传递到一个高阶函数当中去计算。然而，这个闭包有可能不需要提供税率 ( 用户直接给出计算公式 )，也有可能需要 ( 用户仅提供计算方法，此时由高阶函数提供一个默认值)：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> tax(Double amount,Closure computer)&#123;<br>    <span class="hljs-keyword">switch</span> (computer.maximumNumberOfParameters)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> : <span class="hljs-keyword">return</span> computer(amount)<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> : <span class="hljs-keyword">return</span> computer(amount,<span class="hljs-number">15</span>)<br>        <span class="hljs-symbol">default:</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;need 1 or 2 args.&quot;</span>)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 这个闭包传入了税率计算方式以及税率，只需要 1 个参数</span><br>println tax(<span class="hljs-number">14000.0</span>) &#123;<br>        amount -&gt; amount * <span class="hljs-number">0.13</span><br>&#125;<br><br><span class="hljs-comment">// 这个闭包不主动传入税率 rage，有 2 个参数</span><br>println tax(<span class="hljs-number">14000.0</span>) &#123;<br>    amount,rage -&gt; amount * (rage/<span class="hljs-number">100</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 Groovy 能够确定一个参数是闭包，那么可以访问其 <code>.maxinumNumberOfParameters</code> 属性来判断闭包传入时实际的参数个数。如果用户不提供税率，那么就直接按照用户的公式计算交税额。否则，由高阶函数给出一个默认税率并计算。</p>
<p>除了动态判断参数的个数，还可以使用 <code>parameterTypes</code> 属性来动态获取参数的实际类型。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> check(Closure cls)&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(args <span class="hljs-keyword">in</span> cls.parameterTypes) &#123; println <span class="hljs-string">&quot;type[$&#123;i&#125;] = $&#123;args.typeName&#125;&quot;</span>;i++&#125;<br>    <span class="hljs-comment">//.. 什么也不做</span><br>&#125;<br><br><span class="hljs-comment">// type[1] = java.lang.String</span><br>check &#123;<br>    String i -&gt; <span class="hljs-comment">//.. 什么都不做</span><br>&#125;<br><br><span class="hljs-comment">// type[1] = java.lang,Integer</span><br>check &#123;<br>    Integer i -&gt; <span class="hljs-comment">//.. 还是什么也不做</span><br>&#125;<br><br><span class="hljs-comment">//type[1] = java.lang.Integer</span><br><span class="hljs-comment">//type[2] = java.lang.String</span><br>check &#123;<br>    Integer i , String s -&gt; <span class="hljs-comment">//.. 仍然什么也不做</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，前文曾提到过，如果闭包不需要任何参数，那么形式上可以写为 <code>&#123;...&#125;</code> 或者是 <code>&#123; -&gt; ...&#125;</code>，两者的区别是：Groovy 仍然会为前者赋予一个隐含的参数 <code>it</code>，只不过这个值是 <code>null</code>。但对于后者，Groovy 则认为这个它是一个严格的无参数闭包。</p>
<h2 id="4-6-闭包执行上下文与闭包委托"><a href="#4-6-闭包执行上下文与闭包委托" class="headerlink" title="4.6 闭包执行上下文与闭包委托"></a>4.6 闭包执行上下文与闭包委托</h2><p>假设这是一个闭包：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> closure = &#123;<br>	func()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显然，如果没有其它的线索，那么就很难说 <code>func()</code> 调用是从哪来的。先把这个问题搁置在一边，我们有更重要的概念需要提及。</p>
<p>Groovy 为每一个闭包都定义了三个属性：<code>thisObject</code>，<code>owner</code>，<code>delegate</code>。所有的闭包都和它所在类的实例相绑定，并且会被 Groovy 编译成一个内部类的实例。对于一般的闭包，<code>this == owner == delegate</code> ，比如说外部的 <code>out</code> 闭包。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Example_</span>&#123;</span><br>    <span class="hljs-keyword">def</span> out = &#123;<br>        <span class="hljs-comment">// 这是相对而言的内部闭包。</span><br>        <span class="hljs-keyword">def</span> inner = &#123;&#125;<br>        <span class="hljs-comment">//------test of thisObject, owner, delegate----------//</span><br>        println out.thisObject.getClass().name		<span class="hljs-comment">//_Example_</span><br>        println out.owner.getClass().name			<span class="hljs-comment">//_Example_</span><br>        println out.delegate.getClass().name		<span class="hljs-comment">//_Example_</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> _Example_().out()<br></code></pre></td></tr></table></figure>

<p>但对于一些特殊情况就有所不同了：第一种情况是闭包嵌套的情况。比如说 <code>out</code> 闭包内部定义的  <code>inner</code> 闭包。如果访问该 <code>inner</code> 闭包的 <code>owner</code> ，它将指向外部闭包 <code>out</code> 的实例。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Example_</span>&#123;</span><br>    <span class="hljs-keyword">def</span> out = &#123;<br>        <span class="hljs-comment">// 这是相对而言的内部闭包。</span><br>        <span class="hljs-keyword">def</span> inner = &#123;&#125;<br><br>        <span class="hljs-comment">//------test of thisObject, owner, delegate----------//</span><br>        println out.thisObject.getClass().name		<span class="hljs-comment">//_Example_</span><br>        println out.thisObject.hashCode()           <span class="hljs-comment">// == inner.thisObject.hashCode</span><br>        println out.owner.getClass().name			<span class="hljs-comment">//_Example_</span><br>        println out.delegate.getClass().name		<span class="hljs-comment">//_Example_</span><br><br>        println inner.thisObject.getClass().name    <span class="hljs-comment">//_Example_</span><br>        println inner.thisObject.hashCode()         <span class="hljs-comment">// == out.thisObject.hashCode</span><br>        println inner.owner.getClass().name         <span class="hljs-comment">//_Example_$_closure1 (指外部闭包被编译的内部类)</span><br>        println inner.delegate.getClass().name      <span class="hljs-comment">//_Example_$_closure1 (指外部闭包被编译的内部类)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> _Example_().out()<br></code></pre></td></tr></table></figure>

<p>在第二种特殊情况下，<code>delegate</code> 将不再指向 <code>owner</code>，那就是进行<strong>闭包委托</strong>的情形。用简单的话来概述它，就是闭包内部调用的一些方法，<strong>可能</strong>来自于另一个委托类的实例。声明如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// &quot;代理类&quot;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Proxy_</span>&#123;</span>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Example_</span>&#123;</span><br>    <span class="hljs-keyword">def</span> out = &#123;<br>        <span class="hljs-keyword">def</span> inner = &#123;&#125;<br>        inner.delegate = <span class="hljs-keyword">new</span> _Proxy_()<br>        <br>        <span class="hljs-comment">// thisObject, owner, delegate 都不一样。</span><br>        println inner.thisObject.getClass().name<br>        println inner.owner.getClass().name<br>        println inner.delegate.getClass().name<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//_Example_</span><br><span class="hljs-comment">//_Example_$_closure1</span><br><span class="hljs-comment">//_Proxy_</span><br><span class="hljs-keyword">new</span> _Example_().out()<br></code></pre></td></tr></table></figure>

<p>理解这三个闭包的基本属性之后，再去解释本节开头的那个问题就容易得多了：如果一个闭包内部使用的方法或变量在局部块内没有，那么 Groovy 优先在 <code>thisObject</code> 或者 <code>owner</code> 域查找；否则，试图从 <code>delegate</code> 那里查找；否则，就会报错返回。如果能在前两个域当中找到合适的内容，那么 Groovy 就绝对不会 “打扰” <code>delegate</code>。</p>
<p>观察下面的完整代码。由于 <code>_Example_ </code> 类定义了 <code>func1</code> ，<code>out</code> 闭包定义了<code>func2</code>，因此即便是 <code>inner</code> 设置了闭包代理，Groovy 也没有进行路由。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Proxy_</span>&#123;</span><br>    <span class="hljs-keyword">def</span> func1 = &#123; println <span class="hljs-string">&quot;this [func1] is from the instance of Class: _Proxy_&quot;</span> &#125;<br>    <span class="hljs-keyword">def</span> func2 = &#123; println <span class="hljs-string">&quot;this [func2] is still from the instance of Class: _Proxy_&quot;</span> &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Example_</span>&#123;</span><br><br>    <span class="hljs-keyword">def</span> func1 = &#123; println <span class="hljs-string">&quot;this [func1] is from the instance of Class:_Example_.&quot;</span>&#125;<br>    <span class="hljs-keyword">def</span> out = &#123;<br>        <span class="hljs-keyword">def</span> func2 = &#123; println <span class="hljs-string">&quot;this [func2] is from the instance of closure:out&quot;</span>&#125;<br>        <span class="hljs-keyword">def</span> inner = &#123;<br>            func1()<br>            func2()<br>        &#125;<br>        inner.delegate = <span class="hljs-keyword">new</span> _Proxy_()<br>        inner()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//this [func1] is from the instance of Class:_Example_.</span><br><span class="hljs-comment">//this [func2] is from the instance of closure:out</span><br><span class="hljs-keyword">new</span> _Example_().out()<br></code></pre></td></tr></table></figure>

<p>一旦注释掉 <code>_Example_</code> 内部的 <code>func1</code> 或者是 <code>func2</code> 闭包，Groovy 就会从 <code>_Proxy_</code> 那里尝试弥补缺失的内容，从而给出不同的运行结果。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Proxy_</span>&#123;</span><br>    <span class="hljs-keyword">def</span> func1 = &#123; println <span class="hljs-string">&quot;this [func1] is from the instance of Class: _Proxy_&quot;</span> &#125;<br>    <span class="hljs-keyword">def</span> func2 = &#123; println <span class="hljs-string">&quot;this [func2] is still from the instance of Class: _Proxy_&quot;</span> &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Example_</span>&#123;</span><br>    <span class="hljs-keyword">def</span> out = &#123;<br>        <span class="hljs-keyword">def</span> inner = &#123;<br>            func1()<br>            func2()<br>        &#125;<br>        inner.delegate = <span class="hljs-keyword">new</span> _Proxy_()<br>        inner()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//this [func1] is from the instance of Class: _Proxy_</span><br><span class="hljs-comment">//this [func2] is still from the instance of Class: _Proxy_</span><br><span class="hljs-keyword">new</span> _Example_().out()<br></code></pre></td></tr></table></figure>

<p>另一种闭包委托的声明方式会令 Groovy 倒置查找顺序：即优先选择 <code>delegate</code> 的方法，其次才是 <code>owner</code> 或 <code>thisObejct</code>。具体做法是通过调用一个对象的 <code>.with</code> 方法 “外挂” 闭包。如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Proxy_</span>&#123;</span><br>    <span class="hljs-keyword">def</span> func1 = &#123; println <span class="hljs-string">&quot;this [func1] is from the instance of Class: _Proxy_&quot;</span> &#125;<br>    <span class="hljs-keyword">def</span> func2 = &#123; println <span class="hljs-string">&quot;this [func2] is still from the instance of Class: _Proxy_&quot;</span> &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Example_</span>&#123;</span><br>    <span class="hljs-keyword">def</span> func1 = &#123; println <span class="hljs-string">&quot;this [func1] is from the instance of Class: _Example_&quot;</span> &#125;<br>    <span class="hljs-keyword">def</span> func2 = &#123; println <span class="hljs-string">&quot;this [func2] is still from the instance of Class: _Example_&quot;</span> &#125;<br>    <span class="hljs-keyword">def</span> out = &#123;<br>        <span class="hljs-keyword">def</span> inner = &#123;<br>            func1()<br>            func2()<br>        &#125;<br>        <span class="hljs-keyword">new</span> _Proxy_().with inner<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//this [func1] is from the instance of Class: _Proxy_</span><br><span class="hljs-comment">//this [func2] is still from the instance of Class: _Proxy_</span><br><span class="hljs-keyword">new</span> _Example_().out()<br></code></pre></td></tr></table></figure>

<p>注，<code>delegate</code> 在涉及 DSL 的方面会变得非常有用。</p>
<h2 id="4-7-尾递归"><a href="#4-7-尾递归" class="headerlink" title="4.7 尾递归"></a>4.7 尾递归</h2><p>递归代码常常被认为是 “有品位但是不好驾驭” 的典型，和迭代相比，递归从表达上可能更加晦涩，因此令大部分程序员避之不及。令一个经常遇到的麻烦是：当递归的层次过深时，JVM 会招架不住而抛出一个 <code>StackOverFlowError</code> 。我们都知道，JVM 的每一个线程都使用一个栈空间来管理它调用的函数，并为每一个函数分配一个栈帧。如果这个栈一直处于 “只进不出” 的状态，那么 JVM 理论上就有驾崩的危险。</p>
<p>解决栈溢出的思路却又很简单：只要让栈维持 “边进边出” 的状态就可以了。具体的做法是：将一般的递归函数改进成尾递归。尾递归的意思是：当调用下一个函数时，当前的调用直接将返回值传递给它，并且没有后续计算，线程也自然就认为没有必要保存当前调用的栈帧。</p>
<p>用一个例子来说明或许更实在一点：n 的阶乘。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为什么这个方法不是尾递归？</span><br><span class="hljs-comment"> * 如果它的返回值是 n * factorial(n-1)，那么本次调用就需要等待下一次调用的 factorial(n-1) 来计算返回值。</span><br><span class="hljs-comment"> * 因此，假定 n == 3 , 那么线程就需要 3 层栈空间来解决它。</span><br><span class="hljs-comment"> * 假定 n 取了更大的值 , 那么 JVM 就会呻吟了。</span><br><span class="hljs-comment"> * @param n</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">int</span> factorial(<span class="hljs-keyword">int</span> n)&#123;<br>   <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> :n * factorial(n<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-keyword">import</span> groovy.transform.TailRecursive<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为什么这个方法是尾递归？</span><br><span class="hljs-comment"> * 无论是哪个分支，该递归函数总是返回一个数值或者发起一个新的调用，且当前调用没有需要等待的后续运算了。</span><br><span class="hljs-comment"> * 而递归过程的中间结果会不断地被装入 acc 参数中并传递。</span><br><span class="hljs-comment"> * 所以，在当前调用结束之后，它可以安全地 &quot;传宗接代且无后顾之忧&quot;。 </span><br><span class="hljs-comment"> * 无论 n 取何值，这个尾递归始终只占用 1 层栈空间。</span><br><span class="hljs-comment"> * 唯一不太方便的是，用户调用这个函数需要主动为 acc 传递一个初始值，而我们一般都靠包装函数来解决这个瑕疵。</span><br><span class="hljs-comment"> * @param n</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@TailRecursive</span><br><span class="hljs-keyword">int</span> factorial_t(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> acc)&#123;<br>    <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">1</span> ? acc : factorial_t(n<span class="hljs-number">-1</span>,acc * n)<br>&#125;<br><br><span class="hljs-comment">// good</span><br>println factorial_t(<span class="hljs-number">10000</span>,<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// bad, 99.99% 报错</span><br>println factorial(<span class="hljs-number">10000</span>)<br></code></pre></td></tr></table></figure>

<p>其中，<code>@TailRecursive</code> 注解负责检查函数，如果它不是严格尾递归的，那么就会在编译器期间报错。闭包版本的尾递归则和函数版本不太一样，其尾递归需要借助 <code>trampoline</code> ( 意 “弹簧床” ) 方法来实现。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 对于递归闭包，我们必须先定义出一个变量作为它的名字，才能在闭包内部调用自身。</span><br><span class="hljs-keyword">def</span> f <br><br>f = &#123;<br>    i, BigInteger n -&gt; i &lt;= <span class="hljs-number">1</span> ? n : f.trampoline(i - <span class="hljs-number">1</span>, n * i)<br>&#125;.trampoline()<br><br>f(<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>

<p>另外，考虑到用户体验，不妨将闭包的 <code>acc</code> 参数设置为默认值 1 ( 因为它是最后一个参数 )，因此该参数对用户来说可以是透明的。需要指出的是，同等的算法逻辑和入参，函数的执行速度要比闭包快得多。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">BigInteger factorial_func(<span class="hljs-keyword">int</span> i, BigInteger n) &#123;<br>    i &lt;= <span class="hljs-number">1</span> ? n : factorial_func(i - <span class="hljs-number">1</span>, n * i)<br>&#125;<br><br>factorial_closure = &#123;<br>    i, BigInteger n = <span class="hljs-number">1</span> -&gt; i &lt;= <span class="hljs-number">1</span> ? n : factorial_closure.trampoline(i - <span class="hljs-number">1</span>, n * i)<br>&#125;.trampoline()<br><br>l1 = System.currentTimeMillis()<br>println factorial_closure(<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">// 250 ~ 300 millis</span><br>println System.currentTimeMillis() - l1<br><br>l1 = System.currentTimeMillis()<br>println factorial_func(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> BigInteger)<br><br><span class="hljs-comment">// 4 ~ 10 millis</span><br>println System.currentTimeMillis() - l1<br></code></pre></td></tr></table></figure>

<h2 id="4-8-从钢条切割问题探讨递归优化"><a href="#4-8-从钢条切割问题探讨递归优化" class="headerlink" title="4.8 从钢条切割问题探讨递归优化"></a>4.8 从钢条切割问题探讨递归优化</h2><blockquote>
<p>该问题参考自：<a href="https://www.cnblogs.com/tgycoder/p/4980655.html">动态规划-钢杆切割问题 - RunningSnail - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>假定我们是钢杆 ( 或者称钢条 ) 的卖家，不同长度的钢杆价位不同，**且钢杆长度和价格并不是线性相关的 ( 这就表明了整根卖不一定获利最大 ) **。现在给定一个长钢杆，我们希望对它做一些切割以获得最大利润。长度为 <code>n</code> 的钢杆，它的价格记作 <code>rodPrices[n]</code>  ：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">Integer<span class="hljs-comment">[]</span> rodPrices = <span class="hljs-comment">[0, 1, 3, 4, 5, 8, 9, 11, 12, 14, 15, 15, 16, 18, 19, 15, 20, 21, 22, 24, 25, 24, 26, 28, 29, 35, 37, 38, 39, 40]</span><br></code></pre></td></tr></table></figure>

<p>比如，长度为 2 的钢杆，它的价格为 3，而长度为 5 的钢杆，它的价格仅为 8 ( 性价比似乎还 “提高” 了) 。此外，这里为了消除 0 下标的 “错位” 影响，令 <code>rodPrices[0] == 0</code> 。第一问：首先求长度为 27 的钢杆，它所能获得的最大利润。</p>
<p>最朴素的想法是：穷举所有的切割方案并择优选取。一提及穷举，我们自然就会想到迭代，或者递归，或者<strong>两者兼具</strong>。</p>
<p>进一步思考，每次将一段长杆 <code>l</code> 切割，都会产生两个短杆 <code>s1</code> ，<code>s2</code> 。设长度为 <code>n</code> 的钢杆的最大利润为 <code>max(n)</code>，那显然我们只要求出 <code>max(s1)</code> 和 <code>max(s2)</code>，那么就能推算出 <code>max(l) = max(s1) + max(p2)</code> 。那 <code>max(s1)</code>又该怎么求呢？它肯定又能分出更短的杆 <code>ss1</code> 和 <code>ss2</code> ，我们继续求 <code>max(ss1)</code> 和 <code>max(ss2)</code> 就好了 ……</p>
<p>从这段描述中，我们能够提取出四个要点：</p>
<ol>
<li>大问题的目的是求最优解。</li>
<li>大问题可以分解成若干小问题。</li>
<li>大问题的最优解依赖于小问题的最优解。</li>
<li>我们现在正 “自上而下” 地将大问题不断分解成小问题。</li>
</ol>
<p>因此，钢杆 ( 钢条 ) 切割问题本质上是一道<strong>动态规划</strong>题。在下面的叙述中，我们将 “求长度为 <code>length</code> 的钢杆的最大利润” 封装为一个函数 <code>rodCut(length)</code> 。</p>
<p>设传进来长度为 <code>length</code> 的长杆，切割后的两杆其一为 <code>s1</code> ，长度记作 <code>i</code>；而另一个 <code>s2</code> 的长度则为 <code>length - i</code>。我们在一个<strong>迭代</strong>中动态平衡两杆的长度，且在每一次迭代内部，保留 <code>s1</code> 的长度不变，假设它的当前最优解就是 <code>max&#39;(s1)</code> 。以此为前提去对 <code>s2</code> 进行<strong>递归切割</strong>，即调用 <code>rodCut(s2)</code>。</p>
<p>我们确信 <code>rodCut</code> 总能正确的返回 <code>max(s2)</code>，因此每次迭代的 <code>max&#39;(length) = max&#39;(s1) + rodCut(s2)</code> 。在迭代完成后，只需要从这些结果值中取出实际最大值作为当前 <code>rodCut(length)</code> 调用的返回值即可。</p>
<p><img  src="https://i.im5i.com/2021/04/30/wzxVQ.png"  ><span class="image-caption">表达式</span></p>
<p>另外还有一个细节：如果在某一次迭代中  <code>s1 </code> 的长度 <code>i == length</code>，那么显然 <code>s2 == 0</code> 。这时表示不对长度 <code>length</code> 的杆进行切割，此时 <code>max(length) == rodPrices[length]</code> 。</p>
<p>根据上述思路，我们迅速给出了第一版解决方案：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">Integer rodCut(Integer[] rodPrices, length) &#123;<br><br>    <span class="hljs-comment">// 虽然 length[0] 即为 0，但是我们想让调用短路返回，而不是继续执行。</span><br>    <span class="hljs-comment">// 这个 if 不可省略。</span><br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> max = <span class="hljs-number">-1</span><br><br>    <span class="hljs-comment">// &quot;左杆&quot; s1 的长度至少为 1，否则就没意义。</span><br>    <span class="hljs-comment">// 当 length = 1 时， length -1 = 0， 调用会进入临界条件。</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.length) &#123;<br>        <span class="hljs-keyword">def</span> p = rodPrices[i] + rodCut(rodPrices, length - i)<br>        <span class="hljs-keyword">if</span> (p &gt; max) max = p<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在提出一个新的要求：不仅要求出最大利润，还要给出详细的切割方案。比如：长度为 <code>27</code>  的杆，它的最大利润是 <code>43</code>，切割方案是：<code>[5,5,5,5,5,2]</code> ，数组内的每个元素是短杆的长度。</p>
<p>此时不仅要在迭代过程中寻求最优解，还要在此记录每一次求得最优解时短杆的长度。出于这个目的，我们设计出了如下数据结构：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@Canonical</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> &#123;</span><br>    Integer amount<br>    ArrayList splits<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Plan 表示一个切割方案，比如 <code>new Plan(amount: 4, splits:[1,2])</code> 表示这个切割方案中有长度为 1 和 2 的两个子杆，这个方案的总收入为 4。</p>
<p><code>splits</code> 是线性表，用于记录短杆的长度。可以预见的是：长杆 Plan 的创建基于短杆 Plan，新的 <code>splits</code> 总是之前 Plan 的 <code>splits</code> 再插入一个新的元素，而链表能够从容地应对不断追加元素的场合，所以 <code>splits</code> 被设置为 ArrayList 类。</p>
<p>第二版解决方案也出炉了：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@Newify</span>(Plan)<br><span class="hljs-keyword">def</span> rodCut(rodPrices, length) &#123;<br><br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Plan(<span class="hljs-attr">amount:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">splits:</span> [])<br><br>    <span class="hljs-keyword">def</span> max = Plan(<span class="hljs-attr">amount:</span> <span class="hljs-number">-1</span>, <span class="hljs-attr">splits:</span> [])<br><br>    <span class="hljs-comment">// 至少切割成 (1,length-1)，否则没有意义。</span><br>    <span class="hljs-comment">// 当 length = 1 时， length - 1 = 0， 要考虑到边界条件。</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.length) &#123;<br>        <br>        <span class="hljs-comment">// left : 这里是 &quot;剩下的&quot; 意思。</span><br>        <span class="hljs-comment">// 获得 &quot;右杆&quot; s2 的最优 Plan</span><br>        <span class="hljs-keyword">def</span> leftRod = rodCut(rodPrices, length - i)<br><br>        <span class="hljs-comment">// 推算当前迭代中的 &quot;最优&quot; Plan = &quot;左杆&quot; Plan + &quot;右杆&quot; Plan</span><br>        <span class="hljs-keyword">def</span> try_ = Plan(<span class="hljs-attr">amount:</span> rodPrices[i] + leftRod.amount, <span class="hljs-attr">splits:</span> leftRod.splits + i)<br><br>        <span class="hljs-keyword">if</span> (try_.amount &gt; max.amount) max = try_<br>    &#125;<br><br>    <span class="hljs-comment">// 返回实际的长度 Length 的杆所对应的最优 Plan.</span><br>    <span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，这里存在 Groovy 的语法糖：那就是 <code>leftRod.split + i</code>。这是一个操作符重载，实际上可理解为 <code>leftRod.splits.add(i)</code> 。该算法的 Groovy 闭包版本是：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> rodCuts<br><br>rodCut = &#123;<br>    rod_prices, length -&gt;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Plan(<span class="hljs-attr">amount:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">splits:</span> [])<br>        <span class="hljs-keyword">def</span> max = <span class="hljs-keyword">new</span> Plan(<span class="hljs-attr">amount:</span> <span class="hljs-number">-1</span>, <span class="hljs-attr">splits:</span> [])<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.length) &#123;<br>            <span class="hljs-keyword">def</span> leftRod = rodCut(rodPrices, length - i)<br>            <span class="hljs-keyword">def</span> try_ = <span class="hljs-keyword">new</span> Plan(<span class="hljs-attr">amount:</span> rodPrices[i] + leftRod.amount, <span class="hljs-attr">splits:</span> leftRod.splits + i)<br>            <span class="hljs-keyword">if</span> (try_.amount &gt; max.amount) max = try_<br>        &#125;<br>        <span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-8-1-利用记忆化改进性能"><a href="#4-8-1-利用记忆化改进性能" class="headerlink" title="4.8.1 利用记忆化改进性能"></a>4.8.1 利用记忆化改进性能</h3><p>人们常说：过早的优化是万恶之源。因此在之前笔者刻意回避了 <code>rodCut</code> 函数的运行效率。运行第二版的函数 / 闭包，程序需要运行大约 1 ~ 2 分钟的时间才能给出答案。</p>
<p>为什么会这样？我们其实还忽略了第五个要点：那就是将大问题分解为小问题时，应当避免对重复的小问题求解。比如：”将长为 10 的杆分为两个 5”  和 “将长为 8 的杆分成 3 和 5” 的两个情形都涉及到 “求杆长为 5 的最优解”。很不巧的是，在目前的递归过程中，<code>rodCut</code> 函数对传进来的 <code>length</code> 几乎来者不拒，却从来不检讨这个计算有无必要。</p>
<p>一个简单却十分有效的办法是，在调用这个函数的同时，传入一个足够长的 <code>cache</code> 数组作为缓存。其中，<code>cache[n]</code> 存储了长为 <code>n</code> 的杆的最佳方案，但在最开始，所有位置都是 <code>null</code> 。不过每次在 <code>rodCut</code> 返回计算结果之前，都会顺带着将它写入到这个缓存的对应位置内。</p>
<p>在后续的递归调用中，程序优先从查找缓存的对应位置：如果该位置非 <code>null</code>，则意味着当前调用能够立刻返回计算结果，而非重新计算。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> rodCuts_cached<br><br>rodCuts_cached = &#123;<br><br>    Integer[] rod_prices, Integer length, Plan[] cache -&gt;<br><br>        <span class="hljs-keyword">if</span> (cache[length] != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> cache[length]<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Plan(<span class="hljs-attr">amount:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">splits:</span> [])<br>        <span class="hljs-keyword">def</span> max = <span class="hljs-keyword">new</span> Plan(<span class="hljs-attr">amount:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">splits:</span> [])<br><br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.length) &#123;<br>            <span class="hljs-keyword">def</span> leftRod = rodCuts_cached(rod_prices, length - i, cache)<br>            <span class="hljs-keyword">def</span> try_ = <span class="hljs-keyword">new</span> Plan(<span class="hljs-attr">amount:</span> rod_prices[i] + leftRod.amount, <span class="hljs-attr">splits:</span> leftRod.splits + i)<br>            <span class="hljs-keyword">if</span> (try_.amount &gt; max.amount) &#123;<br>                max = try_<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 记录当前最优解。</span><br>        <span class="hljs-comment">// 注意，传入的 cache 是引用，这意味着任意一处递归都能够随时感知 cache 的变化。</span><br>        cache[length] = max<br>        <span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>

<p>依照这个思路，我们重新给出了第三版代码。在同等运行条件下，它的运算时间只相当于第二版的 1%。</p>
<p>这个套路其实和之前 n 阶乘的优化思路非常相像，那就是想方设法保存中间结果来节省后续递归的工作量，无论从形式上是值传递一个计算结果，还是引用传递一块缓存。如果为这个套路起一个专业点的名字，那么它就是 <strong>记忆化</strong> ( Memoization ) 。</p>
<h3 id="4-8-2-画龙点睛之-memoize"><a href="#4-8-2-画龙点睛之-memoize" class="headerlink" title="4.8.2 画龙点睛之 memoize()"></a>4.8.2 画龙点睛之 memoize()</h3><p>我们已经从实例中理解并体会了函数记忆化带来的性能飞跃，体贴的 Groovy 同样也更理解我们。在其它语言中，我们可能会为了实现缓存而手写一段逻辑代码 ( 像第三版代码那样 ) 。但至少在 Groovy 中，实际的工作量就是在原有闭包的基础之上再补充上一个 <code>momonize()</code> 方法调用。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> rodCuts<br>rodCut = &#123;<br>    rod_prices, length -&gt;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Plan(<span class="hljs-attr">amount:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">splits:</span> [])<br>        <span class="hljs-keyword">def</span> max = <span class="hljs-keyword">new</span> Plan(<span class="hljs-attr">amount:</span> <span class="hljs-number">-1</span>, <span class="hljs-attr">splits:</span> [])<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.length) &#123;<br>            <span class="hljs-keyword">def</span> leftRod = rodCuts(rod_prices, length - i)<br>            <span class="hljs-keyword">def</span> try_ = <span class="hljs-keyword">new</span> Plan(<span class="hljs-attr">amount:</span> rodPrices[i] + leftRod.amount, <span class="hljs-attr">splits:</span> leftRod.splits + i)<br>            <span class="hljs-keyword">if</span> (try_.amount &gt; max.amount) max = try_<br>        &#125;<br>        <span class="hljs-keyword">return</span> max<br>&#125;.memoize()<br></code></pre></td></tr></table></figure>

<p>Groovy 会为此创建一个自带缓存空间的闭包，然后就像我们所做的一样，闭包在递归自身时会优先从缓存中读取运算结果，除此之外，Groovy 还考虑到了一些线程安全的内容。由于机制大体相同，因此这一版的运行效率跟第三版代码几乎差不多，而区别是 “我们操心的活变得更少了”。</p>
<p>根据天下没有免费的午餐定理，争取运算时间的代价将是牺牲或多或少的空间。如果问题的规模变得夸张一些，那么对空间的占用就无法忽略 ( 尤其是在本例中，Plan 还是一个携带链表的类 ) 。Groovy 将选择的权利交给了我们，因此 <code>memonized()</code> 还衍生出了 <code>memonizeAtMost()</code> 方法以及其它变种。当缓存达到临界状态时，Groovy 采取 LRU ( Least Last Used ) 策略对缓存内容进行替换。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>Groovy 动态类型</title>
    <url>/2021/04/25/groovy%20%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="3-Groovy-动态类型"><a href="#3-Groovy-动态类型" class="headerlink" title="3. Groovy 动态类型"></a>3. Groovy 动态类型</h1><p>所谓动态语言，指各种类型在程序的运行时进行推断，方法和实参也在运行时进行检查。这样，我们就能够在运行时向类注入行为，从而让代码和严格的静态类型相比有更好的拓展性。简而言之，利用动态类型，可以使用比 Java 更少的代码来实现更灵活的设计。</p>
<h2 id="3-1-Java-中的类型检查"><a href="#3-1-Java-中的类型检查" class="headerlink" title="3.1 Java 中的类型检查"></a>3.1 Java 中的类型检查</h2><p>Java 是一门强类型的静态语言，细致到连一个分号都不漏掉。”牺牲自由以换取了最大安全”。大部分时间，Java 编译器就像一位啰嗦的老婆婆。在下面的代码中，虽然我们确信 <code>super.clone()</code> 的机制决定了它一定能够返回 <code>User_</code> 类型，但是编译器仍然要求代码在此做一步显示地转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User_</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> Address_ address;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> User_ <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (User_) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br><br>	<span class="hljs-comment">// 省略 构造器</span><br>	<span class="hljs-comment">// 省略 toString</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address_</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String street;<br>    <span class="hljs-keyword">public</span> String houseNumber;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Address_ <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (Address_) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>	<span class="hljs-comment">// 省略 构造器</span><br>	<span class="hljs-comment">// 省略 toString</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在调用克隆方法时，编译器也总是坚持要求我们处理这个受检异常 ( 除非给它抛到上级 )，尽管我们能确保这个 <code>CloneNotSupportedException</code> 不会发生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    User_ clone = user_.clone();<br>    System.out.println(clone.toString());<br>&#125;<span class="hljs-keyword">catch</span> (CloneNotSupportedException ex)&#123;<br>    ex.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-2-动态类型带来了什么"><a href="#3-2-动态类型带来了什么" class="headerlink" title="3.2 动态类型带来了什么"></a>3.2 动态类型带来了什么</h2><p>一些在 Java 编译器看来比较 “离谱” 的操作 ( 比如访问一个 Object 类型的 <code>name</code> 字段，或者去调用其它的 Object 本身不存在的方法)，对于支持动态类型的语言来说，只要它在运行期间得到了正确的解释，那这个操作看起来就没有任何问题。</p>
<p>这些  “不应该存在” 的错误，编译器全部放弃了拦截 —— 它假定运行期间这些问题都会随着动态确认或者注入而被解决。其好处是当这个前提确定为真的情况下，我们可以 “面向直觉编程”，并且不用再为了取悦编译器而一次次地添加显示的类型转换。</p>
<p>当然，这不是说动态类型就是万能的。我们先暂且抛出动态类型的风险和代价不提，一个智能又体贴的编程语言，当然谁都愿意用，比如隔壁的 Python。将开头的那个例子使用 Groovy 去实现，我们发现代码被简化了很多：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> groovy.transform.Canonical<br><br><span class="hljs-meta">@Canonical</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> &#123;</span><br>    String name<br>    Address address<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">def</span> clone() <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-built_in">super</span>.clone()<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Canonical</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> &#123;</span><br>    String street<br>    String houseNumber<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">def</span> clone() <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>         <span class="hljs-built_in">super</span>.clone()<br>    &#125;<br>&#125;<br><br>user1 = <span class="hljs-keyword">new</span> User(<span class="hljs-attr">name:</span><span class="hljs-string">&quot;Wang Fang&quot;</span>,<span class="hljs-attr">address:</span> <span class="hljs-keyword">new</span> Address(<span class="hljs-attr">street:</span><span class="hljs-string">&quot;LA&quot;</span>,<span class="hljs-attr">houseNumber:</span> <span class="hljs-string">&quot;132-052&quot;</span>))<br>user2 = user1.clone()<br><br><span class="hljs-comment">// 编译器不会报错，并且能够再运行时反馈正确的结果</span><br><span class="hljs-comment">// 唯一的坏处是，IDE 可能不会给出合理的代码提示。</span><br>println user2.name<br>println user2.address.street<br><br><span class="hljs-comment">// 这个方法印证了 user2 和 user1 不是同一个引用。</span><br>println user2.is(user1)<br><br><span class="hljs-comment">// 注意，Groovy 计算 HashCode 的方式和 Object 不完全相同。</span><br><span class="hljs-comment">// 因此如果比较 user1.hashCode() == user2.hashCode() 得到的结果是 true.</span><br><span class="hljs-comment">// 如果要在 Groovy 中根据传统的 hashCode() 比较两者是否为同一引用，那么需要令 User 主动调用来自 Object 的 super.hashCode() 方法。</span><br></code></pre></td></tr></table></figure>

<p>首先，Groovy 不强制要求处理异常，我们首先节约了一段 try-catch 。其次，根据 <code>clone()</code> 方法的声明，<code>user2</code> 原本是一个 Object，但我们都知道它肯定是一个 User 类型。因此即使在没有任何强制转换的前提下直接访问 <code>user2</code> 的 <code>name</code>，<code>address</code> 属性，Groovy 编译器也没有多加抱怨。</p>
<p>需要注意的是，Groovy 和 Java 一样都是<strong>强语言</strong>类型。如何判断 “强弱”，<strong>目前的共识是</strong>：当发生类型不兼容问题时，程序是尽可能进行强制转换，还是直截了当的给出错误。如果是后者，那这门语言就是强类型[^0]。其实，Groovy 和 Java 都是这么做的。而这对哥俩之间的区别是：Java 早在编译期就会指出不合理的类型转换，并提示：<code>inconvertible types: can not cast &#39;XXX&#39; to &#39;xxx&#39;</code> 。宽容的 Groovy 首先假设我们的所作所为是合理的，然后将这个检查过程推迟到了运行时期。</p>
<p>如果以静态，非静态，强类型，弱类型对编程语言进行划分，这实际上可以划分出四个区间。这里援引一张网络图片：</p>
<p><img  src="https://i.im5i.com/2021/04/25/wnNHl.jpg"  ><span class="image-caption">强弱类型的语言划分</span></p>
<p>在这里需要指出 JVM 语言家族的一个小家碧玉：Scala。”偷天换日” 是它的拿手好戏，程序员可以先自定义一些隐式转换函数，再快乐地基于这些上下文规则进行 “弱类型” 编程，然后 scalac 会在编译期间会偷偷地调用转换函数来保持兼容性 ( 总之，编译器和人至少得有一方要多干些活 )。如此看来，Scala 其实也没有脱离静态强类型语言的范畴。</p>
<p>题外话，人们现在正围绕着 “Python 是强类型语言还是弱类型语言[^0]” 而吵得不可开交。</p>
<h2 id="3-3-能力式设计"><a href="#3-3-能力式设计" class="headerlink" title="3.3 能力式设计"></a>3.3 能力式设计</h2><p>Java 程序员将<strong>接口</strong>作为相互配合工作的契约 —— 它指定了契约里都有哪些任务，预期的结果应该是什么，同时，一个灵活的契约最好不要太过严格。Java 的接口提供了足够抽象的架构实现，但是仍然存在着一定限制。</p>
<p>假设我们现在正处在 Java 的世界观内，现在有一个 “挪动一个重物” 的需求，并针对它设计了一个抽象的 <code>helpMoving</code> 方法。如果我们的眼光放的足够远，那么就会将该方法放到一个接口当中等待其它热心群类去实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Helper</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">helpMoving</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">// Helper helper = new ...</span><br><span class="hljs-comment">// helper.helpMoving();</span><br></code></pre></td></tr></table></figure>

<p>任何有能力搬动重物的类在定义时需要实现这个接口，无论它是 Man，Woman，Elephant，乃至更抽象的 Human，Animal。</p>
<p>而具备动态运行能力的 Groovy 却认为，只要能完成这项任务，那它就不必去关心谁会做，按照哪个契约做 —— 只要它有能力实现 <code>helpMoving</code> 方法，那就无关乎它是 “牛鬼蛇神” 。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Groovy 没有对 helper 做任何限制，因此它本质上是 Object 类型。</span><br><span class="hljs-keyword">def</span> takeHelp(helper)&#123;<br>	helper.helpMoving()<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>helper</code> 本质上是 Object 类，我们在编写这个代码时，其实不保证它到底有没有合适的 <code>helpMoving</code> 方法 ( 在 Java 看来，这段代码简直错得离谱 )。不过，Groovy 相信我们会在运行时传入一个合理的 helper，因此它没有对此 “横加阻拦”。</p>
<p><code>helper</code> 没有显示地实现 Helper 接口，在这里我们仅仅是依赖了它的某一个能力。这样的类在 Python 语言中被称之为 “鸭子类型”，它的典故来自：”如果它走路像鸭子，叫声也像鸭子，那它就是一只鸭子”。</p>
<p>显然，当我们对 <code>helper</code> 的要求逐渐变得复杂起来时，传进来的对象不再需要从源码的层次中补充声明自己实现了这样或者是那样的接口。这样的做的结果就是少了繁文缛节，减少了开发成本。</p>
<h2 id="3-4-合理对待动态类型"><a href="#3-4-合理对待动态类型" class="headerlink" title="3.4 合理对待动态类型"></a>3.4 合理对待动态类型</h2><p>天下没有免费的午餐。动态类型在一定程度节约了代码量，但随着带来的代价之一则是测试成本的增加[^1]。编译器不会再主动地替我们做一些检查，那么就意味着我们需要更多的单元测试来保证其运行时的安全性，否则就是在玩火。</p>
<p>假设用户确实有可能传入一个 “能力不足” 的对象呢？这个担心并无道理。Groovy 提供了一种方式让我们在运行时对 <code>helper</code> 做一些 “资格审查” ，比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Groovy 没有对 helper 做任何限制，它本质上是 Object 类型。</span><br><span class="hljs-keyword">def</span> takeHelp(helper)&#123;<br>    <span class="hljs-comment">// metaClass 的内容，以后再说。</span><br>    <span class="hljs-keyword">if</span> (helper.metaClass.respondsTo(helper,<span class="hljs-string">&#x27;helpMoving&#x27;</span>)) &#123;<br>        helper.helpMoving()<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&#x27;this helper has no capacity of \&#x27;helpMoving\&#x27;&#x27;</span>)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Elephant</span>&#123;</span><br>    <span class="hljs-keyword">def</span> helpMoving()&#123;<br>        println <span class="hljs-string">&quot;doing that&quot;</span><br>    &#125;<br>&#125;<br><br>takeHelp(<span class="hljs-keyword">new</span> Elephant())<br></code></pre></td></tr></table></figure>

<h2 id="3-5-有关-Groovy-的方法多态"><a href="#3-5-有关-Groovy-的方法多态" class="headerlink" title="3.5 有关 Groovy 的方法多态"></a>3.5 有关 Groovy 的方法多态</h2><p>首先需要了解一个大前提：通过继承关系实现的多态方法，Java 会在运行期间根据调用者<strong>的实际类型</strong>进行动态选择 ( 即 “动态绑定” )。这里给定几个类来举例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">make</span><span class="hljs-params">(Product product)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;make product by factory.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClothFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">make</span><span class="hljs-params">(Product product)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;make product by clothFactory.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">make</span><span class="hljs-params">(Cloth cloth)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;make cloth by clothFactory&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span></span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cloth</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Product</span></span>&#123; &#125;<br></code></pre></td></tr></table></figure>

<p>动态绑定常用于解释对上转型对象的方法调用，比如下方代码块的 <code>clothFactory</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通对象</span><br>Factory factory = <span class="hljs-keyword">new</span> Factory();<br><br><span class="hljs-comment">// 上转型对象</span><br>Factory clothFactory = <span class="hljs-keyword">new</span> ClothFactory();<br><br><span class="hljs-comment">// make product by factory.</span><br>factory.make(<span class="hljs-keyword">new</span> Product());<br><br><span class="hljs-comment">// make product by clothFactory.</span><br>clothFactory.make(<span class="hljs-keyword">new</span> Product());<br></code></pre></td></tr></table></figure>

<p>然而在这个例子中，ClothFactory 类除了继承并重写了来自父类的 <code>make</code> 方法以外，自身还实现了接收 Cloth 类型的重载 <code>make</code> 方法。但是对于 Java 而言，只要 <code>clothFactory</code> 的引用是 Factory 类型，那么这个重载的 <code>make</code> 方法就永远无法被路由到，即便传入的是一个 Cloth 类型实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通对象</span><br>Factory factory = <span class="hljs-keyword">new</span> Factory();<br><br><span class="hljs-comment">// 上转型对象</span><br>Factory clothFactory = <span class="hljs-keyword">new</span> ClothFactory();<br><br><span class="hljs-comment">// make product by factory.</span><br>factory.make(<span class="hljs-keyword">new</span> Cloth());<br><br><span class="hljs-comment">// make product by clothFactory.</span><br><span class="hljs-comment">// 没有达到预期。</span><br>clothFactory.make(<span class="hljs-keyword">new</span> Cloth());<br></code></pre></td></tr></table></figure>

<p>可以这样理解：我们将 <code>clothFactory</code> 视作是一个 Factory 类型，因此在调用其 <code>make</code> 方法时，参数也总是被当作 Product 类对待，父类就是这么定义的。</p>
<p>Groovy 也许更懂开发者的心思。它的方法多态不仅和引用的实际类型相关，而且还和参数的实际类型相关 ( 不仅是方法多态，参数也变得 “多态” 了，这种方法分派基于多个实体，因此有个名词叫多分派或者多方法  Multimethods ) 。因此 Groovy 总是能找到最合适的方法来解决需求。下面的代码逻辑和上面完全相同，但是在 Groovy 这得到了 “更精确” 的执行结果。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span>&#123;</span><br>    <span class="hljs-keyword">def</span> make(Product product)&#123;print <span class="hljs-string">&quot;make product by factory&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClothFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Factory</span>&#123;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">def</span> make(Product product) &#123;print <span class="hljs-string">&quot;make product by clothFactory.&quot;</span>&#125;<br>    <span class="hljs-keyword">def</span> make(Cloth cloth)&#123;print <span class="hljs-string">&quot;make cloth by clothFactory&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span>&#123;</span>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cloth</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Product</span>&#123;</span>&#125;<br><br>Factory factory = <span class="hljs-keyword">new</span> Factory()<br>Factory clothFactory = <span class="hljs-keyword">new</span> ClothFactory()<br><br><span class="hljs-comment">// make product by factory</span><br>factory.make(<span class="hljs-keyword">new</span> Cloth())<br><br><span class="hljs-comment">// make cloth by clothFactory</span><br>clothFactory.make(<span class="hljs-keyword">new</span> Cloth())<br></code></pre></td></tr></table></figure>

<h2 id="3-6-重返静态类型"><a href="#3-6-重返静态类型" class="headerlink" title="3.6 重返静态类型"></a>3.6 重返静态类型</h2><p>动态还是静态，Groovy 可以自由切换。至于如何选择，其实很大程度要看每个程序员的编程偏好。笔者已经习惯了 Java  风格，因此大部分情况下还是会选择严谨的类型检查，尤其是对类进行定义时。而在一些明显能推断出属性 / 返回值类型的地方，笔者会倾向于使用 <code>def</code> 关键字一笔带过。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Java:</span><br><span class="hljs-comment">// Tuple3&lt;String,String,String&gt; tps = new Tuple3&lt;&gt;(&quot;java&quot;,&quot;groovy&quot;,&quot;scala&quot;);</span><br><span class="hljs-keyword">def</span> tps = <span class="hljs-keyword">new</span> Tuple3&lt;&gt;(<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;groovy&quot;</span>,<span class="hljs-string">&quot;scala&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>下面有两个实用的注解能够让 Groovy 代码化动为静。</p>
<h3 id="3-6-1-严格的编译时检查"><a href="#3-6-1-严格的编译时检查" class="headerlink" title="3.6.1 严格的编译时检查"></a>3.6.1 严格的编译时检查</h3><p><code>@TypeChecked</code> 是一个<strong>作用在方法或类</strong>上的注解。一旦被标注此注解，那么 Groovy 会在这段代码块内进行严格的类型检查，而不是基于 “运行时可能合理” 的假设。以前面的例子来说，<code>@TypeChecked</code> 注解将这个 “鸭子类型” 打回了原形 —— 编译器现在会报错。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> groovy.transform.TypeChecked<br><br><span class="hljs-meta">@TypeChecked</span><br><span class="hljs-keyword">def</span> takeHelp(helper)&#123;<br>    helper.helpMoving()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面演示了该注解作用在方法上的情形。如果该注解作用到类上，则 Groovy 编译器会对其内部的所有方法，闭包，内部类全部进行严格检查。</p>
<h3 id="3-6-2-静态编译"><a href="#3-6-2-静态编译" class="headerlink" title="3.6.2 静态编译"></a>3.6.2 静态编译</h3><p>Groovy 的动态类型是以 “少许” 的性能做代价的 —— 尤其在 JDK 7 之前，JVM 还没有推出 <code>invokeDynamic</code> 字节码的那个年代。当时，对于那些追求 Groovy 的简洁，又纠结于运行性能的程序员而言，将 Groovy 干脆变成静态代码或许是更好的选择。如果这么做，就意味着舍弃了本章动态类型能够带来的所有便捷体验，以换取更高的运行性能。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> groovy.transform.CompileStatic<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.currentTimeMillis<br><br><span class="hljs-comment">// 显示地标注参数，返回值的类型为基本数据类型 int。</span><br><span class="hljs-meta">@CompileStatic</span><br><span class="hljs-keyword">int</span> Fibonacci(<span class="hljs-keyword">int</span> n)&#123;<br>    <span class="hljs-keyword">return</span> (n&lt;<span class="hljs-number">2</span>) ? <span class="hljs-number">1</span> : Fibonacci(n<span class="hljs-number">-1</span>) + Fibonacci(n<span class="hljs-number">-2</span>)<br>&#125;<br><br>t1 = currentTimeMillis()<br>result = Fibonacci(<span class="hljs-number">40</span>)<br><span class="hljs-comment">//result = Fib_more(40,1,1)</span><br>t2 = currentTimeMillis()<br><br>println <span class="hljs-string">&quot;result:$&#123;result&#125;&quot;</span><br>println <span class="hljs-string">&quot;time:$&#123;t2-t1&#125; millis&quot;</span><br><br><br><span class="hljs-comment">// 尾递归版斐波那契数列。</span><br><span class="hljs-keyword">int</span> Fib_more(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)&#123;<br>    <span class="hljs-keyword">return</span> (n == <span class="hljs-number">0</span>) ? left : Fib_more(n<span class="hljs-number">-1</span>,right,(left + right))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码通过测试非尾递归的斐波那契数列来测试静态编译对执行性能的影响。如果函数标注了 <code>@ComplieStatic</code> 注解，那么该函数运行时长约为 300 ms；在不进行静态编译的情况下，该函数的运行时长约为 1200 ms，运行性能显著拉跨。</p>
<p>注：Groovy 的定位是一门脚本语言 ( 胶水语言 ) ，它其实不擅长做直接的计算密集型任务。到后面的学习会发现，<strong>Groovy 真正强大的地方在于元编程能力，我们得以用它去设计内部 DSL</strong>。思考一下，为什么现在的 AI 库核心选用 C/C++ 来完成，然后再使用 Python 在上面覆盖上薄薄的一层：这是出于性能和适用两方面考虑的决策。因此，可以类比着去思考在 JVM 上 Java ，Groovy 乃至 Scala 应该如何互相配合工作 …… 或者你对 C 语言感兴趣吗？</p>
<h2 id="3-7-参考资料"><a href="#3-7-参考资料" class="headerlink" title="3.7 参考资料"></a>3.7 参考资料</h2><p>[^0]:<a href="https://www.cnblogs.com/pythonista/p/13592043.html">Python 到底是强类型语言，还是弱类型语言？</a><br>[^1]: 笔者认为动态类型的两个代价是：安全和性能。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>Groovy_集合 &amp; GString</title>
    <url>/2021/04/25/Groovy-%E9%9B%86%E5%90%88-GString/</url>
    <content><![CDATA[<h1 id="5-Groovy-常用工具"><a href="#5-Groovy-常用工具" class="headerlink" title="5. Groovy 常用工具"></a>5. Groovy 常用工具</h1><p>本专题包括集合类的两个最主要工具，序列 ( <code>java.util.ArrayList</code> ) 和映射 <code>java.util.LinkedHashMap</code> 以及相关的操作方法 ( 通过传入闭包来实现 ) 。另外，文末补充了 Groovy 独有的字符串类型 —— GString 类型的一些使用技巧。</p>
<h2 id="5-1-定义-ArrayList"><a href="#5-1-定义-ArrayList" class="headerlink" title="5.1 定义 ArrayList"></a>5.1 定义 ArrayList</h2><p>Groovy 使用方括号 <code>[]</code> 创建一个 “可扩容数组”：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> seq = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>println seq.getClass().name<br></code></pre></td></tr></table></figure>

<p>不过，如果我们打印这个数组的类型，可以发现 Groovy 的数组，其底层其实为 <code>java.util.ArrayList</code> ( 换句话说，Groovy 没有原生的 <code>[Object</code> 类型 )。不过由于 Groovy 实现了运算符重载方法，因此我们仅需要通过下标就可以访问到元素。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 访问第一个元素</span><br>println seq[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">// 访问最后一个元素</span><br>println seq[seq.size()<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure>

<p>如果寻找的元素在序列的后边位置，我们可以使用负数下标令 Groovy 从后向前寻找元素：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">seq[<span class="hljs-number">-1</span>]  <span class="hljs-comment">// 等价于 seq[seq.size()-1]</span><br></code></pre></td></tr></table></figure>

<p>甚至，可以像使用 Go 语言的切片一样使用它：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 截取下标 0 ~ 4 (包括) 的新序列</span><br><span class="hljs-keyword">def</span> slice = seq[<span class="hljs-number">0.</span><span class="hljs-number">.3</span>]<br><br><span class="hljs-comment">//[0,1,2,3]</span><br>println slice<br></code></pre></td></tr></table></figure>

<p>在更古老的 Groovy 版本中，如果这个新的 “切片” 是基于另一个 “底层数组” 获得的，那么这处改动会同样影响到 “底层数组” —— 这段描述跟 Go 非常像。但是在新版本 ( 笔者是 3.0.8 ) 中，这种行为已经发生了改变 —— 得到的新 “切片” 将是独立的，它的修改不再会影响到原先的 “底层数组”。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> seq = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">def</span> slice = seq[<span class="hljs-number">0.</span><span class="hljs-number">.3</span>]<br>slice[<span class="hljs-number">0</span>] = <span class="hljs-number">999</span><br><br><span class="hljs-comment">// 下面是在 Groovy 3.0.8 的运行结果。在更古老的版本中，下面两个运行结果可能是相同的。</span><br><span class="hljs-comment">// 999</span><br>println slice[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">// 1</span><br>println seq[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<p>Groovy 的序列提供两个非常直观的符号：<code>+</code> ( 添加元素 ) ，或者是 <code>-</code> ( 删除元素 ) 。但从广义角度来说，这两个符号也可代表求并集，或是求相对补集。因此，这两个操作符可以接收单个元素，也可以接收另一个 <code>ArrayList</code> 。需要注意的是，这两种操作总是返回一个新的 <code>ArrayList</code> ，而原 <code>ArrayList</code> 并不会被改变。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> seq = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// [1,2,3,4,5] - [6] = [1,2,3,4,5]</span><br>println seq - <span class="hljs-number">6</span><br><br><span class="hljs-comment">// [1,2,3,4,5] + [6] = [1,2,3,4,5,6]</span><br>println seq + <span class="hljs-number">6</span><br><br><span class="hljs-comment">// [1,2,3,4,5] - [1,3,5] = [2,4]</span><br>println seq - [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// [1,2,3,4,5] + [6,7,8] = [1,2,3,4,5,6,7,8]</span><br>println seq + [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure>

<h2 id="5-2-使用-ArrayList"><a href="#5-2-使用-ArrayList" class="headerlink" title="5.2 使用 ArrayList"></a>5.2 使用 ArrayList</h2><p>在 Java 中，对某个列表使用 <code>foreach</code> 等操作要率先将其转换成一个流，待转换完毕之后再经过一步终结操作将结果收集起来 ……  Groovy 处理这些操作则非常容易且直观。</p>
<h3 id="5-2-1-each"><a href="#5-2-1-each" class="headerlink" title="5.2.1 each"></a>5.2.1 each</h3><p>在 Groovy 中，只需要使用闭包来告诉 Groovy 应该对每一个元素怎么做就 Ok 了。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> seq = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// Java: for(Integer i : seq)&#123;System.out.println(i)&#125; ...</span><br><span class="hljs-comment">// Groovy: I want to println each element.</span><br>seq.each &#123;println it&#125;<br></code></pre></td></tr></table></figure>

<p>假如现在相对 <code>seq</code> 内的每一个元素做翻倍操作，然后以此创建出一个新的序列：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 好像缺了一点什么。</span><br>seq.each &#123; it * <span class="hljs-number">2</span> &#125;<br></code></pre></td></tr></table></figure>

<p>不过，现在这种写法达不到目的，因为 Groovy 只是单纯地对每一个元素进行了计算而没有进行存储。这里需要借助一个 <code>&lt;&lt;</code> ( 对应重载运算符的 <code>leftShift()</code> ) 方法，将运算后的结果收集起来：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">seq = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">def</span> doubled = []<br><br><span class="hljs-comment">// 相当于 doubled.leftShift(it*2)</span><br>seq.each &#123;doubled &lt;&lt; it * <span class="hljs-number">2</span>&#125;<br>println doubled<br></code></pre></td></tr></table></figure>

<p>如果要通过两两归并的方式对内部所有元素进行折叠，可以使用 <code>sum()</code> 方法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">seq.sum &#123;x1,x2 -&gt; x1 + x2&#125;<br></code></pre></td></tr></table></figure>

<p>对于基本数据类型的 <code>sum</code>，可以不主动传入闭包。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">seq.sum()<br></code></pre></td></tr></table></figure>

<p>Groovy 中的 <code>ArrayList</code> 还提供其它的遍历方式，比如反向迭代：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">seq.<span class="hljs-keyword">reverseEach</span> &#123;<span class="hljs-keyword">println</span> it&#125;<br></code></pre></td></tr></table></figure>

<p>或者，如果关注迭代过程中的下标，可以使用 <code>eachWithIndex()</code> 方法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 提供的闭包需要包含两个参数，第一个是元素类型，第二个是索引类型。</span><br>seq.eachWithIndex &#123; Object entry, <span class="hljs-keyword">int</span> i -&gt;<br>    println <span class="hljs-string">&quot;index of $&#123;i&#125; , objct: $&#123;entry&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-2-2-collect"><a href="#5-2-2-collect" class="headerlink" title="5.2.2 collect"></a>5.2.2 collect</h3><p>如果要在<strong>操作之后顺便收集所有元素</strong>，并在调用之后返回，Groovy 提供 <code>collect()</code> 方法。和之前 <code>each</code> 配合 <code>&lt;&lt;</code> 操作符的做法相比较，它俩的区别在于：<code>collect</code> 会主动返回一个匿名的结果集，而后者是通过副作用来实现的。</p>
<p>Groovy 的 <code>collect()</code> 方法语义上类似于 Scala 或者 Java Stream 的 <code>map()</code> 方法。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> doubled = seq.collect &#123; it * <span class="hljs-number">2</span> &#125;<br>println doubled<br></code></pre></td></tr></table></figure>

<h3 id="5-2-3-find-any-every"><a href="#5-2-3-find-any-every" class="headerlink" title="5.2.3 find / any / every"></a>5.2.3 find / any / every</h3><p>查找元素使用 <code>find()</code> 方法更方便一些，比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">seq = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// 传入的闭包得是 Closure&lt;Boolean&gt;.</span><br><span class="hljs-keyword">def</span> i = seq.find &#123; it == <span class="hljs-number">2</span> &#125;<br><br><span class="hljs-comment">// 2</span><br>print(i)<br></code></pre></td></tr></table></figure>

<p><code>find()</code> 方法只查找一个满足条件的元素，而 <code>findAll()</code> 方法能够将所有满足条件的元素装入到一个 <code>ArrayList</code> 中返回。Groovy 的 <code>findAll()</code> 方法语义上类似于 Scala 或者 Java Stream 的 <code>filter</code> 方法。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">seq = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">def</span> seq1 = seq.findAll &#123;it &gt; <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-comment">// [2,3,4,5]</span><br>println seq1<br></code></pre></td></tr></table></figure>

<p>有时，我们仅仅是想知道满足目的的元素是否存在。这个时候更推荐使用 <code>any()</code> 方法，它将返回一个布尔值：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 是否至少有一个元素满足 &gt;2，显然是满足条件的。</span><br><span class="hljs-keyword">def</span> bool = seq.any &#123;<br>    it &gt; <span class="hljs-number">2</span><br>&#125;<br><br>println bool<br></code></pre></td></tr></table></figure>

<p>另一个极端则是：检查所有的元素是否<strong>都</strong>满足条件。这时应该使用 <code>every()</code> 方法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> seq =[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// 所有的元素都大于 0 吗？ -true.</span><br>println seq.every &#123; it &gt; <span class="hljs-number">0</span> &#125;<br><br><span class="hljs-comment">// 所有的元素都大于 2 吗？ -false.</span><br>println seq.every &#123; it &gt; <span class="hljs-number">2</span> &#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-2-4-join"><a href="#5-2-4-join" class="headerlink" title="5.2.4 join"></a>5.2.4 join</h3><p>Groovy 的 <code>join</code> 指将序列内的所有元素通过一个字符串做分隔符连接，并返回一个完整的长字符串。在需要输出数据内容到外部的场合，<code>join</code> 方法可能会变得很实用，这和 Scala 的 <code>mkString()</code>  语义相类似。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">seq = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-comment">//1-2-3-4-5</span><br>println seq.join(<span class="hljs-string">&quot;-&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="5-2-5-特殊运算符"><a href="#5-2-5-特殊运算符" class="headerlink" title="5.2.5 特殊运算符 *"></a>5.2.5 特殊运算符 *</h3><p>假定有一个由学生类 <code>Student</code>  构成的序列，现在程序需要通过调用内部每一个实例的 <code>info()</code> 方法来收集学生信息。之前提到的 <code>collect</code> 方法可以实现它：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> groovy.transform.Canonical<br><br><span class="hljs-meta">@Canonical</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> &#123;</span><br>    String name<br>    String id<br>    String info()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student id:$&#123;id&#125;,name:$&#123;name&#125;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> students = [<span class="hljs-keyword">new</span> Student(<span class="hljs-attr">name:</span><span class="hljs-string">&quot;Zhao&quot;</span>,<span class="hljs-attr">id:</span> <span class="hljs-string">&quot;0001&quot;</span>),<br><span class="hljs-keyword">new</span> Student(<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Qian&quot;</span>,<span class="hljs-attr">id:</span><span class="hljs-string">&quot;0002&quot;</span>),<br><span class="hljs-keyword">new</span> Student(<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Sun&quot;</span>,<span class="hljs-attr">id:</span><span class="hljs-string">&quot;0003&quot;</span>),<br><span class="hljs-keyword">new</span> Student(<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Li&quot;</span>,<span class="hljs-attr">id:</span><span class="hljs-string">&quot;0004&quot;</span>)<br>]<br><br><span class="hljs-comment">// 写法 1 </span><br>students.collect &#123;it.info()&#125;<br></code></pre></td></tr></table></figure>

<p>然而，Groovy 还提供了一个 <code>*</code> 作为展开操作符，来表示 “序列内的每一个元素”。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 写法 2 </span><br>student*.info()<br></code></pre></td></tr></table></figure>

<p>它和前文的写法 1 语义相同。即 <code>student</code> 序列的每一个元素都调用 <code>info()</code> 方法，<strong>并且隐式地将所有变换结果都收集到另一个序列返回。</strong> <code>*</code> 和 <code>.</code> 共同组成了 <code>*.</code> 操作符，它像 <code>?.</code> 一样能够避免空指针异常，并安全地返回一个 <code>null</code>。</p>
<p>如果操作的序列中混进了一个空指针，如果是 <code>collect</code> 的写法，程序将报错，但是 <code>*.</code> 则不会。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> students = [<span class="hljs-keyword">new</span> Student(<span class="hljs-attr">name:</span><span class="hljs-string">&quot;Zhao&quot;</span>,<span class="hljs-attr">id:</span> <span class="hljs-string">&quot;0001&quot;</span>),<br><span class="hljs-keyword">new</span> Student(<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Qian&quot;</span>,<span class="hljs-attr">id:</span><span class="hljs-string">&quot;0002&quot;</span>),<br><span class="hljs-keyword">new</span> Student(<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Sun&quot;</span>,<span class="hljs-attr">id:</span><span class="hljs-string">&quot;0003&quot;</span>),<br><span class="hljs-keyword">new</span> Student(<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Li&quot;</span>,<span class="hljs-attr">id:</span><span class="hljs-string">&quot;0004&quot;</span>),<br><span class="hljs-literal">null</span><br>]<br><span class="hljs-comment">// students.collect &#123;it.info()&#125;</span><br><span class="hljs-comment">// 不会报错，空调用会插入 null 做代替。</span><br><span class="hljs-comment">// [Student(...),Student(...),...,null]</span><br>println students*.info()<br></code></pre></td></tr></table></figure>

<p><code>*</code> 承担了太多的功能 —— 当它用作前置运算符时，表达的含义又不同了。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> cfg = [<span class="hljs-string">&quot;mongodb&quot;</span>,<span class="hljs-string">&quot;192.168.2.140&quot;</span>,<span class="hljs-string">&quot;27017&quot;</span>]<br><br><span class="hljs-keyword">def</span> getURI(String db,String ip,String port)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;$&#123;db&#125;://$&#123;ip&#125;:$&#123;port&#125;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// println getURI(cfg[0],cfg[1],cfg[2])</span><br>println getURI(*cfg)<br></code></pre></td></tr></table></figure>

<p>这种用法出现在方法调用时的参数赋值。<code>*cfg</code> 表示将序列内部的每一个元素全部 “分发” 到参数列表的对应位置。如果要让这段代码正常运作，那么序列内部的元素个数必须和方法的参数个数相同，或者方法本身接收可变参数。</p>
<h2 id="5-3-定义-Map"><a href="#5-3-定义-Map" class="headerlink" title="5.3 定义 Map"></a>5.3 定义 Map</h2><p>在前几期文章我们已经演示过如何快速使用 Groovy 的语法来创建 Map：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> map  = [<span class="hljs-string">&quot;java&quot;</span>:<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;groovy&quot;</span>:<span class="hljs-string">&quot;3.0.8&quot;</span>,<span class="hljs-string">&quot;scala&quot;</span>:<span class="hljs-string">&quot;2.11.8&quot;</span>,<span class="hljs-string">&quot;python&quot;</span>:<span class="hljs-string">&quot;3.8&quot;</span>]<br>println map.getClass()<br></code></pre></td></tr></table></figure>

<p>和 ArrayList 类似，Groovy 的 Map 即 “包了糖衣之后” 的 <code>java.util.LinkedHashMap</code>，但是创建起来要比 Java 优雅地多。在 key 为字符串的情形，引号甚至可以省略掉。形如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> map  = [<span class="hljs-attr">java:</span><span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-attr">groovy:</span><span class="hljs-string">&quot;3.0.8&quot;</span>,<span class="hljs-attr">scala:</span><span class="hljs-string">&quot;2.11.8&quot;</span>,<span class="hljs-attr">python:</span><span class="hljs-string">&quot;3.8&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>访问 Map 元素更像是访问一个索引为键的值：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">println map[<span class="hljs-string">&quot;java&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>论搞花活这方面，Groovy 从来不会让人失望。比如上面的写法等价于：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 当这个键是不带特殊符号的字符串时，可以不带括号。</span><br>println map.<span class="hljs-string">&quot;java&quot;</span><br>prtinln map.java<br></code></pre></td></tr></table></figure>

<p>Map 的键总是 unique 的。如果在创建 Map 或者添加键值对的过程中某些 key 重复了，则 Groovy 会保存最新的那个。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">map[<span class="hljs-string">&quot;java&quot;</span>] = <span class="hljs-number">11</span><br>map[<span class="hljs-string">&quot;java&quot;</span>] = <span class="hljs-number">8</span><br><br><span class="hljs-comment">// 8</span><br>println map[<span class="hljs-string">&quot;java&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>下面演示 Map 的元素添加和修改：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> map  = [<span class="hljs-string">&quot;java&quot;</span>:<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;groovy&quot;</span>:<span class="hljs-string">&quot;3.0.8&quot;</span>,<span class="hljs-string">&quot;scala&quot;</span>:<span class="hljs-string">&quot;2.11.8&quot;</span>,<span class="hljs-string">&quot;python&quot;</span>:<span class="hljs-string">&quot;3.8&quot;</span>]<br>map.java = <span class="hljs-string">&quot;8&quot;</span><br>map.java = <span class="hljs-string">&quot;6&quot;</span><br><br><span class="hljs-comment">// 相当于添加了 (c++,14) 键值对。</span><br>map[<span class="hljs-string">&quot;c++&quot;</span>] = <span class="hljs-string">&quot;14&quot;</span><br><br><span class="hljs-comment">// 删除键值对。</span><br>map.remove(<span class="hljs-string">&quot;c++&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>同样，在了解 ArrayList 的批量添加删除方法之后，我们将很容易接受这种写法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> map  = [<span class="hljs-string">&quot;java&quot;</span>:<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;groovy&quot;</span>:<span class="hljs-string">&quot;3.0.8&quot;</span>,<span class="hljs-string">&quot;scala&quot;</span>:<span class="hljs-string">&quot;2.11.8&quot;</span>,<span class="hljs-string">&quot;python&quot;</span>:<span class="hljs-string">&quot;3.8&quot;</span>]<br><br>map + [<span class="hljs-string">&quot;c++&quot;</span>:<span class="hljs-string">&quot;20&quot;</span>,<span class="hljs-string">&quot;go&quot;</span>:<span class="hljs-string">&quot;1.15.5&quot;</span>]<br><br><span class="hljs-comment">// 即使是单个元素，也需要使用 [] 括起来。</span><br>map + [<span class="hljs-string">&quot;java&quot;</span>:<span class="hljs-string">&quot;13&quot;</span>]<br><br>map - [<span class="hljs-string">&quot;c++&quot;</span>:<span class="hljs-string">&quot;20&quot;</span>,<span class="hljs-string">&quot;go&quot;</span>:<span class="hljs-string">&quot;1.15.5&quot;</span>]<br><br>map - [<span class="hljs-string">&quot;java&quot;</span>:<span class="hljs-string">&quot;13&quot;</span>]<br></code></pre></td></tr></table></figure>

<h2 id="5-4-使用-Map"><a href="#5-4-使用-Map" class="headerlink" title="5.4 使用 Map"></a>5.4 使用 Map</h2><p>以 each 方法为例子。在遍历 Map 时，可以操作完整的键值对 entry 本身，也可以分别操作键值对的 k 和 v 。下面的代码演示了这两个使用风格：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 操作键值对</span><br>map.each &#123;<br>    entry -&gt;<br>        println <span class="hljs-string">&quot;the key is $&#123;entry.key&#125; and the value is $&#123;entry.value&#125;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 分开操作 k 和 v</span><br>map.each &#123;<br>    k,v -&gt;<br>        println <span class="hljs-string">&quot;the key is $k and the value is $v&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么剩下的 <code>collect()</code>，<code>find()</code> 等相关用法和 <code>ArrayList</code> 中类似，这里就不再做赘述。主要介绍 Map 的其它便捷方法。</p>
<h3 id="5-5-groupBy"><a href="#5-5-groupBy" class="headerlink" title="5.5 groupBy"></a>5.5 groupBy</h3><p>在使用 SQL 语句时，group by 允许我们能够快速地依照某一个条件对整个表进行划分归类。比如，下面的 group by 是按照每个商品的分类 ( 苹果 / 香蕉) 将一个大的商品表分成了两个子表：</p>
<p><img  src="https://i.im5i.com/2021/05/05/wOzFU.png"  ><span class="image-caption">group by</span></p>
<p>Map 中的 <code>groupBy</code> 方法则是依照某一个条件作为 key 变换出的值为<strong>嵌套 Map 类型</strong>的新 Map。在 Groovy 中实现上面的例子：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> map = [<br>        <span class="hljs-comment">// 商品名是主键，因此商品名写在 k 的位置。</span><br>        <span class="hljs-string">&quot;苹果&quot;</span>:<span class="hljs-string">&quot;水果&quot;</span>,<br>        <span class="hljs-string">&quot;香蕉&quot;</span>:<span class="hljs-string">&quot;水果&quot;</span>,<br>        <span class="hljs-string">&quot;芹菜&quot;</span>:<span class="hljs-string">&quot;蔬菜&quot;</span>,<br>        <span class="hljs-string">&quot;香菜&quot;</span>:<span class="hljs-string">&quot;蔬菜&quot;</span>,<br>        <span class="hljs-string">&quot;大葱&quot;</span>:<span class="hljs-string">&quot;蔬菜&quot;</span>,<br>        <span class="hljs-string">&quot;火龙果&quot;</span>:<span class="hljs-string">&quot;水果&quot;</span>,<br>]<br><br><span class="hljs-keyword">def</span> categories = map.groupBy &#123;<br>    <span class="hljs-comment">// 按照每一个商品的分类划分</span><br>    k,v -&gt; v<br>&#125;<br><br><span class="hljs-comment">//水果=&#123;苹果=水果, 香蕉=水果, 火龙果=水果&#125;</span><br><span class="hljs-comment">//蔬菜=&#123;芹菜=蔬菜, 香菜=蔬菜, 大葱=蔬菜&#125;</span><br>categories.each &#123;println it&#125;<br></code></pre></td></tr></table></figure>

<p>Map 的其它使用途径在之前的章节已经介绍：</p>
<ol>
<li>将 Map 用于具名参数的情形，参考 <a href="https://juejin.cn/post/6954350461818421278#heading-8">5 分钟的 Java 转 Groovy 教程 (juejin.cn)</a> 2.7 节。</li>
<li>将 Map 用于接口实现的情形，参考上述链接的 2.10 节。</li>
</ol>
<h2 id="5-6-GString"><a href="#5-6-GString" class="headerlink" title="5.6 GString"></a>5.6 GString</h2><p>Groovy 几乎隐去了数据类型 <code>char</code> 。对于一个表达 <code>&#39;G&#39;</code> ，Java 会认为它是一个 <code>char</code> 类型，但是 Groovy 仍然会将它当作是一个字符串常量。如果有必要将它认作是一个 <code>char</code> 类型，Groovy 必须进行一次强制转换：<code>&#39;G&#39; as char</code> 。</p>
<p>除了双引号包括的字符串以外，由正斜杠 <code>//</code> 包括的字符串也<strong>可能</strong>会被认为是 GString ：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> str1 = <span class="hljs-string">&quot;hello Groovy&quot;</span><br><span class="hljs-keyword">def</span> str2 = <span class="hljs-regexp">/hello Groovy/</span><br></code></pre></td></tr></table></figure>

<p>GString 实际上是一个表达式，或者说是一个模板，通过 <code>$</code> 预留了一些占位符。即便我们不改变 GString 本身的引用，当占位符引用的内容 ( 这里指的是值 ) 发生改变时，GString 返回的内容也会随之变化：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 单线程环境下，选择 StringBuilder。由于它不是线程安全的，因此多线程环境下选择 StringBuffer。</span><br><span class="hljs-keyword">def</span> lang = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&#x27;lang&#x27;</span>)<br><span class="hljs-keyword">def</span> template = <span class="hljs-string">&quot; i use $&#123;lang&#125; to finish my project.&quot;</span><br><br>println template.getClass().name<br>println template<br><br>lang.replace(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;groovy&#x27;</span>)<br><br><span class="hljs-comment">// 我们只是重复地打印 template，但是它的内容却改变了。</span><br>println template<br></code></pre></td></tr></table></figure>

<p>GString 总是<strong>惰性计算的</strong>，它只有在被使用的时候才会重新计算表达式的实际内容并返回。当 GString 表达式内部没有任何占位符时，那么 Groovy 就会省去 <code>String -&gt; GString</code> 的包装过程。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> str1 = <span class="hljs-string">&quot;hello Groovy&quot;</span><br><span class="hljs-comment">// 由于内部没有任何占位符，因此它实际上是个 String 类型。</span><br><span class="hljs-comment">// java.lang.String</span><br>println str1.getClass().name<br></code></pre></td></tr></table></figure>

<h3 id="5-6-1-避免使用陷阱"><a href="#5-6-1-避免使用陷阱" class="headerlink" title="5.6.1 避免使用陷阱"></a>5.6.1 避免使用陷阱</h3><p>回到刚才的话题。通过调用 <code>StringBuilder</code> 类型的 <code>template</code> 的 <code>replace()</code> 方法，它返回的 <code>toString()</code> 内容也发生了变化，因此导致两次输出的结果不同，这是符合预期的，但如果 <code>lang</code> 是纯粹的 <code>String</code> 类型呢？</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> lang = <span class="hljs-string">&#x27;java&#x27;</span><br><span class="hljs-keyword">def</span> template = <span class="hljs-string">&quot; i use $&#123;lang&#125; to finish my project.&quot;</span><br><br>println template.getClass().name<br>println template<br><br>lang = <span class="hljs-string">&#x27;groovy&#x27;</span><br><br><span class="hljs-comment">// 打印的内容没有发生变化。</span><br>println template<br></code></pre></td></tr></table></figure>

<p>由于 Java 字符串不可变，<code>template</code> 在编译期就会将占位符 <code>$&#123;lang&#125;</code> 替换成常量池中的某一个存放着 <code>&quot;java&quot;</code> 的索引。如果使用 <code>javap</code> 工具解析这段字节码，其 <code>$&#123;lang&#125;</code> 的传入是通过 <code>ldc</code> 指令 ( 它将常量池的值压入操作数栈 ) 实现的。</p>
<p>换句话说，<code>lang</code> 之后再怎么变化，<code>template</code> 都始终指向那个 <code>&quot;java&quot;</code> 字符串常量。想要打破这个局面，就必须让 <code>lang</code> 是可变的，上述 <code>StringBuilder</code> 是个可行的方法，但是会让我们的代码变得冗长。另一个更简便办法是让将其修改成一个返回 <code>lang</code> 的闭包：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> lang = <span class="hljs-string">&#x27;java&#x27;</span><br><span class="hljs-keyword">def</span> template = <span class="hljs-string">&quot; i use $&#123;-&gt;lang&#125; to finish my project.&quot;</span><br><br>println template.getClass().name<br>println template<br><br>lang = <span class="hljs-string">&#x27;groovy&#x27;</span><br><br><span class="hljs-comment">// 重新得到预期的结果，并且没有增加任何其它的代码。</span><br>println template<br></code></pre></td></tr></table></figure>

<p>如果引用 Scala 的术语来解释，那就是这里的传值调用变成了传名调用。简单来说，这种做法推迟了一步 <code>GString</code> 的计算，因此 <code>GString</code> 现在无法直接指向一个字符串常量来蒙混过关。</p>
<p>在避开这个陷阱之后，使用 GString 来做一些重复拼装字符串的任务会变得非常轻松愉快 ( 幸亏这里使用的不是 <code>StringBuilder</code> 或者是 <code>StringBuffer</code> ) 。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">(lang,frame) = [<span class="hljs-string">&quot;_&quot;</span>,<span class="hljs-string">&quot;_&quot;</span>]<br><span class="hljs-keyword">def</span> template = <span class="hljs-string">&quot; i use $&#123;-&gt;lang&#125; to build $&#123;-&gt;frame&#125;.&quot;</span><br><br><span class="hljs-keyword">def</span> map = [<br>        <span class="hljs-string">&#x27;java&#x27;</span>:<span class="hljs-string">&#x27;spring&#x27;</span>,<br>        <span class="hljs-string">&#x27;groovy&#x27;</span>:<span class="hljs-string">&#x27;grails&#x27;</span>,<br>        <span class="hljs-string">&#x27;go&#x27;</span>:<span class="hljs-string">&#x27;gin&#x27;</span><br>]<br><br>map.each &#123;<br>    k,v -&gt;<br>        lang = k<br>        frame = v<br>        println template<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-6-2-重载操作符"><a href="#5-6-2-重载操作符" class="headerlink" title="5.6.2 重载操作符"></a>5.6.2 重载操作符</h3><p>Groovy 对字符串给出了很多便捷的重载实现，比如 <code>+</code>，<code>-</code> 或者 <code>*</code> 运算符。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// from org.codehaus.groovy.runtime.StringGroovyMethods.</span><br><br><span class="hljs-comment">// &quot;hellohello&quot;</span><br>println <span class="hljs-string">&quot;hello&quot;</span> * <span class="hljs-number">2</span><br><br><span class="hljs-comment">// &quot;he&quot;</span><br>println <span class="hljs-string">&quot;hello&quot;</span> - <span class="hljs-string">&quot;llo&quot;</span><br><br><span class="hljs-comment">// &quot;hello guys&quot;</span><br>println <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot; guys&quot;</span><br></code></pre></td></tr></table></figure>

<p>Groovy 通过 MOP 方法拦截机制将重载运算符注入给了 String，这些方法实际归属于 <code> org.codehaus.groovy.runtime.StringGroovyMethods</code> 。有关于 MOP 方法诸注入的内容，我们在未来的章节中介绍。</p>
<h3 id="5-6-3-正则表达式"><a href="#5-6-3-正则表达式" class="headerlink" title="5.6.3 正则表达式"></a>5.6.3 正则表达式</h3><p>一旦在字符串前面加上 <code>~</code> 符号，那么这个字符串将成为一段正则表达式，其字符串形式不限于 GString 或是 String，因此可以使用单引号，双引号，正斜杠将表达式括起来。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">~<span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-regexp">~/hello/</span><br>~<span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure>

<p>在正则表达式的场合，习惯上使用正斜杠，也就是上述代码的第二种表示法。正则表达式中经常会出现反斜杠 <code>\</code>，而该写法将允许表达式内部不用对反斜杠进行转义。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">~<span class="hljs-string">&#x27;\\d*\\w*&#x27;</span><br>~<span class="hljs-string">&quot;\\d*\\w*&quot;</span><br><span class="hljs-regexp">~/\d*\w/</span><br></code></pre></td></tr></table></figure>

<p>Groovy 针对匹配给出了两种运算符：精确匹配 <code>==~</code> 和模糊匹配 <code>=~</code>。前者要求字符串内容完全匹配表达式，而后者只要求字符串内容有一部分匹配表达式。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 匹配 Groovy 或者 groovy。</span><br>pattern = ~<span class="hljs-string">&#x27;([Gg])roovy&#x27;</span><br><br><span class="hljs-comment">// 这个字符串包含了 groovy，满足条件。</span><br>println <span class="hljs-string">&quot;java and groovy&quot;</span> =~ pattern?<span class="hljs-string">&quot;match&quot;</span>:<span class="hljs-string">&quot;not match&quot;</span><br><br><span class="hljs-comment">// 这个字符串并不是只包含 Groovy 或者 groovy，不满足条件。</span><br>println <span class="hljs-string">&quot;java and groovy&quot;</span> ==~ pattern?<span class="hljs-string">&quot;match&quot;</span>:<span class="hljs-string">&quot;not match&quot;</span><br></code></pre></td></tr></table></figure>

<p>同样的字符串和正则表达式，由于运算符的严格程度不同，因此程序给出了两种不同的运算结果。这两个操作符均返回 <code>java.util.regex.Matcher</code> 实例，只不过当它用于三目运算符或者 <code>if</code> 的条件判断时，Groovy 会自动将其转换成布尔值。</p>
<h3 id="5-6-4-String-as-Scrpit"><a href="#5-6-4-String-as-Scrpit" class="headerlink" title="5.6.4 String as Scrpit"></a>5.6.4 String as Scrpit</h3><p>在最开始的章节，我们曾经介绍过：Groovy 可以非常轻松地和系统进程进行交互：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 通过 Groovy 程序打印 Groovy 自身的 GDK</span><br>println <span class="hljs-string">&#x27;cmd /C groovy -v&#x27;</span>.execute().text<br></code></pre></td></tr></table></figure>

<p>和重载运算符类似，其 <code>execute() </code>方法实际归属于 <code>org.codehaus.groovy.runtime.ProcessGroovyMethods</code> 类。</p>
<p>如果对 Groovy 自动化非常感兴趣，请参照 <a href="http://www.groovy-lang.org/api.html">The Apache Groovy programming language - Groovy Development Kit (groovy-lang.org)</a> 并搜索上文的类名，然后搜索相关 API 的用法。<code>execute()</code> 方法实际返回的是 Java 的 <code>Process</code> 类，代表着一个<strong>运行的进程</strong>，通过访问 Process 实例的相关属性，我们可以获取到子进程的运行状态，因此也建议去 javadoc 或者在这篇文章 <a href="https://zhuanlan.zhihu.com/p/44957705">java Process类详解！ - 知乎 (zhihu.com)</a> 中了解 Process 类的相关内容。</p>
<p>Groovy 提供了简单的方式来获取一个 Process 的 I/O 流：</p>
<ol>
<li><code>in</code> 输入流，用于接收子进程的正常运行结果 (  <code>execute().text</code> 默认从这里获取信息 )。</li>
<li><code>err</code> 输入流，用于接收子进程本身的异常调用信息 ( 通常都是因为找不到对应的命令，程序，然后由操作系统给出错误提示。也有一些奇怪的特例：比如 <code>java -version</code> 打印的消息会输入到 <code>err</code> 流而非 <code>in</code> 流 )。</li>
<li><code>out</code> 输出流，用于向子进程传递信息。</li>
</ol>
<p>下面这段 Groovy 调用 <code>java</code> 命令执行另一个 <code>HelloWorld</code> 类的主程序，此主程序正通过 <code>Scanner</code> 类阻塞式地等待接收外部的消息，并在回显这条消息后退出。这里演示了这三个流的傻瓜式操作：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// execute() 的第一个参数表示环境变量参数。传入空数组或 null 表示沿用当前进程的环境变量参数。</span><br><span class="hljs-keyword">def</span> p = <span class="hljs-string">&quot;java HelloWorld&quot;</span>.execute([],<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\i\\Desktop&quot;</span>))<br><span class="hljs-comment">// 向这个 java 进程传入消息。</span><br>p.out.withWriter &#123;<br>    w -&gt; w.write(<span class="hljs-string">&quot;hi&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 接收此 java 进程的返回值，或者中途抛出的异常。</span><br>p.<span class="hljs-keyword">in</span>.withReader &#123;<br>    r -&gt; println r.text<br>&#125;<br><br><span class="hljs-comment">// 如果进程本身报错，通过 err 流取出。</span><br>p.err.withReader &#123;<br>    r -&gt; println r.text<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另一个例子是，Groovy 跳转到其它的路径下执行 <code>dir</code> 命令 ( Windows 系统 ) 查看那个路径下的文件信息：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Windows 命令默认输出是 GBK 字符集，Java/String 的输入流默认是 UTF-8 字符集。</span><br>println <span class="hljs-string">&quot;cmd /C dir&quot;</span>.execute([],<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\i\\Desktop&quot;</span>)).<span class="hljs-keyword">in</span>.withReader(<span class="hljs-string">&quot;GBK&quot;</span>) &#123;<br>    reader -&gt; reader.text<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果打印的内容包含中文，那么输出的内容可能包含乱码。原因是 Windows 命令默认的编码格式是 GBK，而 Java Reader 的默认编码是 UTF-8，因此这里多了一步转换工作。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>5 分钟从 Java 到 Groovy</title>
    <url>/2021/04/23/Groovy/</url>
    <content><![CDATA[<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><p><a href="https://groovy.apache.org/download.html">安装</a> Groovy 本身非常简单。对于 Windows 端的用户，将 SDK Bundle 压缩包解压到磁盘的任意路径下，然后像配置 Java 一样去配置 Groovy 的 GROOVY_PATH 和 PATH 变量，Groovy 就算安装完成了。至于 IDE 的选择，笔者仍然选择使用 IDEA IntelliJ，去 plugins 那里搜一搜 Groovy 的插件，然后安装即可。</p>
<p>重点来了。笔者选择安装的版本是 GDK 3.0.8 ( 官方说这是最新的稳定发行版本)，它最高支持到 JDK 1.8 ，在更高的版本运行 Groovy 会报错[^1]。这不是我们因为操作疏忽引发的错误，这主要和 JDK 本身的变动有关系。如果要在高版本的 JDK  下运行 Groovy 脚本，则需要在项目中将缺失的依赖项补充上 ( 假设正在 Maven 项目中使用它 )：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-runtime<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如果你需要使用 Java 和 Groovy 混合开发一些项目，那么 Maven 应该同时配置一个编译插件以及保证 Groovy 能够正常编译的最小依赖包 ( 下方的 groovy-all )。详情参考<a href="https://zhuanlan.zhihu.com/p/75976213">这篇知乎链接</a>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.groovy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>groovy-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h1 id="2-Hello！初来乍到"><a href="#2-Hello！初来乍到" class="headerlink" title="2. Hello！初来乍到"></a>2. Hello！初来乍到</h1><p>首先，很难用 “编译型还是解释型” 来区分 Groovy 和 Java，因为两者都需要 <code>javac</code> or <code>groovyc</code> 将源码翻译成二进制码，然后交给 JVM 解释执行。这样看的话，Java 和 Groovy 应该都算 “编译兼解释型” 语言。两者的主要区别是：Java 是典型的静态语言 ( 所有的数据都在编译期间就被确定 )，而 Groovy 可以做到 “动态分发”，同时也支持静态编译。</p>
<p>下面的细节有助于我们快速从 Java 过渡 Groovy。</p>
<h2 id="2-1-Groovy-as-Script"><a href="#2-1-Groovy-as-Script" class="headerlink" title="2.1 Groovy as  Script"></a>2.1 Groovy as  Script</h2><p>得益于 Groovy 的简练语法（其实几乎只要是个新颖的编程语言就要比 Java 简洁得多，因此 “简洁” 其实不应该再算是 Groovy 的 Feature）和动态特性，使得 Groovy 可以轻松地和系统进程进行交互：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 用 groovy 去执行 &quot;groovy -v&quot;.</span><br><span class="hljs-comment">// Windows 环境下需要带上 cmd /C 前缀。</span><br>println(<span class="hljs-string">&quot;cmd /C groovy -v&quot;</span>.execute().text)<br></code></pre></td></tr></table></figure>

<p><code>execute()</code> 方法可以将这个字符串视作是一个<strong>命令</strong>交给系统去执行，<code>.text</code> 可以获取该命令在系统下的执行结果。下面演示了在 Linux 和 Windows 系统当中，如何通过 <code>.groovy</code> 脚本实现 “浏览当前目录（即执行者 <code>.groovy</code> 所在的那个目录下）的内容”：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Linux 系统</span><br>println(<span class="hljs-string">&quot;ls -l&quot;</span>)<br><br><span class="hljs-comment">// Windows 系统</span><br>println(<span class="hljs-string">&quot;cmd /C dir&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>注意，<code>ls</code> 是 Linux 系统中可以直接运行的程序，但是 <code>dir</code> 在 Widows 系统中仅仅是 <code>cmd</code> 命令行解释器当中定义的一条命令，所以在这里补充了额外的前缀 <code>cmd /C</code>。一段 Groovy 代码还可以即时调用另一个文件存储的 Groovy 代码。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">evaluate(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\i\\IdeaProjects\\GroovyHello\\src\\HelloWorld.groovy&quot;</span>))<br><span class="hljs-comment">// 在另一个 ./HelloWorld.groovy 脚本中，我们在那个文件里仅使用了一句 print &#x27;hello World! -by groovy&#x27; 令其输出一段话。</span><br></code></pre></td></tr></table></figure>

<p>因此，Groovy 被称之为是 “JVM 上的脚本语言”，这名副其实。</p>
<h2 id="2-2-编写-Groovy-逻辑的两种风格"><a href="#2-2-编写-Groovy-逻辑的两种风格" class="headerlink" title="2.2 编写 Groovy 逻辑的两种风格"></a>2.2 编写 Groovy 逻辑的两种风格</h2><p>在 <code>.groovy</code> 文件内，可以不声明任何类而<strong>直接在文件顶级层次编写代码逻辑 (笔者刚才就是这样做的)<strong>。不过这样的话，就不能在文件的顶级层次再声明一个</strong>和文件同名的类</strong>，否则编译器会给出  <code>there is a synthetic class generated for script code</code> 的错误。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 假定这段代码出现在 Obj.groovy 源文件中 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span>&#123;</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// 这个方法调用和类声明一样都在文件的 &#x27;顶级&#x27; 位置。</span><br><span class="hljs-comment">// We don&#x27;t need &#x27;System.out.println(...)&#x27; anymore.</span><br>print(<span class="hljs-string">&#x27;hello groovy&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>从编译角度来看这可以理解，因为 <code>.groovy</code> 文件被编译成 <code>.class</code> 文件并执行时，编译器实际上会为其生成一个合成类，而正是这一步导致了冲突发生：我们刚定义的类名和它重复了。</p>
<p>实际上，如果 <code>.groovy</code> 文件内部出现了和文件同名的类，则意味着这个 <code>.groovy</code> 文件会被视作是一段 “用 Groovy 方言编写的 Java 代码”，一般它也就不再作为脚本使用，而是变成一个 “普通的类” ( IDEA 称它是一个 Groovy Class) 。这么做的一个直接后果是，我们不能够在文件的顶级层次直接编写代码逻辑。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 这段代码出现在 Obj.groovy 源文件中。</span><br><span class="hljs-comment">// 它相当于是 .java 文件中的 public class 定义.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span>&#123;</span><br>    <span class="hljs-comment">// 就像在写 Java 代码一样!</span><br>    <span class="hljs-comment">// 在 Groovy 中，public 关键字其实是多余的，默认情况下所有的声明就是 public。</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args)&#123;<br>         <span class="hljs-comment">// 在 Groovy 中，字符串还可以使用 &quot;&quot;,&#x27;&#x27;,&quot;&quot;&quot; &quot;&quot;&quot;,&#x27;&#x27;&#x27; &#x27;&#x27;&#x27;,包裹，具体区别见后文。</span><br>		print(<span class="hljs-string">&#x27;hello groovy&#x27;</span>)<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 它相当于是 .java 文件中的非 public class 定义.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherObj</span>&#123;</span>&#125;<br><br><span class="hljs-comment">// 代码不能再出现在文件的 &#x27;顶层&#x27; 位置，因为我们在 Java 开发时就不是这样做的。</span><br>print (<span class="hljs-string">&#x27;oops&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="2-3-异常处理"><a href="#2-3-异常处理" class="headerlink" title="2.3 异常处理"></a>2.3 异常处理</h2><p>Java 总是要我们在第一时间处理受检异常，否则傲娇的 <code>javac</code> 编译器就拒绝执行。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/HelloWorld.groovy&quot;</span>);<br>        <span class="hljs-comment">// FileInputStream 抛出受检异常，因此调用它的函数要么继续 throws 到上级 (当然，主程序 throws 异常没什么意义)，</span><br>        <span class="hljs-comment">// 要么就通过 try-catch 内部解决掉它。</span><br>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而 Groovy 对异常处理的写法更为宽松：如果没有在该代码块内通过 try-catch 处理异常，那么该异常就会自动地向上级抛出，且无需在函数声明中使用 <code>throws</code> 主动定义它们。下面是 Groovy 代码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 即使没有声明 throws，也没有定义 try-catch, groovyc 仍然会正常执行。</span><br>File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&#x27;HelloWorld.groovy&#x27;</span>)<br>FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file)<br></code></pre></td></tr></table></figure>

<h2 id="2-4-简洁的-“非空则调用”-语法"><a href="#2-4-简洁的-“非空则调用”-语法" class="headerlink" title="2.4 简洁的 “非空则调用” 语法"></a>2.4 简洁的 “非空则调用” 语法</h2><p>为了避免调用某个空指针的方法，在 Java 代码中，我们通常要包裹一层 if 语句块：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">String maybeNull = <span class="hljs-string">&quot;I&#x27;m Java&quot;</span>;<br><span class="hljs-keyword">if</span>(maybeNull != <span class="hljs-literal">null</span>)&#123;System.out.println(nullString.length());&#125;<br></code></pre></td></tr></table></figure>

<p>这一长串逻辑在 Groovy 当中可以直接使用一个 <code>?.</code> 操作符解决：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">String maybeNull = <span class="hljs-string">&#x27;I\&#x27;m groovy&#x27;</span><br>print(maybeNull?.length())<br></code></pre></td></tr></table></figure>

<h2 id="2-5-GString"><a href="#2-5-GString" class="headerlink" title="2.5 GString"></a>2.5 GString</h2><p>在 Groovy 中，短字符串可以使用 <code>&#39;&#39;</code> 或者 <code>&quot;&quot;</code> 表示，而需要跨行的长字符串则通常使用 <code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或者 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code> 。被双引号包括的字符串又被称为 GString，和原生的 String 相比，它支持在字符串内部使用 <code>$&#123;&#125;</code> 做占位符 ( 类似 <code>printf </code>)，避免了手工的 String 字符串拼接。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">name = <span class="hljs-string">&#x27;Wangfang&#x27;</span><br>age = <span class="hljs-string">&#x27;18&#x27;</span><br><br><span class="hljs-comment">// 占位符拼接的用法</span><br>print(<span class="hljs-string">&quot;my name is $&#123;name&#125;,my age is $&#123;age&#125;.&quot;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="2-6-精简的-JavaBean"><a href="#2-6-精简的-JavaBean" class="headerlink" title="2.6 精简的 JavaBean"></a>2.6 精简的 JavaBean</h2><p>在 Groovy 当中，编译器总是自动在底层为属性生成对应的 Set 和 Get 方法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student_</span> &#123;</span><br>    String name<br>    Integer age<br>    <br>    Student_(String name,Integer age)&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>        <span class="hljs-built_in">this</span>.age = age<br>    &#125;<br>&#125;<br><br>Student_ s = <span class="hljs-keyword">new</span> Student_()<br><span class="hljs-comment">// 这个 getXXX 方法是由编译器生成的。</span><br>s.getName()<br></code></pre></td></tr></table></figure>

<p>如果希望某个属性在对象被构造之后就不可变，则需使用 <code>final</code> 关键字，编译器将不会主动地为其生成 Set 方法 ( 意味着该属性是只读的 ) 。另外，属性可以不主动声明类型，此时原本的类型被 <code>def</code> 关键字替代。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student_</span>&#123;</span><br>	<span class="hljs-keyword">final</span> name<br>	<span class="hljs-keyword">def</span> age<br>	Student_(name,age)&#123;<br>		<span class="hljs-built_in">this</span>.name = name <br>		<span class="hljs-built_in">this</span>.age = age<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于未主动声明类型的属性，其本质上属于 Object 对象，这不利于对该属性的后续操作。想要解决这个问题，不妨在构造器中留下一些线索，以便于编译器能够 “推导” 出目标类型 ( Groovy 总是通过变量的赋值来推断这个变量的实际类型 )。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student_</span>&#123;</span>    <br>    <span class="hljs-keyword">final</span> name<br>    <span class="hljs-keyword">def</span> age<br><br>    <span class="hljs-comment">// 使得 name 和 age 属性的实际类型可以被推导 </span><br>    Student_(String name, Integer age)&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>        <span class="hljs-built_in">this</span>.age = age<br>    &#125;<br>&#125;<br><br>s = <span class="hljs-keyword">new</span> Student_(<span class="hljs-string">&#x27;Wang Fang&#x27;</span>,<span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure>

<p>如果一个属性被声明为了 <code>private</code>，则编译器不会再自动地为该属性声明 Get 和 Set 方法。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student_</span>&#123;</span>    <br>    <span class="hljs-keyword">final</span> name<br>    <span class="hljs-keyword">private</span> age<br><br>    <span class="hljs-comment">// 使得 name 和 age 属性的实际类型可以被推导 </span><br>    Student_(String name, Integer age)&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>        <span class="hljs-built_in">this</span>.age = age<br>    &#125;<br>&#125;<br><br>s = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;Wang Fang&#x27;</span>,<span class="hljs-number">23</span>)<br><br><span class="hljs-comment">//报错</span><br>s.getName()<br></code></pre></td></tr></table></figure>

<h2 id="2-7-或许无需手动创建构造器"><a href="#2-7-或许无需手动创建构造器" class="headerlink" title="2.7 或许无需手动创建构造器"></a>2.7 或许无需手动创建构造器</h2><p>对于上述的 Student_ 类而言，它可能需要有 4 个构造器：无参构造器，仅附带 name 属性的构造器，仅附带 age 属性的构造器，完整的构造器。Groovy 可以让我们仅通过一个 Map 实现灵活的对象创建，并且不需要再手动地补充构造器写法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student_</span>&#123;</span><br>    String name<br>    Integer age<br>&#125;<br><br><span class="hljs-comment">// 没有实现 Student_(name,age) 构造器，但是可以直接使用</span><br>stu1 = <span class="hljs-keyword">new</span> Student_(<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Wang Fang&quot;</span>,<span class="hljs-attr">age:</span> <span class="hljs-number">12</span>)<br><br><span class="hljs-comment">// 同样，我们也没有手动实现 Student_(name) 构造器。</span><br>stu2 = <span class="hljs-keyword">new</span> Student_(<span class="hljs-attr">name:</span><span class="hljs-string">&quot;Wang Fang&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>在些参数列表中，我们传入的其实是一整个 Map。里面的每一个 <code>k:v</code> 都表示了一个键值对。<code>k</code> 对应了这个类当中每个属性名，而 <code>v</code> 则为这些属性赋值。但是，我们不能这样做：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">stu1 = <span class="hljs-keyword">new</span> Student_(<span class="hljs-string">&quot;Wang Fang&quot;</span>,<span class="hljs-number">12</span>)<br>stu2 = <span class="hljs-keyword">new</span> Student_(<span class="hljs-string">&quot;Wang Fang&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>除非手动地补充上对应的构造函数。</p>
<h2 id="2-8-方法中的可选形参"><a href="#2-8-方法中的可选形参" class="headerlink" title="2.8 方法中的可选形参"></a>2.8 方法中的可选形参</h2><p>Java 不支持可选形参，在调用方法时，每个参数必须严格赋值。而 Groovy 则有所不同：在方法 ( 或函数 ) 参数列表内，可以提前为<strong>最后一个</strong>参数设定默认值，那么在调用该方法时，最后一个参数可以被省略。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> add(Integer arg,Integer implicit = <span class="hljs-number">10</span>)&#123;arg + implicit&#125;<br><br><span class="hljs-comment">// 11</span><br>print(add(<span class="hljs-number">1</span>))<br><span class="hljs-comment">// 3 </span><br>print(add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>

<p>这个例子还展现了其它细节：至少，Groovy 的方法 ( 函数 ) 不要求显示地添加 <code>return</code> 关键字，它总是默认返回函数体内最后一个调用的结果值。然后，这个函数的返回值类型是显然可以推断的，因此这里也可使用 <code>def</code> 关键字替换掉函数的返回值声明。</p>
<h2 id="2-9-多重赋值"><a href="#2-9-多重赋值" class="headerlink" title="2.9 多重赋值"></a>2.9 多重赋值</h2><p>如果方法 ( 函数 ) 返回的是一个数组，那么 Groovy 支持使用多个变量接收数组内的元素内容。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> swap(x, y) &#123; <span class="hljs-keyword">return</span> [y, x] &#125;<br><br>Integer a, b<br>a = <span class="hljs-number">10</span><br>b = <span class="hljs-number">50</span><br><br><span class="hljs-comment">// 通过多重赋值实现了两数交换</span><br>(a, b) = swap(a, b)<br>print(<span class="hljs-string">&quot;a=$a,b=$b&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>利用这个特点，Groovy 的方法 (函数) 可以返回多个值。其它支持这么做的编程语言还有 Go，Scala ( 通过包装成元组来实现 ) 等。当接收变量的个数和实际的返回值个数不匹配时，Groovy 会这样做：</p>
<ol>
<li>如果接收的变量更多，那么会将没有赋值的变量赋为 null 。</li>
<li>如果返回值更多，那么多余的返回值会被丢弃。</li>
</ol>
<p>当然，Groovy 也的确提供了元组，这个写法对于一些 Scala 程序员绝对不陌生：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">Tuple2&lt;Integer,Integer&gt; swap(Integer a,Integer b)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Tuple2&lt;Integer,Integer&gt;(b,a)<br>&#125;<br><br>a = <span class="hljs-number">10</span><br>b = <span class="hljs-number">20</span><br><br>(a, b) = swap(a, b)<br>print(<span class="hljs-string">&quot;a=$&#123;a&#125;,b=$&#123;b&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>



<h2 id="2-10-接口实现"><a href="#2-10-接口实现" class="headerlink" title="2.10 接口实现"></a>2.10 接口实现</h2><p>假定有这样一个单方法接口：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Calculator</span>&lt;<span class="hljs-title">T</span>&gt;&#123;</span><br>    T add(T a,T b)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Java 可能要这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Calculator&lt;Integer&gt; calculator = <span class="hljs-keyword">new</span> Calculator&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">add</span><span class="hljs-params">(Integer a, Integer b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在 Java 8 之后，匿名实现的写法终于变得更简练了亿些，但遗憾的是，Lambda 表达式只能用于单方法接口。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">Calculator&lt;Integer&gt; calculator = <span class="hljs-function"><span class="hljs-params">(a, b)</span> -&gt;</span> a + b;<br></code></pre></td></tr></table></figure>

<p>Groovy 给出了与众不同的解决思路：首先给出 Lambda 表达式的语法块，这个语法块被 <code>&#123;&#125;</code> 包裹，在 Groovy 中它被称之为闭包；然后通过 <code>as</code> 关键字将这个闭包声明为是对某一接口的实现[^2]。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 多亏类型推导的存在，我们不需要把 Calculator&lt;Integer&gt; 重新抄写一遍 .....</span><br><span class="hljs-keyword">def</span> a = &#123;a,b -&gt;<span class="hljs-keyword">return</span> a+b&#125; <span class="hljs-keyword">as</span> Calculator&lt;Integer&gt;<br></code></pre></td></tr></table></figure>

<p>如果要实现多方法接口，那么就将多个闭包装入到一个 Map 当中，使用 <code>k</code> 来标注每个闭包实现的是哪个方法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Calculator</span>&lt;<span class="hljs-title">T</span>&gt; &#123;</span><br>    T add(T a, T b)<br>    T sub(T a, T b)<br>&#125;<br><br><span class="hljs-keyword">def</span> cal = [<br>        <span class="hljs-symbol">add:</span> &#123; a, b -&gt; a + b &#125;,<br>        <span class="hljs-symbol">sub:</span> &#123; a, b -&gt; a - b &#125;<br>] <span class="hljs-keyword">as</span> Calculator&lt;Integer&gt;<br><br><span class="hljs-keyword">def</span> c = cal.sub(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>print(c)<br></code></pre></td></tr></table></figure>

<p>Groovy 从未强制实现一个接口的所有方法：如果某些方法确实用不到，那就没有必要将对应的闭包实现放入 Map 中。值得注意的是，如果调用了没有实现的接口方法，那么程序就会抛出亲切的 <code>NullPointerException</code> 异常。</p>
<h2 id="2-11-布尔求值"><a href="#2-11-布尔求值" class="headerlink" title="2.11 布尔求值"></a>2.11 布尔求值</h2><p>在 If 语句的条件部分，Java 强制要求传入一个计算好的布尔值，否则就报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span><br><span class="hljs-comment">// :)     =&gt; if(a != 0)...</span><br><span class="hljs-comment">// :(     =&gt; if(a)...</span><br></code></pre></td></tr></table></figure>

<p>Groovy 的处理则更加优雅一些，当传入的值不是纯粹的布尔值时，Groovy 会基于传入的类型进行一些合理的推断，而不是直接报错，参见下方的表格：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>何时为真</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>值是 true</td>
</tr>
<tr>
<td>Collection</td>
<td>集合本身不是 null，且内部有元素</td>
</tr>
<tr>
<td>Character</td>
<td>值不为 0</td>
</tr>
<tr>
<td>CharSequence</td>
<td>长度大于 0</td>
</tr>
<tr>
<td>Enumeration</td>
<td>Has More Enumerations 为 True</td>
</tr>
<tr>
<td>Iterator</td>
<td>hasNext() 为 True</td>
</tr>
<tr>
<td>Number</td>
<td>Double 值不为 0</td>
</tr>
<tr>
<td>Map</td>
<td>映射本身不是 null，且映射内部不为空</td>
</tr>
<tr>
<td>Matcher</td>
<td>至少有一个匹配</td>
</tr>
<tr>
<td>Object[]</td>
<td>长度大于 0</td>
</tr>
<tr>
<td>其它类型</td>
<td>引用不为 null</td>
</tr>
</tbody></table>
<p>在大部分情况下，直接向 if 条件部分传入一个值都是为了判断它是否为空。如果要基于该值是否为空来决定是否执行一系列动作，可以考虑使用前文提到的 <code>?.</code> 操作符简化代码。</p>
<h2 id="2-12-运算符重载"><a href="#2-12-运算符重载" class="headerlink" title="2.12 运算符重载"></a>2.12 运算符重载</h2><p>Groovy 预留了一些方法名称，这些方法意味着对操作符进行重载[^3]：</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Method</th>
</tr>
</thead>
<tbody><tr>
<td>a + b</td>
<td>a.plus(b)</td>
</tr>
<tr>
<td>a – b</td>
<td>a.minus(b)</td>
</tr>
<tr>
<td>a * b</td>
<td>a.multiply(b)</td>
</tr>
<tr>
<td>a ** b</td>
<td>a.power(b)</td>
</tr>
<tr>
<td>a / b</td>
<td>a.div(b)</td>
</tr>
<tr>
<td>a % b</td>
<td>a.mod(b)</td>
</tr>
<tr>
<td>a | b</td>
<td>a.or(b)</td>
</tr>
<tr>
<td>a &amp; b</td>
<td>a.and(b)</td>
</tr>
<tr>
<td>a ^ b</td>
<td>a.xor(b)</td>
</tr>
<tr>
<td>a++ or ++a</td>
<td>a.next()</td>
</tr>
<tr>
<td>a– or –a</td>
<td>a.previous()</td>
</tr>
<tr>
<td>a[b]</td>
<td>a.getAt(b)</td>
</tr>
<tr>
<td>a[b] = c</td>
<td>a.putAt(b, c)</td>
</tr>
<tr>
<td>a &lt;&lt; b</td>
<td>a.leftShift(b)</td>
</tr>
<tr>
<td>a &gt;&gt; b</td>
<td>a.rightShift(b)</td>
</tr>
<tr>
<td>switch(a) { case(b) : }</td>
<td>b.isCase(a)</td>
</tr>
<tr>
<td>~a</td>
<td>a.bitwiseNegate()</td>
</tr>
<tr>
<td>-a</td>
<td>a.negative()</td>
</tr>
<tr>
<td>+a</td>
<td>a.positive()</td>
</tr>
</tbody></table>
<p>而这些操作符在遇到 null 时不会抛出空指针异常：</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Method</th>
</tr>
</thead>
<tbody><tr>
<td>a == b</td>
<td>a.equals(b) or a.compareTo(b) == 0 **</td>
</tr>
<tr>
<td>a != b</td>
<td>! a.equals(b)</td>
</tr>
<tr>
<td>a &lt;=&gt; b</td>
<td>a.compareTo(b)</td>
</tr>
<tr>
<td>a &gt; b</td>
<td>a.compareTo(b) &gt; 0</td>
</tr>
<tr>
<td>a &gt;= b</td>
<td>a.compareTo(b) &gt;= 0</td>
</tr>
<tr>
<td>a &lt; b</td>
<td>a.compareTo(b) &lt; 0</td>
</tr>
<tr>
<td>a &lt;= b</td>
<td>a.compareTo(b) &lt;= 0</td>
</tr>
</tbody></table>
<p>举个例子：在程序中定义复数类，然后定义两个复制之和是实部和虚部的分别加和：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComplexNumber</span> &#123;</span><br>    Integer real<br>    Integer imaginary<br><br>    <span class="hljs-comment">//plus 方法对应 + 操作符</span><br>    <span class="hljs-keyword">def</span> plus(ComplexNumber other) &#123;<br>        <span class="hljs-keyword">new</span> ComplexNumber(<span class="hljs-attr">real:</span> <span class="hljs-built_in">this</span>.real + other.real,<span class="hljs-attr">imaginary:</span> <span class="hljs-built_in">this</span>.imaginary+other.imaginary)<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    String toString() &#123; <span class="hljs-string">&quot;$&#123;real&#125; + $&#123;imaginary&#125;i&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// 注意，这个写法相当于 println(...)</span><br><span class="hljs-comment">// 内部相当于是调用了 new ComplexNumber(balabala).plus(new ComplexNumber(balabala))</span><br>println <span class="hljs-keyword">new</span> ComplexNumber(<span class="hljs-attr">real:</span><span class="hljs-number">3</span>,<span class="hljs-attr">imaginary:</span>  <span class="hljs-number">2</span>) + <span class="hljs-keyword">new</span> ComplexNumber(<span class="hljs-attr">real:</span><span class="hljs-number">3</span>,<span class="hljs-attr">imaginary:</span><span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>但相比 Scala 而言，笔者认为这种方式有点奇怪 …… 因为当我们需要这么做时，总是得翻阅一下上面的表格，然后去比对哪个操作符对应哪个方法，除非把这张表格背下来 ( 可以，但没必要 )。不过不管怎么样，有总比没有强。</p>
<h2 id="2-13-for-循环"><a href="#2-13-for-循环" class="headerlink" title="2.13 for 循环"></a>2.13 for 循环</h2><p>下面是一段 Java 代码演示的 for 循环，i 从 0 开始，直到 3 ( 不包括 3)  为止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span> ; i++)&#123;System.out.println(<span class="hljs-string">&quot;java loop&quot;</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>在 Groovy 中， 0 ~ 3 的左闭右开区间可以使用 <code>0..2</code> 来表示：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.2</span>)&#123;println <span class="hljs-string">&quot;groovy loop&quot;</span>&#125;<br></code></pre></td></tr></table></figure>

<p><code>in</code> 通常用于遍历 “模糊类型” 的数组。如果遍历的是确定类型的数组，还可以这样写：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">String[] strings = [<span class="hljs-string">&#x27;java&#x27;</span>,<span class="hljs-string">&#x27;scala&#x27;</span>,<span class="hljs-string">&#x27;groovy&#x27;</span>,<span class="hljs-string">&#x27;go&#x27;</span>]<br><br><span class="hljs-comment">//  s 必须指明是 String 类型。</span><br><span class="hljs-comment">//  : 替换了之前的 in 关键字。</span><br><span class="hljs-keyword">for</span>(String <span class="hljs-attr">s :</span> strings)&#123;<br>    print(s.length())<br>&#125;<br><br><span class="hljs-comment">//  等价写法</span><br><span class="hljs-keyword">for</span> (s <span class="hljs-keyword">in</span> strings)&#123;<br>    print s.length()<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>..</code> 可以被视作是一个特殊的二元符号，在循环语句之外也可以单独使用它来创建一个步长为 1 的序列。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 你可以将 .. 视作是 Integer 的一个双目运算符号，其中 n..m 会返回 [n,n+1,n+2,...m] 的序列。</span><br><span class="hljs-comment">// seq 是 IntRange 类型。</span><br><span class="hljs-keyword">def</span> seq = <span class="hljs-number">0.</span><span class="hljs-number">.10</span><br><br><span class="hljs-comment">// 11</span><br>print seq.size()<br></code></pre></td></tr></table></figure>

<h2 id="2-14-关于导入"><a href="#2-14-关于导入" class="headerlink" title="2.14 关于导入"></a>2.14 关于导入</h2><p>Groovy 通常的导入方式和 Java 如出一辙，并且<strong>不强制</strong>所有的 <code>import</code> 出现在文件的最上方。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> java.lang.Math<br>print Math.random()<br></code></pre></td></tr></table></figure>

<p>除此之外，Groovy 支持 <code>import static</code> 导入某一个类的静态方法，这样我们可以在当前命名空间当中将该静态方法直接作为一个函数来调用。如果担心命名重复，可以使用 <code>as</code> 关键字将该静态方法重新命名。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 静态导入 Math 类的静态 random 方法</span><br><span class="hljs-comment">// as 关键字可以顺便将导入的静态方法起一个别名，通常用于简化或者避免命名冲突的目的。</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> math.random <span class="hljs-keyword">as</span> rdm<br>print rdm()<br></code></pre></td></tr></table></figure>

<h2 id="2-15-一切即闭包"><a href="#2-15-一切即闭包" class="headerlink" title="2.15 一切即闭包"></a>2.15 一切即闭包</h2><p>Groovy 特地将 <code>[]</code> 留给了数组的声明：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">String[] str = [<span class="hljs-string">&#x27;java&#x27;</span>,<span class="hljs-string">&#x27;groovy&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p>而一切 <code>&#123;&#125;</code> 代码块在 Groovy 会被视作一个<strong>闭包</strong>，闭包对于 Groovy 来说，是一个具体的 <code>Closure&lt;T&gt;</code> 类型[^4]。( 有关 Groovy 闭包的内容笔者后续会单独说明 ) 在 Java 中，我们可以使用 <code>&#123;&#125;</code> 表示一段有独立作用域的子代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&#123;<br>    System.out.println(<span class="hljs-string">&quot;block1&quot;</span>);<br>&#125;<br><br>&#123;<br>    System.out.println(<span class="hljs-string">&quot;block2&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// ()-&gt;void 函数也可以被理解成是子代码块。</span><br>Runnable runnable = () -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;block3&quot;</span>);<br>&#125;;<br><br>runnable.run();<br></code></pre></td></tr></table></figure>

<p>但在 Groovy 当中，一段 <code>&#123;&#125;</code> 扩起来的闭包不能单独声明出现，除非是写成赋值的形式：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 不能通过编译</span><br>&#123;print <span class="hljs-string">&quot;hello&quot;</span>&#125;<br><br><span class="hljs-comment">// 编译通过，这种赋值明确地表示 &#123;&#125; 是一个闭包。</span><br><span class="hljs-keyword">def</span> c = &#123;print <span class="hljs-string">&quot;hello&quot;</span>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-15-1-避免闭包和匿名类的冲突"><a href="#2-15-1-避免闭包和匿名类的冲突" class="headerlink" title="2.15.1 避免闭包和匿名类的冲突"></a>2.15.1 避免闭包和匿名类的冲突</h3><p>如果一个函数 / 方法接收闭包作为参数，那么从语法上可以将这些闭包附着在函数调用的尾部。形象点说，一个 <code>method(&#123;...&#125;,&#123;...&#125;)</code> 语句块可以改写成 <code>method() &#123;...&#125;&#123;...&#125;</code> 的形式 ( 这么做有利于设计内部 DSL 语法，想想我们为什么能够在 Groovy 写出诸如 <code>print &quot;hello&quot;</code> 的句式？) ：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> aspect(before, after) &#123;<br>    before()<br>    print(<span class="hljs-string">&quot;method&quot;</span>)<br>    after()<br>&#125;<br><br><span class="hljs-comment">// 正常的调用方式</span><br>aspect(&#123;print <span class="hljs-string">&quot;before doing...&quot;</span>&#125;,&#123;print <span class="hljs-string">&quot;after doing...&quot;</span>&#125;)<br><br><br><span class="hljs-comment">// 将闭包迁移到调用尾部，aspect() 的小括号 () 可写可不写。</span><br>aspect() &#123;<br>    print(<span class="hljs-string">&quot;before doing...&quot;</span>)<br>&#125; &#123;<br>    print(<span class="hljs-string">&quot;after doing...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有时，一个类的构造函数也会需要接收一个闭包，那么在这种场合可能会引发歧义：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aspect</span>&#123;</span><br>        <span class="hljs-comment">// Closure 是 Groovy 中表示闭包的类型。它实际上还有一个泛型，该泛型指代的是该闭包的返回值。</span><br>        Aspect(Closure before)&#123;<br>            before()<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>按照开头的调用风格，它可以被写成这样：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 这个写法的原意是将闭包写到构造函数的后面。</span><br><span class="hljs-keyword">def</span> a  = <span class="hljs-keyword">new</span> Aspect()&#123;<br>	print <span class="hljs-string">&quot;create a aspect...&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>但对于一个 Java 程序员而言，这种写法看起来却像是在创建一个匿名对象 —— 甚至 Groovy 也会不知所措。在这种情况下，必须严格使用 <code>()</code> 的语法避免歧义发生。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> a = <span class="hljs-keyword">new</span> Aspect(&#123;print <span class="hljs-string">&quot;create a aspect...&quot;</span>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="2-15-2-避免闭包和实例初始化器的冲突"><a href="#2-15-2-避免闭包和实例初始化器的冲突" class="headerlink" title="2.15.2 避免闭包和实例初始化器的冲突"></a>2.15.2 避免闭包和实例初始化器的冲突</h3><p>在某些类的定义中，我们需要使用一段 <code>&#123;&#125;</code> 扩起来的代码块作为<strong>实例初始化器</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span>&#123;</span><br><br>    String from = <span class="hljs-string">&quot;China&quot;</span><br><br>    <span class="hljs-comment">// 我们不认为它是闭包，而是实例初始化器</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;这段代码先于 Apple 的构造函数去执行&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然而 Groovy 却会把字符串 <code>&quot;China&quot;</code> 和它认为的 “闭包” <code>&#123;...&#125;</code> 视作是一个整体，而导致运行时出错。解决办法有两种：要么将实例初始化器移动到内部声明的最上方，要么就显示地使用 <code>;</code> 分号将两者分隔开：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 解决方法1，推荐</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span>&#123;</span><br><br>    &#123;<br>        print(<span class="hljs-string">&quot;&quot;</span>)<br>    &#125;<br>    <br>    String from = <span class="hljs-string">&quot;China&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 解决方法 2，不太推荐，因为这种写法容易让人混淆实例初始化器和普通闭包的声明。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span>&#123;</span><br><br>    String from = <span class="hljs-string">&quot;China&quot;</span>;<br><br>    &#123;<br>        print(<span class="hljs-string">&quot;&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-16-强力注解"><a href="#2-16-强力注解" class="headerlink" title="2.16 强力注解"></a>2.16 强力注解</h2><p>这里或许有一些官方提供的注解帮助快速开发，它们绝大部分都是来自于 <code>groovy.lang</code> 包，这意味着不需要通过 <code>import</code> 关键字额外地导入外部依赖：</p>
<h3 id="2-16-1-Canonical-替代-toString"><a href="#2-16-1-Canonical-替代-toString" class="headerlink" title="2.16.1 @Canonical 替代 toString"></a>2.16.1 @Canonical 替代 toString</h3><p>假如希望打印一个类信息，又不想自己生成 <code>toString()</code> 方法，则可以使用 <code>@Canonical</code> 注解。该注解有额外的 <code>excludes</code> 选项：允许我们忽略一些属性。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@Canonical</span><br><span class="hljs-comment">// 如果不想打印 id 和 score，可以：</span><br><span class="hljs-comment">// @Canonical(excludes=&quot;id,score&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> &#123;</span><br>    Integer id<br>    String name<br>    Integer age<br>    String major<br>    Integer score<br>&#125;<br><br><span class="hljs-comment">// 如果没有此注解，打印的则是 Student@Hashcode</span><br><span class="hljs-comment">// 如果有注解，打印的则是 Student(1,&quot;Wang Fang&quot;,20,&quot;CS&quot;,&quot;score&quot;)</span><br>print <span class="hljs-keyword">new</span> Student(<span class="hljs-attr">id:</span> <span class="hljs-number">1</span>,<span class="hljs-attr">name:</span><span class="hljs-string">&quot;Wang Fang&quot;</span>,<span class="hljs-attr">age:</span> <span class="hljs-number">20</span>,<span class="hljs-attr">major:</span> <span class="hljs-string">&quot;CS&quot;</span>,<span class="hljs-attr">score:</span> <span class="hljs-number">90.0</span>d)<br></code></pre></td></tr></table></figure>

<h3 id="2-16-2-Delegate-实现委托"><a href="#2-16-2-Delegate-实现委托" class="headerlink" title="2.16.2 @Delegate 实现委托"></a>2.16.2 @Delegate 实现委托</h3><p>使用 <code>@Delegate</code> 注解，在 Groovy 中实现方法委托非常容易。委托是继承以外的另一种代码复用的思路。在下面的代码块中，Manager 通过注解将 <code>work()</code> 方法委托给了内部的 worker 属性：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span>&#123;</span><br>    <span class="hljs-keyword">void</span> work()&#123;<br>        print(<span class="hljs-string">&quot;worker is working exactly.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Manager 获得了 Worker 的公开方法，尽管 worker 属性本身是 private.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span>&#123;</span><br>    <span class="hljs-meta">@Delegate</span> <span class="hljs-keyword">private</span> Worker worker = <span class="hljs-keyword">new</span> Worker()<br>&#125;<br><br><span class="hljs-comment">// 检查 Manager 实例有没有 work 方法，没有就去委托 worker 执行此方法。</span><br><span class="hljs-keyword">new</span> Manager().work()<br></code></pre></td></tr></table></figure>

<h3 id="2-16-3-Immutable-不可变对象"><a href="#2-16-3-Immutable-不可变对象" class="headerlink" title="2.16.3 @Immutable 不可变对象*"></a>2.16.3 @Immutable 不可变对象*</h3><p>不可变的对象天生就是线程安全的。想要创建一个不可变对象，需要限制它的类属性全部是 <code>final</code> ，一旦属性被初始化之后就不可以再被改变。<code>@Immutable</code> 注解可以提供一个便捷的解决方案：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@Immutable</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student_</span>&#123;</span><br>    String id<br>    String name<br>&#125;<br><br><span class="hljs-keyword">def</span> s = <span class="hljs-keyword">new</span> Student_(<span class="hljs-attr">id:</span><span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-attr">name:</span><span class="hljs-string">&quot;Wang Fang&quot;</span>)<br><br>print s<br></code></pre></td></tr></table></figure>

<p>和其它注解不同，它来自 <code>groovy.transform</code> 包。笔者在使用该注解的时候曾遇到一些奇怪的问题，IDEA 似乎不能很好的识别该注解，并进一步引发代码无法粘贴，错误地弹出警告，代码提示消失等 Bug。</p>
<h3 id="2-16-4-Lazy-延迟加载类成员"><a href="#2-16-4-Lazy-延迟加载类成员" class="headerlink" title="2.16.4 @Lazy 延迟加载类成员"></a>2.16.4 @Lazy 延迟加载类成员</h3><p>懒加载是大部分新兴语言都支持的特性。在 Groovy 中，它通过注解来实现，<strong>注意，该注解只能用于类成员</strong>。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span>&#123;</span><br>    <br>    <span class="hljs-comment">// 加载 Connection 需要 1 秒的时间</span><br>    Connection()&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>)<br>        print <span class="hljs-string">&quot;Connection 实例初始化完毕&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span>&#123;</span><br>    <br>    <span class="hljs-comment">// 由于代码没有调用 conn ，因此实际上 new Connection() 并没有真正执行</span><br>    <span class="hljs-meta">@Lazy</span> <span class="hljs-keyword">def</span> conn = <span class="hljs-keyword">new</span> Connection()<br>    Pool()&#123;<br>        print <span class="hljs-string">&quot;Pool 实例初始化完毕&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> pool = <span class="hljs-keyword">new</span> Pool();<br></code></pre></td></tr></table></figure>

<p>对于懒加载的成员只有在第一次被调用时才会被初始化，并且 Groovy 内部通过 voaltitle 关键字保证这个创建的过程是线程安全的。</p>
<h3 id="2-16-5-Newify-注解"><a href="#2-16-5-Newify-注解" class="headerlink" title="2.16.5 @Newify 注解"></a>2.16.5 @Newify 注解</h3><p>该注解的功能有点类似于 Scala 语言当中的 apply 方法，允许我们在创建新对象的时候忽略掉 <code>new</code> 关键字 ( 这个特性也有助于设计 DSL )。该注解可用在类声明和方法声明，也可以用在单独的变量赋值语句上：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&#123;</span><br>    String id<br>    String name<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span>&#123;</span><br>    String id<br>    String name<br>&#125;<br><br><span class="hljs-meta">@Newify</span>(Student)<br><span class="hljs-keyword">def</span> getStudent()&#123;<br>    <span class="hljs-comment">// 在函数内部创建 Student 时，可以省略掉 new 关键字。</span><br>    Student(<span class="hljs-attr">id:</span><span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Wang Fang&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 多个类型使用数组的形式排列。</span><br><span class="hljs-meta">@Newify</span>([Student,Teacher])<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> getStudentAndTeacher()&#123;<br>    [Student(<span class="hljs-attr">id:</span><span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-attr">name:</span><span class="hljs-string">&quot;Wang Fang&quot;</span>),Teacher(<span class="hljs-attr">id:</span> <span class="hljs-string">&quot;0002&quot;</span>,<span class="hljs-attr">name:</span><span class="hljs-string">&quot;Cheng Yu&quot;</span>)]<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-16-6-Singleton-单例模式"><a href="#2-16-6-Singleton-单例模式" class="headerlink" title="2.16.6 @Singleton 单例模式"></a>2.16.6 @Singleton 单例模式</h3><p>在 Groovy 中，仅凭 <code>@Singleton</code> 注解就可以实现一个线程安全，并且简洁的单例模式。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 懒加载的单例模式，lazy 项是可选的。</span><br><span class="hljs-meta">@Singleton</span>(lazy = <span class="hljs-literal">true</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TheUnique</span>&#123;</span><br>    &#123;<br>        println <span class="hljs-string">&quot;created only once&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过 .instance 调用这个单例对象。</span><br>TheUnique.instance<br></code></pre></td></tr></table></figure>

<p>单例模式可以选择懒汉式加载，仅需在注解的 <code>lazy</code> 选项中设置为 <code>true</code> 即可。</p>
<h2 id="2-17-注意-Groovy-的-符号"><a href="#2-17-注意-Groovy-的-符号" class="headerlink" title="2.17 注意 Groovy 的 == 符号"></a>2.17 注意 Groovy 的 == 符号</h2><p>在 Java 中，<code>==</code> 可以比较两个基本数据类型的值，或者比较两个引用类型的 HashCode。而 <code>.equals()</code> 方法如何比较则取决于开发者制定的规则：在什么都不做的情况下，<code>.equals</code> 方法和 <code>==</code> 等价。</p>
<p>对于一些常用类型，Java 已经制定好了 <code>.equals()</code> 方法的比较规则。就 String 而言，它的 <code>.equals()</code> 实现首先就是通过 <code>==</code> 符号判断两个字符串的引用是否相同，然后判断两个字符串的长度是否相同，最后再按位判断每个位置的字符是否相同。</p>
<p>而在 Groovy 当中，这两者的混乱程度有所加剧：Groovy 的 <code>==</code> <strong>相当于</strong>是 Java 的 <code>.equals()</code> 方法或者是 <code>compareTo()</code> 方法 (见运算符重载的那个表格)，而 Java 原始的 <code>==</code> 语义在 Groovy 中变成了 <code>is()</code> 方法。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">str1 = <span class="hljs-string">&quot;111&quot;</span><br>str2 = <span class="hljs-string">&quot;222&quot;</span><br><br><span class="hljs-comment">// 相当于是 Java 语义中的 str1 == str2</span><br>str1.is(str2)<br><br><span class="hljs-comment">// 相当于是 Java 语义中的 str1.equals(str2)</span><br>str1 == str2<br></code></pre></td></tr></table></figure>

<p>如果比较的类实现了 <code>Compareble</code> 接口，那么 <code>==</code> 的语义优先会选择 <code>compareTo()</code> 方法而非 <code>equals()</code> 方法。</p>
<h1 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3. 参考链接"></a>3. 参考链接</h1><p>[^0]:  Groovy 程序设计 [美]Venkat Subramaniam 著<br>[^1]: <a href="https://blog.csdn.net/qq_41886200/article/details/90443560">Groovy 在更高 JDK 版本使用的方法</a><br>[^2]: <a href="https://www.orcode.com/question/728715_k914e4.html">Groovy ‘as’ 用于实现2+接口的关键字</a><br>[^3]: <a href="https://www.cnblogs.com/rollenholt/archive/2013/10/02/3349047.html">Groovy：运算符重载</a><br>[^4]: 想要提前了解闭包，可以参考这篇文章：<a href="https://www.jianshu.com/p/abf755035d67">Groovy 闭包 - 简书 (jianshu.com)</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 实用小册</title>
    <url>/2021/04/23/Git%20%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%86%8C/</url>
    <content><![CDATA[<h1 id="Git-实用小册"><a href="#Git-实用小册" class="headerlink" title="Git 实用小册"></a>Git 实用小册</h1><p>笔者在进入梳理了有关于 Git 的基本概念及命令行下的使用方法。</p>
<p>对于 Windows 用户，不要使用 CMD 或者 Jet Branins IDE 提供的终端执行 Git 命令，因为 Git 会使用到 Linux 环境下的 vim 工具 ( 或者是其它命令 ) ，而 Windows 系统并不支持，因此在执行过程中会给出类似 <code>Git error: cannot spawn XXX: No such file or directory</code> 的提示，有时可能会影响 Git 的功能。</p>
<p>因此，安装 Git 后，请在项目根目录下点击右键：Git Bash Here 并使用 Git 。该终端将允许我们在模拟 Linux 的环境下来和 Git 进行交互。</p>
<p>随着笔者对 Git 的了解逐渐加深，本文的内容可能会随之更新。文内若出现部分理解出现偏颇的内容，欢迎大家指正。此为 Git 的官方文档：<a href="https://git-scm.com/doc">Git - Documentation (git-scm.com)</a></p>
<h2 id="1-四大区域与三个层次"><a href="#1-四大区域与三个层次" class="headerlink" title="1. 四大区域与三个层次"></a>1. 四大区域与三个层次</h2><p>在使用 Git 之前，首先要对这四个区域有一个基本的了解：</p>
<p><img  src="https://i.im5i.com/2021/04/23/wWAL8.png"  ><span class="image-caption">Git 的四大库及其操作</span></p>
<p>工作区间：即经过 <code>git init</code> 初始化后的项目目录。Git 会自动追踪该目录下的文件内容变更的情况。</p>
<p>暂存区：通过 <code>add</code> 命令 ( 可理解成 “选中” 操作) 告知 Git 有哪些文件需要被托管，这些文件 ( 及更改的内容 ) 会被移动到暂存区。</p>
<p>本地库：通过 <code>commit</code> 命令 ( 真正的 “提交” 操作 ) 告知 Git，将当前暂存区的内容永久保存。</p>
<p>远程库：Github，码云等云端代码托管平台，我们最终将本地库的代码存储到这里，以便于团队的跨网协作。</p>
<p>此外，对于一个 Git 项目，还可分为三个层级：</p>
<p><img  src="https://i.im5i.com/2021/04/23/wWevU.png"  ><span class="image-caption">Git 的库，分支，提交记录</span></p>
<p>一个库可包含多条分支，每一条分支代表了该 Git 项目的不同版本 ( 正式版本，测试版本，开发版本，特性开发版本等等 )。一条分支内又包含了多条提交记录，可以将每一次提交理解成某个版本的一个对应版本号。</p>
<h2 id="2-本地操作"><a href="#2-本地操作" class="headerlink" title="2. 本地操作"></a>2. 本地操作</h2><h3 id="2-1-创建本地分支并切换-Branch-Checkout"><a href="#2-1-创建本地分支并切换-Branch-Checkout" class="headerlink" title="2.1 创建本地分支并切换 - Branch / Checkout"></a>2.1 创建本地分支并切换 - Branch / Checkout</h3><p>对于任意一个想要托管到 Git 的项目工程，在根目录下使用以下命令进行初始化：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git init <br></code></pre></td></tr></table></figure>

<p>Git 将创建一个名为 <code>.git</code> 的隐藏文件夹，项目级别的相关配置会被放入其中。本篇作为 Git 的实用性质介绍，这里不去详细解析该文件夹的内容和功能。首先，使用 <code>add</code> 命令选中要被 Git 托管的文件，这些文件 ( 及其变更 ) 会被移动到暂存区中等待提交。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 选中某个文件</span><br>$ git add &lt;path&gt;<br><br><span class="hljs-comment"># 选中目录下的全部文件</span><br>$ git add .<br></code></pre></td></tr></table></figure>

<p>紧接着就是通过 <code>commit</code> 命令将刚才选中的文件从暂存区永久保存到本地库内。 <code>-m</code> 的功能相当于代码的注释，尤其在团队合作中，我们需要提供足够的信息来描述此次提交的缘由，或者是维护 / 更新的内容。</p>
<p>如果要将某个文件从暂存区移除，笔者的做法是先在工作区间内将此文件删除，然后再将剩余的文件添加到暂存区：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ rm &lt;path&gt;<br>$ git add .<br></code></pre></td></tr></table></figure>

<p>如果没有带上 <code>-m</code> 参数，则 Git 会打开 vim 强制要求补充描述信息，否则 Git 将拒绝执行这次提交。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git commit -m <span class="hljs-string">&quot;why this commit&quot;</span><br></code></pre></td></tr></table></figure>

<p>如果此次提交没有新增任何文件 ( 言外之意是所有更新都是基于已有文件进行的 ) ，则可以通过 <code>-a</code> 参数 “略过暂存区” 而直接提交到本地库。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git commit -am <span class="hljs-string">&quot;why this commit&quot;</span><br></code></pre></td></tr></table></figure>

<p>一个 Git 项目的各种环境 ( 比如正式版本，特性开发版本，开发版本 ) 区分都是 “基于分支” 实现的。刚才的 <code>commit</code> 命令更确切的说是 “提交到了本地库的 <code>master</code> 分支” 上。</p>
<p>对初始 Git 项目做第一次提交之后，Git 将创建出本地库的第一条名为 <code>master</code> 的分支。使用 <code>branch</code> 命令能够查看本地库内拥有的全部分支。其中，带 <code>*</code> 标记的分支表示目前所处的分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git branch<br></code></pre></td></tr></table></figure>

<p>此外，使用 <code>git status</code> 能够查看到该分支的状态。该命令在后文中会经常使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git status<br><br><span class="hljs-comment"># 首先会打印出当前所在的分支名称</span><br><span class="hljs-comment"># On branch &lt;branchName&gt;</span><br><br><span class="hljs-comment"># 当暂存区内有等待 commit 提交的文件时：</span><br><span class="hljs-comment"># Changes to be committed:</span><br><span class="hljs-comment">#  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#        ...</span><br><br><span class="hljs-comment"># 当工作区间存在没有被 add 命令添加的文件时:</span><br><span class="hljs-comment"># Untracked files:</span><br><span class="hljs-comment">#  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#        ...</span><br><br><span class="hljs-comment"># 在工作区间的文件全部 add + commit 完毕后，将显示：</span><br><span class="hljs-comment"># nothing to commit, working tree clean</span><br></code></pre></td></tr></table></figure>

<p>Git 能够以一个分支为镜像 “深复制” 出另一个新的分支。对这个分支的后续更改都不会影响到当前分支。<strong>每个分支将独立记录项目目录下的文件状态</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git branch &lt;nbn&gt;<br><br><span class="hljs-comment"># 另一个方法是 checkout 创建并进入到该分支:</span><br>$ git checkout -b &lt;nbn&gt;<br></code></pre></td></tr></table></figure>

<p><code>nbn</code> ( new branch name ) 指这个新分支的名称。相对的，附带 <code>-d &lt;bn&gt;</code> 或 <code>-D &lt;bn&gt;</code> 表示删除分支，但是不可以删除掉当前所在的分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git branch -d &lt;bn&gt;<br><br><span class="hljs-comment"># 当某个分支存在未合并完的内容时，Git 可能会拒绝删除此分支。</span><br><span class="hljs-comment"># 下面的命令是强制删除分支：</span><br>$ git branch -D &lt;bn&gt;<br></code></pre></td></tr></table></figure>

<p>如果要在多个分支工作，则需要手动切换。 <code>otherBn</code> 指代其它分支的名字。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git checkout &lt;otherBn&gt;<br></code></pre></td></tr></table></figure>

<p>在切换分支时，工作区间内的文件也会随之切换到对应的版本。下面的语句块演示了这一过程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 假定目前在 master 分支，创建了新文件</span><br>$ touch master_cfg<br><br>$ ls <span class="hljs-comment"># 只能看到一个 master_cfg</span><br><br><span class="hljs-comment"># 创建新分支，并切换到新分支中</span><br><span class="hljs-comment"># 可以使用一行命令:</span><br><span class="hljs-comment"># git checkout -b backup</span><br>$ git branch backup<br>$ git checkout backup<br><br><span class="hljs-comment"># 在该分支下创建新文件，并 commit </span><br>$ touch backup_cfg<br>$ git add backup_cfg<br>$ git commit -m <span class="hljs-string">&quot;create a new file in the branch:backup&quot;</span><br><br>$ ls <span class="hljs-comment"># 能看到两个文件：master_cfg, backup_cfg</span><br><br><span class="hljs-comment"># 回到主分支下</span><br>$ git checkout master<br><br>$ ls <span class="hljs-comment"># 项目目录又只剩下一个 master_cfg 了，backup_cfg 只会在 backup 分支下存在。</span><br></code></pre></td></tr></table></figure>

<h3 id="2-2-临时保存工作进度-Stash"><a href="#2-2-临时保存工作进度-Stash" class="headerlink" title="2.2 临时保存工作进度 - Stash"></a>2.2 临时保存工作进度 - Stash</h3><p>在切换分支之前，Git 要求所有<strong>被追踪文件的修改</strong>都已经提交到本地分支上。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"># xxx.txt 发生了修改，但是没有被 <span class="hljs-built_in">add</span> 到暂存区。<br>Changes not staged <span class="hljs-keyword">for</span> commi<span class="hljs-variable">t:</span><br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will <span class="hljs-keyword">be</span> committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> discard <span class="hljs-keyword">changes</span> in working directory)<br><br>        modified:   xxx.txt<br>        <br># xxx.txt 发生了修改，但是没有被 commit 到本地分支。        <br>Changes <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> unstage)<br><br>        modified:   xxx.txt<br>        <br></code></pre></td></tr></table></figure>

<p>如果 <code>git status</code> 有提示以上的信息，则切换分支会被拒绝：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>Your local changes to the following files would be overwritten by checkout:<br>        xxx.txt<br>Please commit your changes or stash them before you switch branches.<br></code></pre></td></tr></table></figure>

<p>Git 提示，此时要么通过 <code>commit</code> 提交更改，要么通过 <code>stash</code> 将这些改动临时保存起来：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git stash<br>$ git stash save <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-comment"># git stash save &quot;save the modified in xxx.txt&quot;</span><br></code></pre></td></tr></table></figure>

<p><code>save &quot;message&quot;</code> 用于为临时存档添加描述信息，虽然是非必须选项，但是建议添加。通过 <code>stash list</code> 能够查询本地库通过 <code>stash</code> 保存的所有临时存档，以及这些存档所在的分支：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git stash list<br><span class="hljs-comment"># stash@&#123;0&#125;: On opps: save the modified in xxx.txt</span><br></code></pre></td></tr></table></figure>

<p>恢复存档有两种形式，<code>pop</code> 和 <code>apply</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># n 是 stash list 中显示的某个临时存档的序列号。</span><br><span class="hljs-comment"># 恢复这个临时存档，并且此存档从 stash list 中删掉。</span><br>$ git stash pop stash@&#123;n&#125;<br><br><span class="hljs-comment"># 恢复这个临时存档，并且此存档仍然在 stash apply 中保留。</span><br>$ git stash apply stash@&#123;n&#125;<br></code></pre></td></tr></table></figure>

<p>同样，临时存档也可以不恢复而直接删除：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 删除指定的临时存档。</span><br>$ git stash drop stash@&#123;n&#125;<br><br><span class="hljs-comment"># 删除所有通过 stash 保存的临时存档。</span><br>$ git stash clear<br></code></pre></td></tr></table></figure>

<h3 id="2-3-解决多分支下的文件冲突-Merge"><a href="#2-3-解决多分支下的文件冲突-Merge" class="headerlink" title="2.3 解决多分支下的文件冲突 - Merge"></a>2.3 解决多分支下的文件冲突 - Merge</h3><p>通常，我们会将一些系统的新功能切到一个独立的 <code>feature</code> 分支进行开发，待功能完善后再将其迁移到主分支 <code>master</code> 中并上线 ( 不同公司对此都会有相应的约束和规范 ) 。这里需要引入另一个命令来实现分支的合并：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git merge &lt;other_bn&gt;<br></code></pre></td></tr></table></figure>

<p>切记，这条命令是将其它分支的内容合并到当前分支 ( 而不是反过来的 ) 。</p>
<p>合并操作难免会带来一些冲突情况，譬如两条分支可能都对一份文件进行了更改。如果这个更改属于 “追加” 性质，则 Git 会直接将新增内容补充到当前分支中，并要求操作者像 <code>commit</code>  命令一样补充此次 <code>merge</code> 操作的描述和原因。</p>
<p>不过，大部分情况下，代码冲突都不是简单地追加，这种情况下就需要人为地介入修改。当 Git 无法自动处理冲突时，它会给出类似的提示： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">Auto-merging xxxx<br><span class="hljs-keyword">CONFLICT</span> (content): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> xxxx<br>Automatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.<br></code></pre></td></tr></table></figure>

<p>另外，Git Bash 显示当前的分支从 <code>(xxx)</code> 变成了 <code>( xxx | MERGING )</code> ，这是 Git 在提醒我们人工处理代码冲突。在该模式下，我们无法通过 <code>push</code> 命令将本地分支提交到对应的远程分支，必须在人工解决冲突后使用 <code>commit</code> 命令重新提交一个 “进行了合并且解决冲突后的新版本”。此时，Git 会解除 <code>MERGING</code> 状态。</p>
<p>发生冲突的位置会被 Git 替换为以下格式的文本：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>modified by 1...<br>=======<br>modified by demo2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; github_origin/master<br></code></pre></td></tr></table></figure>

<p>这个文本表示：在当前版本中，该位置的文本是 <code>modified by 1...</code> ，而在另一个 <code>github_origin/master</code> 分支中，该处的文本是 <code>modified by demo2</code> 。对于大型项目而言，想要通过人工方式来检阅所有的代码冲突是一件不现实的事情，因此这里借助 <code>diff</code> 命令使 Git 显示所有发生冲突的位置。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git diff <br></code></pre></td></tr></table></figure>

<p>注：<code>merge</code> 也被视作是一次对本地分支的更新。此外，除了 <code>merge</code> 命令之外，其它 Git 命令：<code>cherry-pick</code>，<code>fetch</code>，<code>revert</code> 等都有可能引发代码冲突。</p>
<h2 id="3-在远程库中维护代码"><a href="#3-在远程库中维护代码" class="headerlink" title="3. 在远程库中维护代码"></a>3. 在远程库中维护代码</h2><p>远程库的选择有很多，除了 Github 之外，国内类似的代码托管网站还有码云。无特殊说明的情况下，后续的 “远程库” 说法均默认指代 Github 网站。</p>
<p>本地库的内容会同步到远程库 ( Remote Repository )， 以便于云端开发。<strong>一个本地库的代码可以提交到多个远程库</strong>。笔者在后文可能会出于省略的目的而使用 “提交到远程库”，”提交远程库的某分支” 之类的描述，实际上，这些说法是不确切的，严谨的说法是 “提交到某个远程库的某个分支”。我们在 Git 命令行中能看到如此的表示：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">origin/<span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure>

<p>它指代的是名为 <code>origin</code> 的远程库中的 <code>master</code> 分支。下图描述了远程库和本地库的映射关系：不仅仅是分支对应分支，每条分支内的每条提交记录也是相对应的。</p>
<p><img  src="https://i.im5i.com/2021/04/23/wWzUw.png"  ><span class="image-caption">远程库到本地库的映射关系</span></p>
<h3 id="3-1-将本地库关联到一个新的远程库-Remote"><a href="#3-1-将本地库关联到一个新的远程库-Remote" class="headerlink" title="3.1 将本地库关联到一个新的远程库 - Remote"></a>3.1 将本地库关联到一个新的远程库 - Remote</h3><p>首先，登录到 Github 网页 ( 需要先注册 Github 账号 )  并创建一个新的空仓库，各种选项和命名可根据自己的需要而定。</p>
<p>一个刚创建好的空仓库看起来是这样的：并且它目前没有关联任何分支，也没有任何提交记录。同时，它留下了两种形式的 <code>url</code> ，分别是 HTTPS 形式的链接和 SSH 形式的链接。</p>
<p><img  src="https://i.im5i.com/2021/04/23/wW0ZZ.png"  ><span class="image-caption">GitHub 提供了提示命令</span></p>
<p>下一步便是利用这个链接在本地库中关联远程库。<code>url</code> 原则上可以选择 HTTPS 和 SSH 的任意一种形式，这会影响到我们日后将以何种方式向远程库提交代码。如果对 SSH 方式暂时不了解，在这里可以先选择 HTTPS 形式的链接。同时为了日后能够引用这个远程库，还需要指定该远程库的命名 <code>rn</code> ( remote name，比如 <code>origin</code> )</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git remote add &lt;rn&gt; &lt;url&gt;<br></code></pre></td></tr></table></figure>

<p>以下命令能够检查本地库关联的所有远程库以及对应的 <code>url</code> ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git remote -v<br></code></pre></td></tr></table></figure>

<p>前文已经提到过，一个本地库可以对应多个远程库，而这些多个远程库的别名不允许重复。和关联相对应的，下方的命令用于删除远程库关联：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git remote rm &lt;rn&gt;<br></code></pre></td></tr></table></figure>

<h3 id="3-2-向远程库提交代码-Push"><a href="#3-2-向远程库提交代码-Push" class="headerlink" title="3.2 向远程库提交代码 - Push"></a>3.2 向远程库提交代码 - Push</h3><p>通过 <code>push</code> 命令，我们就可以将本地库的更新提交到远程库了，下面对一些参数和细节做说明：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git push &lt;rn&gt; &lt;lbn&gt;<br></code></pre></td></tr></table></figure>

<p><code>rn</code> 是已经关联的远程库名称，而 <code>lbn</code> ( local branch name ) 是指定提交本地库的分支名。前文已经提过，本地库和远程库是分支 “对应” 分支的关系，这条命令将本地分支的更新提交到了远程库的<strong>同名分支</strong>中 ( 如果在远程库中，这个分支原本不存在，则它就会被新创建出来 ) 。</p>
<p>远程库会将第一个提交的分支设置为默认分支。一个非空的远程库至少要存在一个默认分支，这个默认分支是不可删除的。不过，我们可以登录 Github 官网中主动选择默认分支，或者做出其它的设置。</p>
<p>只有远程库的管理者有权利直接使用 <code>push</code> 命令提交代码 ( 非管理者参考后文的 <code>fork</code> ) 。<code>push</code> 的方式取决于本地库用何种形式与远程库相关联：</p>
<p>第一种为 HTTPS 协议形式。这样每次 <code>push</code> 时，Git 都会要求我们提供 Github 的账号密码来通过身份验证。</p>
<p>第二种为 SSH 协议形式。只需在本地生成一对公私钥，然后在 Github 中将公钥注册，后续在本机的 <code>push</code> 将免去身份验证环节。SSH 的配置部分参考后文的补充部分。</p>
<p>如果想将对某远程库的关联切换为另一种协议，只需要借助下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git remote set-url &lt;rn&gt; &lt;url&gt;<br></code></pre></td></tr></table></figure>

<p>其中，<code>rn</code> 为指定的远程库名 ，<code>url</code> 则是项目对应的 HTTPS / SSH 链接 ( 比如：<code>git@github.com:me/Test.git </code>)</p>
<p>“用户账户”，”用户密码” 是指在各个远程库平台申请的账号，用于避免其他人向远程库恶意提交或覆盖上垃圾代码。Git 则是专注于 Control Version ( 或称 Ctrl + V ) 的工具，它有身份验证环节 ，但是本身并不提供账号密码。</p>
<p>当本地分支在上一次 <code>push</code> 之后进行了多次本地提交，那么下一次 <code>push</code> 时会将这些新的提交记录一并上传到远程分支上。</p>
<h3 id="3-3-在新环境中继续开发项目-Clone"><a href="#3-3-在新环境中继续开发项目-Clone" class="headerlink" title="3.3 在新环境中继续开发项目 - Clone"></a>3.3 在新环境中继续开发项目 - Clone</h3><p>当需要在另一台新机器中继续开发项目时，或者开发组的人员要维护一个远程库时，首先应使用 <code>clone</code> 命令，从远程库那里各自生成本地库及对应分支。克隆 —— 顾名思义，就是得到的本地库代码和远程库完全相同。<strong>这保证了我们无论在哪个开发环境，或者说对于一个开发组的任何人而言，下载，修改，并提交的都是同一处来源的代码。</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git <span class="hljs-built_in">clone</span> &lt;url&gt; <br></code></pre></td></tr></table></figure>

<p>默认的 <code>clone</code> 命令将从指定的 <code>url</code> ( HTTPS 或者 SSH 链接均可 ) 获取远程库的全部分支，<strong>但是 Git 只会主动创建一个与远程库默认分支相对应的本地分支</strong>。如果要在本地关联远程库的其它分支，可以通过下面的命令来完成：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># -a 参数将显示所有 ( 本地库 + 远程库 ) 的分支。</span><br>$ git branch -a<br><br><span class="hljs-comment"># e.g:</span><br><span class="hljs-comment"># git checkout -t origin/feature</span><br><span class="hljs-comment"># 这会在本地创建出一个 feature 分支，该分支和远程库的同名分支相对应。</span><br>$ git checkout -t &lt;rn&gt;/&lt;rbn&gt;<br></code></pre></td></tr></table></figure>

<p>在 Github 网页版中，可以查看到哪一个是默认分支。如果要克隆项目时直接指定远程库的分支，则需要添加 <code>-b</code> 参数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git <span class="hljs-built_in">clone</span> -b &lt;rbn&gt; &lt;url&gt;<br></code></pre></td></tr></table></figure>

<p>其中，<code>rbn</code> ( remote branch name ) 指远程库中对应的分支名称。</p>
<p>除此之外，<code>clone</code> 命令会另 Git 自动建立起本地库和远程库的关联，该远程库默认被命名为 <code>origin</code> 。</p>
<h3 id="3-4-保证项目进度的一致性-Fetch-Pull"><a href="#3-4-保证项目进度的一致性-Fetch-Pull" class="headerlink" title="3.4 保证项目进度的一致性 - Fetch / Pull"></a>3.4 保证项目进度的一致性 - Fetch / Pull</h3><p>我们总是<strong>基于最新的项目进度进行开发</strong>，同样，我们也很清楚，并发 / 并行总是会引发一些同步上的问题。现在假设这样的生产环境：A 和 B 两个人同时维护同一个远程库分支。</p>
<p><img  src="https://i.im5i.com/2021/04/23/wWaFJ.png"  ><span class="image-caption">A 和 B 同时提交导致冲突</span></p>
<p>如果 A 在向远程库分支 <code>push</code> 之前，B 却早已更新了分支内的一些内容，则 A 目前的本地分支就不再是 “最新的” 了。显然，此时如果 A 的代码更新成功了，那么就会导致 B 的更新丢失。</p>
<p><img  src="https://i.im5i.com/2021/04/23/wW4y1.png"  ><span class="image-caption">B 在提交前获取 A 的更新</span></p>
<p>或者，A 自己在另一个工作环境中提交的工作，却没有在当前的工作环境中及时更新，这也会引发类似的问题。在上述情况下，Git 会拒绝 <code>push</code> ：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">error: failed <span class="hljs-built_in">to</span> push some refs <span class="hljs-built_in">to</span> <span class="hljs-string">&#x27;git@github.com:XXX/xxx.git&#x27;</span><br>hint: Updates were rejected because <span class="hljs-keyword">the</span> remote <span class="hljs-keyword">contains</span> work that you <span class="hljs-built_in">do</span><br>hint: <span class="hljs-keyword">not</span> have locally. This is usually caused <span class="hljs-keyword">by</span> another repository pushing<br>hint: <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> same ref. You may want <span class="hljs-built_in">to</span> <span class="hljs-keyword">first</span> integrate <span class="hljs-keyword">the</span> remote changes<br>hint: (e.g., <span class="hljs-string">&#x27;git pull ...&#x27;</span>) <span class="hljs-keyword">before</span> pushing again.<br>hint: See <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure>

<p>解决方案便是通过 <code>fetch/pull</code> 命令率先更新自己的本地分支。</p>
<p><code>fetch</code> 命令会使 Git 先从远程库中下载更新内容，并与本地库中的代码进行 <code>merge</code> 操作。在提交代码前，A 可以通过 <code>git diff</code> 查看到远程库的最新版本中做出了哪些修改，A 需要考虑该作何修改。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git fetch &lt;rn&gt; &lt;rbn&gt;<br></code></pre></td></tr></table></figure>

<p><code>fetch</code> 命令需要提供远程库名 <code>rn</code>，以及对应的分支名称 <code>rbn</code> 。如果 A 和 B 之间维护的代码存在少许耦合，交叉的情况，A 需要根据 B 的代码来做相应维护，在这种情况下，推荐使用 <code>fetch</code> 命令。</p>
<p><code>pull</code> 命令会使 Git 在下载更新内容后直接覆盖掉本地库中的代码。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git pull &lt;rn&gt; &lt;rbn&gt;<br></code></pre></td></tr></table></figure>

<p>如果 A 和 B 两者维护的代码内容完全独立，A 完全不需要关注 B 做出了哪些改动，这种情况下，推荐使用 <code>pull</code> 命令。</p>
<p>最极端的方式，就是在 <code>push</code> 命令后加 <code>-f</code> 参数进行强制提交。除非遇到了特殊情况，比如后文会用到该参数对远程库的分支进行<strong>强制回滚</strong>，否则不会用到这个参数。在远程库中，可以通过设置保证在正常情况下远程库自动拒绝强制提交，以免发生工作内容覆盖，丢失等问题。</p>
<h3 id="3-5-远程库的跨团队协作-Fork"><a href="#3-5-远程库的跨团队协作-Fork" class="headerlink" title="3.5 远程库的跨团队协作 - Fork"></a>3.5 远程库的跨团队协作 - Fork</h3><p>首先，<code>fork</code> 是<strong>远程库行为</strong>，而非 Git 的命令。</p>
<p>在介绍 <code>fork</code> 之前，首先说说 Git 提供的 <code>clone</code> 命令。对于 <code>clone</code> 得到的本地分支，虽然可以在本地库进行自定义更新，但由于我们不是该远程库的管理者，所以无法在 <code>push</code> 时提供 HTTPS / SSH 验证信息，自然就无法向远程库提交对该项目的后续更新。这个道理很好理解，我们没有权限向不属于自己的远程库中提交代码。</p>
<p>或许，我们在 “用轮子” 的过程中有了一个不错的改进灵感，并希望原远程库的管理者充分考虑这些意见。登录到 Github 官网，通过 <code>fork</code> 按钮复制这份远程库到自己名下。显然，对于复制来的远程库，我们可以下载到本地库中自行维护，并有充分的权利通过 <code>push</code> 进行维护。整个逻辑类似于：</p>
<p><img  src="https://i.im5i.com/2021/04/23/wWpRn.png"  ><span class="image-caption">PR 过程</span></p>
<p>当时机成熟时，便可以向原远程库的管理者发起一个 <code>pull request</code> 请求，管理者将会对比这两个远程库的差异，并决定是否采纳这些更新。</p>
<h2 id="4-git-log-与-cherry-Pick"><a href="#4-git-log-与-cherry-Pick" class="headerlink" title="4. git log 与 cherry-Pick"></a>4. git log 与 cherry-Pick</h2><p>随着项目开发的进行，每条分支都会延展成一条长长的时间线：每一个关键的 “时间节点” 都代表了一次 <code>commit </code> 更新记录 ( 而 <code>commit</code> 的原因可能是多种，也许是正常提交，也许是为了解决 <code>merge</code> ，<code>revert</code> 过程的冲突代码 ) 。</p>
<p>Git 是基于增量更新的。这意味着，分支每一次更改都会添加一点 “新玩意” ( 它可能代表着一个系统的新功能，由多个额外的文件组成，我们暂且将它比喻为 ”cherry“ ) 。偶尔，我们想在另一个分支的时间线中，挑选一些其它分支的 “Cheeries” 并融入进来，这就是一个 <strong>cherry-Pick</strong> 的过程。</p>
<p>为了查看这些 “Cherries” ，首先需要了解如何查看每条分支的提交历史：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git <span class="hljs-built_in">log</span> &lt;bn&gt;			<span class="hljs-comment"># 打印完整的，指定分支的提交历史</span><br>$ git <span class="hljs-built_in">log</span>					<span class="hljs-comment"># 打印当前分支的提交历史	</span><br>$ git <span class="hljs-built_in">log</span> &lt;bn&gt; --oneline	 <span class="hljs-comment"># 打印简略的提交历史</span><br></code></pre></td></tr></table></figure>

<p>笔者截取了其中两条来展示 <code>git log</code> 的完整格式：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 普通的 commit 记录</span><br><span class="hljs-attribute">commit</span> <span class="hljs-number">5</span>c<span class="hljs-number">1</span>d<span class="hljs-number">691</span>c<span class="hljs-number">476632</span>e<span class="hljs-number">916</span>f<span class="hljs-number">8190391</span>f<span class="hljs-number">345</span>d<span class="hljs-number">2203</span>a<span class="hljs-number">8770</span><br><span class="hljs-attribute">Author</span>: xxxx &lt;you@example.com&gt;<br><span class="hljs-attribute">Date</span>:   Wed Dec <span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">48</span>:<span class="hljs-number">23</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">your</span> description<br><br><span class="hljs-comment"># git merge 会记录合并的两个 commit hash.</span><br><span class="hljs-attribute">commit</span> a<span class="hljs-number">01</span>db<span class="hljs-number">86557</span>eaf<span class="hljs-number">443277</span>ac<span class="hljs-number">641840</span>af<span class="hljs-number">3</span>fd<span class="hljs-number">81</span>fcabad<br><span class="hljs-attribute">Merge</span>: ea<span class="hljs-number">0180</span>f b<span class="hljs-number">3</span>bb<span class="hljs-number">2</span>f<span class="hljs-number">2</span><br><span class="hljs-attribute">Author</span>: xxxx &lt;you@example.com&gt;<br><span class="hljs-attribute">Date</span>:   Sun Dec <span class="hljs-number">20</span> <span class="hljs-number">16</span>:<span class="hljs-number">39</span>:<span class="hljs-number">49</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">Merge</span> branch &#x27;that_branch&#x27; into this_branch<br><br></code></pre></td></tr></table></figure>

<p>每一条记录都有此分支内唯一一个哈希值作为 id ( 使用时只复制前 6 位即可 )。除此之外，它还记录了该记录的提交者 ( 这依赖于本地的 Git 配置，和远程库的账号没有必然联系 )，提交的时间，以及提交者对此次操作的描述。 </p>
<p>不仅仅是 <code>cherry-pick</code> 依赖 <code>git log</code>，后续的回滚 ( Reset )，恢复 ( Revert ) 等操作同样需要它。尤其是当</p>
<p>现在，通过一个实例介绍如何使用 <code>cherry-pick </code> 命令。假设这样的场景：主分支 <code>master</code> 中经历了三次提交，每一次提交都假定只更新一个新功能 ( 这里以创建一个文本 <code>functionx</code> 来代替 )，而另一个 <code>dev</code> 则只去获取主分支 <code>master</code> 第一次，第三次提交时添加的新内容。</p>
<p>首先使用 <code>log</code> 命令打印出主分支 <code>master</code> 的相关提交记录 ( 或许现在我们能理解为什么 Git 要求每一次都要为 <code>merge</code> 和 <code>commit</code> 操作留下描述信息了 )：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 第一次只更新 (创建) 了新文件 function1</span><br><span class="hljs-attribute">commit</span> ef<span class="hljs-number">9</span>e<span class="hljs-number">7</span>c<span class="hljs-number">162</span>e<span class="hljs-number">51414986</span>ecd<span class="hljs-number">0352</span>ad<span class="hljs-number">23</span>b<span class="hljs-number">68</span>f<span class="hljs-number">69</span>b<span class="hljs-number">4956</span> (HEAD -&gt; master)<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">13</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">add</span> new function<span class="hljs-number">3</span><br><br><span class="hljs-comment"># 第二次只更新 (创建) 了新文件 function2</span><br><span class="hljs-attribute">commit</span> <span class="hljs-number">13</span>c<span class="hljs-number">07865</span>d<span class="hljs-number">974</span>ca<span class="hljs-number">8</span>c<span class="hljs-number">4</span>e<span class="hljs-number">83889</span>b<span class="hljs-number">2690</span>e<span class="hljs-number">0</span>d<span class="hljs-number">9</span>acccfc<span class="hljs-number">6</span>c<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">13</span>:<span class="hljs-number">28</span>:<span class="hljs-number">38</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">add</span> new function<span class="hljs-number">2</span><br><br><span class="hljs-comment"># 第三次只更新 (创建) 了新文件 function3</span><br><span class="hljs-attribute">commit</span> c<span class="hljs-number">5</span>ddee<span class="hljs-number">49</span>aabde<span class="hljs-number">4</span>d<span class="hljs-number">99</span>aa<span class="hljs-number">2</span>b<span class="hljs-number">5816</span>d<span class="hljs-number">9</span>bdb<span class="hljs-number">0</span>b<span class="hljs-number">551</span>eebb<span class="hljs-number">5</span><br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">13</span>:<span class="hljs-number">27</span>:<span class="hljs-number">44</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">add</span> new function<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure>

<p>切换到 <code>dev</code> 分支下，通过 <code>cherry-pick</code> 获取其中第一次和第三次更新的文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git checkout dev<br><span class="hljs-comment"># cherry-pick 命令后面可以跟上任意个更改的 Hash 值。</span><br>$ git cherry-pick ef9e7c1 c5ddee4<br>$ ls <span class="hljs-comment">#项目目录下新增了 function3 和 function1 ，但是没有 function2</span><br></code></pre></td></tr></table></figure>

<p><code>cherry-pick</code> 后面的参数除了更改记录的哈希值之外，还可以选择分支名。和 <code>merge</code> 命令不同的是，<strong>它只获取该分支的最后一次更改</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git cherry-pick &lt;bn&gt;<br></code></pre></td></tr></table></figure>

<p>回到案例中，如果 <code>dev</code> 刚才执行的是以下命令，它将只会获取到 <code>function3</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git checkout dev<br>$ git cherry-pick master<br>$ ls <span class="hljs-comment">#项目目录下只新增了 master 最后一次更新的 function3.</span><br></code></pre></td></tr></table></figure>

<p><code>cherry-pick</code> 可以获取 “从 A 之后到 B 的所有更新”，这要求 A 一定是发生在 B 前面的更改。下面演示了 <code>dev</code> 分支如何获取从 <code>function2</code> 到 <code>function3</code> 的更新：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># git cherry-pick &lt;A_hash&gt;..&lt;B_hash&gt;</span><br>$ git cherry_pick ef9e7c1..c5ddee4<br>$ ls <span class="hljs-comment"># 项目目录只新增了 master 的最后两次更新，因此显示 function2, function3.</span><br></code></pre></td></tr></table></figure>

<p>如果表述 “获取从 A 到 B 的所有更新”，则需要在 A 的后面标注一个 <code>^</code> 符号。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># git cherry-pick &lt;A_hash&gt;^..&lt;B_hash&gt;</span><br>$ git cherry-pick ef9e7c1^..c5ddee4<br>$ ls <span class="hljs-comment"># 项目目录新增了 master 的连续三次更新，因此显示了 function1, function2, function3.</span><br></code></pre></td></tr></table></figure>

<h3 id="4-1-Cherry-Pick-的冲突解决方式"><a href="#4-1-Cherry-Pick-的冲突解决方式" class="headerlink" title="4.1 Cherry-Pick 的冲突解决方式"></a>4.1 Cherry-Pick 的冲突解决方式</h3><p>接下来讨论 <code>cherry-pick</code> 发生冲突的情况。假设在 <code>dev</code> 已经具备 <code>function2</code> 相关内容的情形下，再去获取 <code>master</code> 分支的 <code>function1</code> ~ <code>function3</code> ，则 Git 会在执行到 <code>function2</code> 时暂停并提示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 第一个 function1 不存在冲突，更新成功<br>[dev <span class="hljs-number">60</span>c08d9] <span class="hljs-keyword">new</span> function1<br> <span class="hljs-type">Date</span>: Thu <span class="hljs-type">Dec</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span>:<span class="hljs-number">40</span>:<span class="hljs-number">39</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span><br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">0</span> insertions(<span class="hljs-operator">+</span>), <span class="hljs-number">0</span> deletions(<span class="hljs-operator">-</span>)<br> <span class="hljs-keyword">create</span> mode <span class="hljs-number">100644</span> function1<br> <br># 第一个 function2 存在冲突，更新失败。<br>error: could <span class="hljs-keyword">not</span> apply <span class="hljs-number">24</span>d27a5... <span class="hljs-keyword">new</span> function2<br>hint: after resolving the conflicts, mark the corrected paths<br>hint: <span class="hljs-keyword">with</span> <span class="hljs-string">&#x27;git add &lt;paths&gt;&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;git rm &lt;paths&gt;&#x27;</span><br>hint: <span class="hljs-keyword">and</span> <span class="hljs-keyword">commit</span> the <span class="hljs-keyword">result</span> <span class="hljs-keyword">with</span> <span class="hljs-string">&#x27;git commit&#x27;</span><br></code></pre></td></tr></table></figure>

<p><code>git status</code> 命令将显示如下的状态：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">On branch dev<br>You are currently cherry-picking commit <span class="hljs-number">24</span>d27a5.<br>  (<span class="hljs-keyword">fix</span> conflicts <span class="hljs-built_in">and</span> run <span class="hljs-string">&quot;git cherry-pick --continue&quot;</span>)<br>  (use <span class="hljs-string">&quot;git cherry-pick --abort&quot;</span> <span class="hljs-keyword">to</span> cancel the cherry-pick operation)<br><br>Unmerged path<span class="hljs-variable">s:</span><br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">mark</span> resolution)<br><br>        both added:      function2<br><br><span class="hljs-keyword">no</span> <span class="hljs-keyword">changes</span> added <span class="hljs-keyword">to</span> commit (use <span class="hljs-string">&quot;git add&quot;</span> <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>同时，Git Bash 的命令行显示目前的分支从 <code>(dev)</code> 变更为 <code>(dev|CHERRY-PACKING)</code> 。对于代码冲突问题，<code>cherry-pick</code> 提供了三种选择：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git cherry-pick --abort <span class="hljs-comment"># 回滚到执行 cherry-pick 之前的状态，即便之前有成功执行的更新，也会被撤销。</span><br>$ git cherry-pick --quit  <span class="hljs-comment"># 不再继续向后的 cherry-pick 操作，之前成功执行的更新会被保留。</span><br>$ git cherry-pick --<span class="hljs-built_in">continue</span> <span class="hljs-comment"># 继续执行未完成的 cherry-pick，这需要用户手动解决冲突问题。</span><br></code></pre></td></tr></table></figure>

<p>第一二种方式都比较好理解，我们在这里将尝试第三种解决方式。根据提示信息，Git 要求我们主动处理发生冲突的文件，并在修复后重新将它添加到暂存区中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 假定笔者处理了冲突部分</span><br>$ vim function2 <br><br><span class="hljs-comment"># 重新将文件添加到暂存区</span><br>$ git add function2<br><br><span class="hljs-comment"># 通知 Git 继续执行未完成的 cherry-pick, 从 function2 开始。</span><br>$ git cherry-pick --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure>

<p><code>cherry-pick</code> 将重新将 <code>function2</code> 记录到本地分支内，对此，我们还需要添加对此更改的描述信息。</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap"><span class="hljs-comment"># 第二个 function2 修复了冲突，更改提交信息后，显示更新成功。</span><br>[dev fb54d23] merge the function2<br> Date: Thu Dec<span class="hljs-number"> 17 </span>18:41:15<span class="hljs-number"> 2020 </span>+0800<br><span class="hljs-number"> 1 </span>file changed,<span class="hljs-number"> 1 </span>insertion(+)<br> <br><span class="hljs-comment"># 第三个 function3 不存在冲突，更新成功。 </span><br>[dev d798361] commit new function3<br> Date: Thu Dec<span class="hljs-number"> 17 </span>18:41:48<span class="hljs-number"> 2020 </span>+0800<br><span class="hljs-number"> 1 </span>file changed,<span class="hljs-number"> 0 </span>insertions(+),<span class="hljs-number"> 0 </span>deletions(-)<br> create mode<span class="hljs-number"> 100644 </span>function3<br></code></pre></td></tr></table></figure>

<p>Git 会执行完剩下的 <code>cherry-pick</code> 任务，最终 Git Bash 显示分支从原来的 <code>(dev|CHERRY-PICKING)</code> 状态变更回 <code>(dev)</code> 时表示 <code>cherry-pick</code> 已经完成。此时，<code>function1</code>，<code>function3</code> 及合并后的 <code>function2</code> 都被成功地添加到了 <code>dev</code> 分支内。</p>
<h3 id="4-2-Cherry-Pick-vs-Merge"><a href="#4-2-Cherry-Pick-vs-Merge" class="headerlink" title="4.2 Cherry -Pick vs Merge"></a>4.2 Cherry -Pick vs Merge</h3><p>和 <code>cherry-pick</code> 相比，<code>merge</code> 命令会试图将其中一条分支从创建到现在为止的所有更改全部合并到此分支。</p>
<p>而 <code>cherry-pick</code> 操作的粒度则更加细致：它能够摘取出其它分支的部分更新并合并到本分支内。</p>
<p>有关于 <code>cherry-pick</code> 命令，这里推荐 <a href="http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html">阮一峰的 cherry-Pick 章节</a>。</p>
<h2 id="5-回滚操作-Reset"><a href="#5-回滚操作-Reset" class="headerlink" title="5. 回滚操作 - Reset"></a>5. 回滚操作 - Reset</h2><p>回滚操作同样是版本控制的一个重要内容。Git 为此提供了两种命令：<code>reset</code> 和 <code>revert</code> ，在这里首先介绍前者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 回滚到指定位置</span><br>$ git reset &lt;op&gt; &lt;commit_Hash&gt;<br><br><span class="hljs-comment"># 回滚最后 n 次更新</span><br>$ git reset &lt;op&gt; HEAD~&lt;n&gt;<br></code></pre></td></tr></table></figure>

<p>其中，<code>op</code> 参数有三种选择：<code>--hard</code>，<code>--soft</code>，<code>--mixed</code>。注意，如果使用了 <code>reset</code> 命令，<strong>无论是何种方式的回滚，都会导致原提交记录被删除</strong>。下面通过一个例子来说明：假定在该分支中做了一次 “无用” 的提交，并且在该提交中，创建了一个名为 <code>useless</code> 的文件。</p>
<h3 id="5-1-回滚的三种形式"><a href="#5-1-回滚的三种形式" class="headerlink" title="5.1 回滚的三种形式"></a>5.1 回滚的三种形式</h3><p>第一种，<code>--hard</code> 是最彻底，最简单地回滚方式。该方式会使分支完全回退到某个过去的提交刚刚完成的状态。举例：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">commit</span> <span class="hljs-number">7929397</span>d<span class="hljs-number">75</span>dc<span class="hljs-number">81</span>b<span class="hljs-number">265</span>c<span class="hljs-number">9</span>a<span class="hljs-number">67016</span>c<span class="hljs-number">1</span>efd<span class="hljs-number">4</span>ec<span class="hljs-number">568</span>ac<span class="hljs-number">9</span> (HEAD -&gt; master)<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Fri Dec <span class="hljs-number">18</span> <span class="hljs-number">11</span>:<span class="hljs-number">53</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">useless</span> commit<br><br><span class="hljs-attribute">commit</span> a<span class="hljs-number">560</span>b<span class="hljs-number">0</span>e<span class="hljs-number">04</span>e<span class="hljs-number">86</span>bca<span class="hljs-number">1666</span>cd<span class="hljs-number">7</span>df<span class="hljs-number">1375</span>efb<span class="hljs-number">4</span>bb<span class="hljs-number">912</span>e<span class="hljs-number">6</span>d<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">19</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">lasted</span> commit<br><br></code></pre></td></tr></table></figure>

<p>如果使用以下命令之一，分支将回退到 <code>a560b0e</code> 号提交的状态。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git reset --hard a560b0<br>$ git reset --hard HEAD~1<br></code></pre></td></tr></table></figure>

<p>使用 <code>git status</code> 检查当前的状态，这个 <code>792939</code> 号更改就好像从来没发生过一样，并且曾经在 <code>792939</code> 号提交的 <code>useless</code> 文件也彻底消失了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">On</span> branch master<br><span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean<br></code></pre></td></tr></table></figure>

<p>第二种，<code>--mixed</code> 是相对 “温和” 的处理方式。该方式相当于将本次提交的文件 “打回”：<code>useless</code> 文件会从暂存区移除 ( 相当于这个文件还没有被 <code>add</code> 进来 ) ，但是仍然能够在工作区间内找到它。在执行完回滚命令后，使用 <code>git status</code> 将显示：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">On branch master<br>Untracked <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span><br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> include in what will <span class="hljs-keyword">be</span> committed)<br><br>        useless<br>        <br></code></pre></td></tr></table></figure>

<p>第三种，<code>--soft</code> 是 “更温和” 的处理方式。该方式相当于只将这个提交动作 “打回”：<code>useless</code> 文件将处于在暂存区等待提交的状态。在执行完回滚命令后，使用 <code>git status</code> 将显示：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">On</span> branch master<br>Changes <span class="hljs-keyword">to</span> be committed:<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> unstage)<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-keyword">file</span>:   useless<br><br></code></pre></td></tr></table></figure>

<h3 id="5-2-利用回滚简化提交记录"><a href="#5-2-利用回滚简化提交记录" class="headerlink" title="5.2 利用回滚简化提交记录"></a>5.2 利用回滚简化提交记录</h3><p><code>--soft</code> 模式还有一种用法，那就是将多个零碎的提交 ( 这些频繁的提交可能都是维护一个功能) 合并成一个单次提交，从而达到简化提交记录的效果。举例：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">commit</span> <span class="hljs-number">8</span>f<span class="hljs-number">1756</span>abfd<span class="hljs-number">6</span>b<span class="hljs-number">06</span>c<span class="hljs-number">67</span>af<span class="hljs-number">4</span>f<span class="hljs-number">9</span>acb<span class="hljs-number">8</span>c<span class="hljs-number">6</span>d<span class="hljs-number">8</span>b<span class="hljs-number">6</span>b<span class="hljs-number">892</span>e<span class="hljs-number">955</span> (HEAD -&gt; master)<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Fri Dec <span class="hljs-number">18</span> <span class="hljs-number">12</span>:<span class="hljs-number">49</span>:<span class="hljs-number">04</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">modified</span> controller for the function...<br><br><span class="hljs-attribute">commit</span> <span class="hljs-number">3518520</span>e<span class="hljs-number">0</span>cd<span class="hljs-number">7</span>e<span class="hljs-number">5</span>d<span class="hljs-number">33</span>ec<span class="hljs-number">432488929515</span>b<span class="hljs-number">08</span>b<span class="hljs-number">110</span>b<span class="hljs-number">5</span><br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Fri Dec <span class="hljs-number">18</span> <span class="hljs-number">12</span>:<span class="hljs-number">48</span>:<span class="hljs-number">11</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">create</span> repository for the function...<br><br><span class="hljs-attribute">commit</span> cdaa<span class="hljs-number">05</span>af<span class="hljs-number">52</span>f<span class="hljs-number">3</span>e<span class="hljs-number">160</span>be<span class="hljs-number">6818613</span>f<span class="hljs-number">0</span>f<span class="hljs-number">0</span>d<span class="hljs-number">9434474148</span><br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Fri Dec <span class="hljs-number">18</span> <span class="hljs-number">12</span>:<span class="hljs-number">46</span>:<span class="hljs-number">53</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">create</span> controller for the function...<br><br><span class="hljs-attribute">commit</span> a<span class="hljs-number">560</span>b<span class="hljs-number">0</span>e<span class="hljs-number">04</span>e<span class="hljs-number">86</span>bca<span class="hljs-number">1666</span>cd<span class="hljs-number">7</span>df<span class="hljs-number">1375</span>efb<span class="hljs-number">4</span>bb<span class="hljs-number">912</span>e<span class="hljs-number">6</span>d<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">19</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>	<span class="hljs-attribute">do</span> something ...<br></code></pre></td></tr></table></figure>

<p>首先通过 <code>git reset --soft</code> 将这三次提交期间改动的文件全部挪动到暂存区内 ( 以下两个命令取其一均可 )：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git reset --soft a560b0e04<br>$ git reset --soft HEAD~3<br></code></pre></td></tr></table></figure>

<p>使用 <code>git status</code> 显示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">On branch master<br>Changes <span class="hljs-keyword">to</span> be committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> unstage)<br><br>        <span class="hljs-keyword">new</span> file:   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Controller</span>.</span></span>java<br>        <span class="hljs-keyword">new</span> file:   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Repository</span>.</span></span>java<br><br></code></pre></td></tr></table></figure>

<p>这三次的更改对于 <code>a560b0e</code> 号提交而言都属于新增内容，因此它们都被认为是 “new file” 。检查无误后重新提交：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git commit -m <span class="hljs-string">&quot;Full function:xxx&quot;</span><br></code></pre></td></tr></table></figure>

<p>再次查看该分支的提交记录：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">commit</span> b<span class="hljs-number">3</span>bb<span class="hljs-number">2</span>f<span class="hljs-number">24636003069</span>e<span class="hljs-number">4486</span>f<span class="hljs-number">41</span>bc<span class="hljs-number">7</span>ecd<span class="hljs-number">48</span>c<span class="hljs-number">08</span>e<span class="hljs-number">1</span>f<span class="hljs-number">3</span> (HEAD -&gt; master)<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Fri Dec <span class="hljs-number">18</span> <span class="hljs-number">13</span>:<span class="hljs-number">02</span>:<span class="hljs-number">32</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">Full</span> function:xxx<br><br><span class="hljs-attribute">commit</span> a<span class="hljs-number">560</span>b<span class="hljs-number">0</span>e<span class="hljs-number">04</span>e<span class="hljs-number">86</span>bca<span class="hljs-number">1666</span>cd<span class="hljs-number">7</span>df<span class="hljs-number">1375</span>efb<span class="hljs-number">4</span>bb<span class="hljs-number">912</span>e<span class="hljs-number">6</span>d<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">19</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">do</span> something...<br><br></code></pre></td></tr></table></figure>

<p>该提交包含了原先三次提交的所有更新，并且使得该分支的提交记录变得更加清晰。</p>
<h3 id="5-3-回滚远程库分支"><a href="#5-3-回滚远程库分支" class="headerlink" title="5.3 回滚远程库分支"></a>5.3 回滚远程库分支</h3><p>Git 没有命令能够直接使远程库的分支回滚。想要实现这个目的，我们需要进行两步操作：首先，在本地库对此分支进行回滚，其次，将回滚后的本地分支通过 <code>push -f</code> 强制覆盖掉远程库的对应分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 确定要返回的状态</span><br>$ git <span class="hljs-built_in">log</span><br>$ git reset --hard &lt;commit_hash&gt;<br>$ git push -f &lt;rbn&gt; &lt;lbn&gt;<br></code></pre></td></tr></table></figure>

<h2 id="6-恢复操作-Revert"><a href="#6-恢复操作-Revert" class="headerlink" title="6. 恢复操作 - Revert"></a>6. 恢复操作 - Revert</h2><p>恢复操作的目的和回滚操作相同，都是为了撤销已提交的更改。然而，两者在实现方式上有所差异。直观的体现是回滚 ( Reset ) 会删除掉提交记录 ( 通过 <code>git log </code> 来查看 ) ，我们无法再去追溯原有的更改，而 <code>revert</code> 则依靠和原有提交做 “相反的熵减操作”，以此来实现等效于回滚的效果。</p>
<p>显然，这种方式不会删掉原有的提交记录，反而会新增用于抵消之前操作的另一条 <code>commit</code> 更新。和 <code>Reset</code> 相比，它的优势是能够通过提交记录再次追溯到原有的更改。语法形式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 恢复某一个 commit</span><br>$ git revert &lt;a_hash&gt;<br><br><span class="hljs-comment"># 下面的用法类似于 cherry-pick</span><br><span class="hljs-comment"># 恢复一系列 commit，不包括 &lt;a_hash&gt;</span><br>$ git revert -n &lt;a_hash&gt;..&lt;b_hash&gt;<br><br><span class="hljs-comment"># 恢复一系列 commit，包括 &lt;a_hash&gt;</span><br>$ git revert -n &lt;a_hash&gt;^..&lt;b_hash&gt;<br></code></pre></td></tr></table></figure>

<p>由于 <code>revert</code> 也被视作是一次更新，因此 Git 会要求补充对此次恢复操作的描述信息。此外，一条 <code>revert commit</code> 对应一条 <code>commit</code> ，如果一次性恢复了多条 <code>commit</code>，则在 <code>git log</code> 上也会增加对应数目的 <code>revert commit</code> 。</p>
<h3 id="6-1-Revert-中的祖父悖论-？"><a href="#6-1-Revert-中的祖父悖论-？" class="headerlink" title="6.1 Revert 中的祖父悖论 ？"></a>6.1 Revert 中的祖父悖论 ？</h3><p><img  src="https://i.im5i.com/2021/04/23/wW7pl.gif"  ><span class="image-caption">Git Reset 逻辑</span></p>
<p>相比于 <code>reset</code> 将 “整个时间线” 回退，<code>revert</code> 更像是回到某个时间点 ( 一次 <code>commit</code> ) 修改历史。</p>
<p><img  src="https://i.im5i.com/2021/04/23/wWOK7.gif"  ><span class="image-caption">Git Revert 逻辑</span></p>
<p>比如我们曾经在过去的提交 <code>A</code> 中创建了一个名为 <code>future</code> 的文件，而后续的提交 <code>B</code> ，<code>C</code> 都对 <code>future</code> 文件进行了修改。现在如果恢复了提交 <code>A</code> ( 意味着 <code>future</code> 文件将消失 )，那么在 <code>B</code>，<code>C</code> 提交对 <code>future</code> 文件的修改势必受到牵连 —— Git Bash 显示分支状态从 <code>(xxx)</code> 变更为了 <code>(xxx|REVERTING)</code> 。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 123bfbd (HEAD -&gt; opps) add 2 in file &#x27;future&#x27;</span><br><span class="hljs-comment"># f56f502 add 1 in file &#x27;future&#x27;</span><br><span class="hljs-comment"># 4a0ce50 create a file &#x27;future&#x27;			</span><br><br>$ git revert 4a0ce50<br><span class="hljs-comment"># error: could not revert 4a0ce50... create a file &#x27;future&#x27;</span><br><span class="hljs-comment"># hint: after resolving the conflicts, mark the corrected paths</span><br><span class="hljs-comment"># hint: with &#x27;git add &lt;paths&gt;&#x27; or &#x27;git rm &lt;paths&gt;&#x27;</span><br><span class="hljs-comment"># hint: and commit the result with &#x27;git commit&#x27;</span><br></code></pre></td></tr></table></figure>

<p>好在，我们有充分的自主权决定这个文件将何去何从：当 <code>git revert</code> 遇到代码冲突时，要么 <code>rm</code> 删掉这个 “扰乱时间线” 的文件，要么修正之后通过 <code>add </code> 命令将它重新放入暂存区 ( 根据实际需求而定，比如本案例中选择将 <code>future</code> 从暂存区直接删除 )，然后通过 <code>--continue</code> 参数示意 Git 继续执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git revert --<span class="hljs-built_in">continue</span><br><span class="hljs-comment"># 和 cherry-pick 类似，revert 有另外的两个选择：</span><br><span class="hljs-comment"># git revert --abort </span><br><span class="hljs-comment"># gti revert --quit</span><br></code></pre></td></tr></table></figure>

<h2 id="7-Git-杀手锏-Rebase"><a href="#7-Git-杀手锏-Rebase" class="headerlink" title="7. Git 杀手锏 - Rebase"></a>7. Git 杀手锏 - Rebase</h2><p>本段对 Rebase 的描述主要来源于此篇博客：<a href="https://www.jianshu.com/p/4a8f4af4e803">【Git】rebase 用法小结 - 简书 (jianshu.com)</a></p>
<p>Rebase 是一条强大的命令 —— 你可以通过在交互界面编写逻辑，以此任意地修改分支在某段区间内的提交记录，甚至将这段提交记录移植给其它分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 修改从 &lt;startPoint&gt; 之后到现在的提交记录。</span><br>$ git rebase -i &lt;startPoint&gt;[^]<br><br><span class="hljs-comment"># 修改从 &lt;startPoint&gt; 之后到 &lt;endPoint&gt; 的提交记录。</span><br>$ git rebase -i &lt;startPoint&gt;[^] &lt;endPoint&gt;<br><br><span class="hljs-comment"># 修改最近的 n 个提交记录。</span><br>$ git rebase HEAD~&lt;n&gt;<br><br><span class="hljs-comment"># 将修改好的提交记录移植到其它分支中 ( cherry-pick )</span><br>$ git rebase  &lt;startPoint&gt;[^] &lt;endPoint&gt; --onto &lt;other_bn&gt;<br></code></pre></td></tr></table></figure>

<p>如果要包含这个 <code>startPoint</code> ，仍然可以通过 <code>^</code> 符号来实现。在执行完这个命令后，我们首先会进入到 <code>vim</code> 编辑器内 ( 笔者对做了一些翻译处理 )：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># rebase 命令选中的记录区间会按从前到后的顺序逐行打印。</span><br>pick e4f076c add 1 <span class="hljs-keyword">in</span> function4		<span class="hljs-comment"># 最早的提交记录 </span><br>pick 9ae7197 add 2 <span class="hljs-keyword">in</span> function4<br>pick dfd4ce7 add 3 <span class="hljs-keyword">in</span> function4<br>pick fbe2372 Full <span class="hljs-keyword">function</span>:xxx		<span class="hljs-comment"># 最近的提交记录 </span><br><br><span class="hljs-comment"># Rebase 7778996..fbe2372 onto 7778996 (4 commands)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Commands:</span><br><span class="hljs-comment"># p, pick = use commit</span><br><span class="hljs-comment"># 	-&gt; 选择这个提交</span><br><span class="hljs-comment"># r, reword = use commit, but edit the commit message</span><br><span class="hljs-comment"># 	-&gt; 选择这个提交，重新编辑提交信息</span><br><span class="hljs-comment"># e, edit = use commit, but stop for amending</span><br><span class="hljs-comment"># 	-&gt; 选择这个提交，并在执行此提交时停下来 ( 修改这个提交 )</span><br><span class="hljs-comment"># s, squash = use commit, but meld into previous commit</span><br><span class="hljs-comment"># 	-&gt; 选择这个提交，并和之前的提交合并。</span><br><span class="hljs-comment"># f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="hljs-comment"># 	-&gt; 选择这个提交，与之前合并提交的同时，忽略掉有关于此提交的描述。</span><br><span class="hljs-comment"># x, exec = run command (the rest of the line) using shell</span><br><span class="hljs-comment"># 	-&gt; 执行 shell </span><br><span class="hljs-comment"># d, drop = remove commit</span><br><span class="hljs-comment"># 	-&gt; 移除这个提交</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="hljs-comment"># 	这些提交历史自上而下地被执行，换句话说，你可以重新排序这些提交历史。</span><br><span class="hljs-comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="hljs-comment"># 	如果你删除了某一行，则相关的提交将会丢失。</span><br><span class="hljs-comment"># However, if you remove everything, the rebase will be aborted.</span><br><span class="hljs-comment"># 	然而，如果你删去了所有行，则这条 rebase 指令会被 aborted 。</span><br><span class="hljs-comment"># Note that empty commits are commented out</span><br><span class="hljs-comment"># 	空提交会被注释掉</span><br></code></pre></td></tr></table></figure>

<p>或许是它太过强力，以至于 Git 为 Rebase 制定了一条黄金准则：“No one shall rebase a shared branch” — Everyone about rebase 。简单来说，如果你的此分支已经提交到了远程库，并且别人已经通过 <code>pull</code> 获取了它，那么就不要再使用 <code>rebase</code> 命令了。</p>
<p>下面我们将基于这段提交历史实现几个案例，<code>function4</code> 是一个普通的文本文件，<code>add x in funtion4</code> 表示 “本次提交在该文件内追加了 x” 。为了方便复用，请提前通过 <code>branch / checkout</code> 创建该分支的副本。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">commit</span> dfd<span class="hljs-number">4</span>ce<span class="hljs-number">7</span>d<span class="hljs-number">115102917740</span>a<span class="hljs-number">1572944</span>cba<span class="hljs-number">9</span>a<span class="hljs-number">7474</span>cff (HEAD -&gt; feature)<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">19</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">add</span> <span class="hljs-number">3</span> in function<span class="hljs-number">4</span><br><br><span class="hljs-attribute">commit</span> <span class="hljs-number">9</span>ae<span class="hljs-number">7197</span>b<span class="hljs-number">3086225</span>eec<span class="hljs-number">48</span>ae<span class="hljs-number">376</span>e<span class="hljs-number">139</span>e<span class="hljs-number">02</span>e<span class="hljs-number">0</span>f<span class="hljs-number">77</span>b<span class="hljs-number">25</span><br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">19</span>:<span class="hljs-number">03</span>:<span class="hljs-number">03</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">add</span> <span class="hljs-number">2</span> in function<span class="hljs-number">4</span><br><br><span class="hljs-attribute">commit</span> e<span class="hljs-number">4</span>f<span class="hljs-number">076</span>c<span class="hljs-number">66</span>cbc<span class="hljs-number">7848</span>f<span class="hljs-number">5</span>aad<span class="hljs-number">1</span>bc<span class="hljs-number">9</span>f<span class="hljs-number">0</span>e<span class="hljs-number">9</span>cf<span class="hljs-number">87</span>b<span class="hljs-number">695474</span><br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">19</span>:<span class="hljs-number">02</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">add</span> <span class="hljs-number">1</span> in function<span class="hljs-number">4</span><br>    <br><span class="hljs-attribute">commit</span> <span class="hljs-number">7778996155</span>d<span class="hljs-number">5</span>f<span class="hljs-number">630</span>adf<span class="hljs-number">5</span>ad<span class="hljs-number">88595</span>fe<span class="hljs-number">10</span>fb<span class="hljs-number">711</span>ab<span class="hljs-number">36</span> <br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">18</span>:<span class="hljs-number">41</span>:<span class="hljs-number">48</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">earlier</span> commit...<br><br></code></pre></td></tr></table></figure>

<h3 id="7-1-移除提交记录"><a href="#7-1-移除提交记录" class="headerlink" title="7.1 移除提交记录"></a>7.1 移除提交记录</h3><p>前文我们已经介绍如何利用 <code>reset --hard</code> 达到同样的目的 ( 甚至该方式更简单 )，在这里出于练习目的，使用 <code>rebase</code> 来完成。首先通过 <code>git rebase -i HEAD~3</code> 进入交互式编辑页面，将原先的 <code>pick</code> 修改为 <code>drop</code>：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">drop</span> e<span class="hljs-number">4</span>f<span class="hljs-number">076</span>c add <span class="hljs-number">1</span> in function<span class="hljs-number">4</span><br><span class="hljs-attribute">drop</span> <span class="hljs-number">9</span>ae<span class="hljs-number">7197</span> add <span class="hljs-number">2</span> in function<span class="hljs-number">4</span><br><span class="hljs-attribute">drop</span> dfd<span class="hljs-number">4</span>ce<span class="hljs-number">7</span> add <span class="hljs-number">3</span> in function<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>保存并 <code>wq</code> 退出，等待执行完毕后通过 <code>git log --oneline</code> 观察结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">7778996 (HEAD -&gt; feature) earlier commit<br>...<br></code></pre></td></tr></table></figure>

<p>显然，最近的三次提交被删除了。</p>
<h3 id="7-2-简化提交记录"><a href="#7-2-简化提交记录" class="headerlink" title="7.2 简化提交记录"></a>7.2 简化提交记录</h3><p>前文我们已经介绍如何利用 <code>reset --soft</code> 达到同样的目的，在这里仍使用 <code>rebase</code> 来完成。首先通过 <code>git rebase -i HEAD~3</code> 进入交互式编辑页面：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pick</span> e<span class="hljs-number">4</span>f<span class="hljs-number">076</span>c add <span class="hljs-number">1</span> in function<span class="hljs-number">4</span><br><span class="hljs-attribute">squash</span> <span class="hljs-number">9</span>ae<span class="hljs-number">7197</span> add <span class="hljs-number">2</span> in function<span class="hljs-number">4</span><br><span class="hljs-attribute">squash</span> dfd<span class="hljs-number">4</span>ce<span class="hljs-number">7</span> add <span class="hljs-number">3</span> in function<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>这会进入另一个编辑界面，用于整合这三次提交的描述信息 ( 这三条描述最终会合并再一条提交内 )：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># This is a combination of 3 commits.</span><br><span class="hljs-comment"># This is the 1st commit message:</span><br><br><span class="hljs-attribute">add</span> <span class="hljs-number">1</span> in function<span class="hljs-number">4</span><br><br><span class="hljs-comment"># This is the commit message #2:</span><br><br><span class="hljs-attribute">add</span> <span class="hljs-number">2</span> in function<span class="hljs-number">4</span><br><br><span class="hljs-comment"># This is the commit message #3:</span><br><br><span class="hljs-attribute">add</span> <span class="hljs-number">3</span> in function<span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure>

<p>保存并 <code>wq</code> 退出，等待执行完毕后通过 <code>git log --oneline</code> 观察结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">commit</span> <span class="hljs-number">68</span>b<span class="hljs-number">21</span>c<span class="hljs-number">1</span>decb<span class="hljs-number">155</span>e<span class="hljs-number">4426</span>d<span class="hljs-number">17</span>fa<span class="hljs-number">6</span>b<span class="hljs-number">3742</span>eaa<span class="hljs-number">431</span>c<span class="hljs-number">32</span>d (HEAD -&gt; opps)<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">19</span>:<span class="hljs-number">02</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">add</span> <span class="hljs-number">1</span> in function<span class="hljs-number">4</span><br><br>    <span class="hljs-attribute">add</span> <span class="hljs-number">2</span> in function<span class="hljs-number">4</span><br><br>    <span class="hljs-attribute">add</span> <span class="hljs-number">3</span> in function<span class="hljs-number">4</span><br><br><span class="hljs-attribute">commit</span> <span class="hljs-number">7778996155</span>d<span class="hljs-number">5</span>f<span class="hljs-number">630</span>adf<span class="hljs-number">5</span>ad<span class="hljs-number">88595</span>fe<span class="hljs-number">10</span>fb<span class="hljs-number">711</span>ab<span class="hljs-number">36</span> <br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">18</span>:<span class="hljs-number">41</span>:<span class="hljs-number">48</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">earlier</span> commit...<br><br></code></pre></td></tr></table></figure>

<p>如果我们希望去掉后两次的描述信息，而直接在被合并的第一次提交的描述信息中做一些修改：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">e</span> e<span class="hljs-number">4</span>f<span class="hljs-number">076</span>c add <span class="hljs-number">1</span> in function<span class="hljs-number">4</span><br><span class="hljs-attribute">f</span> <span class="hljs-number">9</span>ae<span class="hljs-number">7197</span> add <span class="hljs-number">2</span> in function<span class="hljs-number">4</span><br><span class="hljs-attribute">f</span> dfd<span class="hljs-number">4</span>ce<span class="hljs-number">7</span> add <span class="hljs-number">3</span> in function<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>执行，Git 将显示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">Stopped <span class="hljs-keyword">at</span> e4f076c...  <span class="hljs-keyword">add</span> <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> function4<br>You can amend the <span class="hljs-keyword">commit</span> now, <span class="hljs-keyword">with</span><br><br>  git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span><br><br>Once you <span class="hljs-keyword">are</span> satisfied <span class="hljs-keyword">with</span> your changes, run<br><br>  git rebase <span class="hljs-comment">--continue</span><br><br></code></pre></td></tr></table></figure>

<p>同时，状态将从 <code>feature</code> 更变为 <code>(feature|REBASE-i 1/3)</code> ，它表示 <code>rebase</code> 操作中途暂停了 ( 和 <code>revert</code> ，<code>cherry-pick</code> 等执行逻辑类似 ) 。此时的 <code>git status</code> 将提示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">interactive rebase <span class="hljs-keyword">in</span> progress; onto <span class="hljs-number">7778996</span><br>Last command done (<span class="hljs-number">1</span> command done):<br>   edit e4f076c <span class="hljs-keyword">add</span> <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> function4<br>Next commands <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span> (<span class="hljs-number">2</span> remaining commands):<br>   fixup <span class="hljs-number">9</span>ae7197 <span class="hljs-keyword">add</span> <span class="hljs-number">2</span> <span class="hljs-keyword">in</span> function4<br>   fixup dfd4ce7 <span class="hljs-keyword">add</span> <span class="hljs-number">3</span> <span class="hljs-keyword">in</span> function4<br>  (use &quot;git rebase --edit-todo&quot; <span class="hljs-keyword">to</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">and</span> edit)<br>You are currently editing a <span class="hljs-keyword">commit</span> <span class="hljs-keyword">while</span> rebasing branch <span class="hljs-string">&#x27;feature&#x27;</span> <span class="hljs-keyword">on</span> <span class="hljs-string">&#x27;7778996&#x27;</span>.<br>  (use &quot;git commit --amend&quot; <span class="hljs-keyword">to</span> amend the <span class="hljs-keyword">current</span> <span class="hljs-keyword">commit</span>)<br>  (use &quot;git rebase --continue&quot; once you are satisfied <span class="hljs-keyword">with</span> your changes)<br></code></pre></td></tr></table></figure>

<p>在这里，我们仅仅为了修改 <code>e4f076c</code> 号提交的描述信息 ( 因此，在刚才的编辑中可以将 <code>e</code> 更改为 <code>r</code> )，因此直接 <code>commit</code> 并示意 Git 继续执行即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git commit --amend<br><span class="hljs-comment"># 更新自己的提交信息</span><br>$ git rebase --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure>

<h3 id="7-3-移植提交记录"><a href="#7-3-移植提交记录" class="headerlink" title="7.3 移植提交记录"></a>7.3 移植提交记录</h3><p>现在，我们将通过 <code>rebase</code> 命令在原 <code>feature</code> 分支上最新的三次提交记录 “转嫁” 给 <code>target</code> 分支。这从逻辑上来看，和在 <code>target</code> 分支上执行了 <code>git cherry-pick feature 4f076^..dfd4ce</code> 是等效的：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># git log feature</span><br><span class="hljs-attribute">commit</span> dfd<span class="hljs-number">4</span>ce<span class="hljs-number">7</span>d<span class="hljs-number">115102917740</span>a<span class="hljs-number">1572944</span>cba<span class="hljs-number">9</span>a<span class="hljs-number">7474</span>cff (HEAD -&gt; feature)<br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">19</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">add</span> <span class="hljs-number">3</span> in function<span class="hljs-number">4</span><br><br><span class="hljs-attribute">commit</span> <span class="hljs-number">9</span>ae<span class="hljs-number">7197</span>b<span class="hljs-number">3086225</span>eec<span class="hljs-number">48</span>ae<span class="hljs-number">376</span>e<span class="hljs-number">139</span>e<span class="hljs-number">02</span>e<span class="hljs-number">0</span>f<span class="hljs-number">77</span>b<span class="hljs-number">25</span><br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">19</span>:<span class="hljs-number">03</span>:<span class="hljs-number">03</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">add</span> <span class="hljs-number">2</span> in function<span class="hljs-number">4</span><br><br><span class="hljs-attribute">commit</span> e<span class="hljs-number">4</span>f<span class="hljs-number">076</span>c<span class="hljs-number">66</span>cbc<span class="hljs-number">7848</span>f<span class="hljs-number">5</span>aad<span class="hljs-number">1</span>bc<span class="hljs-number">9</span>f<span class="hljs-number">0</span>e<span class="hljs-number">9</span>cf<span class="hljs-number">87</span>b<span class="hljs-number">695474</span><br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">19</span>:<span class="hljs-number">02</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">add</span> <span class="hljs-number">1</span> in function<span class="hljs-number">4</span><br>    <br><span class="hljs-attribute">commit</span> <span class="hljs-number">7778996155</span>d<span class="hljs-number">5</span>f<span class="hljs-number">630</span>adf<span class="hljs-number">5</span>ad<span class="hljs-number">88595</span>fe<span class="hljs-number">10</span>fb<span class="hljs-number">711</span>ab<span class="hljs-number">36</span> <br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">18</span>:<span class="hljs-number">41</span>:<span class="hljs-number">48</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">earlier</span> commit...<br><span class="hljs-comment"># ---------------------------------------------------------------------------------------</span><br><span class="hljs-comment"># git log target</span><br><span class="hljs-attribute">commit</span> <span class="hljs-number">7778996155</span>d<span class="hljs-number">5</span>f<span class="hljs-number">630</span>adf<span class="hljs-number">5</span>ad<span class="hljs-number">88595</span>fe<span class="hljs-number">10</span>fb<span class="hljs-number">711</span>ab<span class="hljs-number">36</span> <br><span class="hljs-attribute">Author</span>: xx &lt;**@qq.com&gt;<br><span class="hljs-attribute">Date</span>:   Thu Dec <span class="hljs-number">17</span> <span class="hljs-number">18</span>:<span class="hljs-number">41</span>:<span class="hljs-number">48</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-attribute">earlier</span> commit...<br></code></pre></td></tr></table></figure>

<p>这一次的 <code>rebase</code> 命令要带上 <code>--onto</code> 参数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git rebase e4f076^ dfd4ce --onto target<br></code></pre></td></tr></table></figure>

<p>下一步，便是切换到 <code>target</code> 分支中获取这移植得来的三次提交：借助 <code>reset</code> 命令来将 <code>target</code> 提交记录的 “头指针” HEAD 移动到最新的 <code>dfd4ce</code> 提交上去：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ git checkout target<br><span class="hljs-comment"># 切换到 target 分支时， Git 会提示：</span><br><span class="hljs-comment"># Previous HEAD position was dfd4ce7 add 3 in function4</span><br><span class="hljs-comment"># 表示该分支有三个新增，但未关联起来的提交记录。</span><br>$ git reset --hard dfd4ce<br></code></pre></td></tr></table></figure>

<h2 id="8-附录：为远程库设置-SSH-Key"><a href="#8-附录：为远程库设置-SSH-Key" class="headerlink" title="8. 附录：为远程库设置 SSH Key"></a>8. 附录：为远程库设置 SSH Key</h2><p>这里选取 Github 作为远程库。首先使用这条命令来测试本机和 Github 仓库的 SSH 连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ ssh -T git@github.com<br></code></pre></td></tr></table></figure>

<p>本机在没有和 Github 建立 SSH 连接的条件下，会提示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>: Permission denied (publickey).<br></code></pre></td></tr></table></figure>

<p>使用以下命令创建一个 SSH 公钥，字符串任选 ( 网上经常说该参数为自己在某远程库的注册邮箱，其实两者并没有什么关系 )，没有特殊需求的情况下一路回车即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">ssh-keygen -t rsa -C <span class="hljs-string">&quot;anyString&quot;</span><br></code></pre></td></tr></table></figure>

<p>这会在你的用户目录下创建一个 <code>.ssh</code> 文件夹，其中 <code>id_rsa.pub</code> 存放的是命令行生成的公钥。将该文件的内容提取出来，登录到 Github 官网，在个人设置中将其添加即可。</p>
<p><img  src="C:\Users\liJunhu\Desktop\x学习笔记\images\github_ssh.png"  ><span class="image-caption">在 GitHub 配置 SSH</span></p>
<p>这一步隐含地将该 SSH 和你的远程库账号绑定了一起，因为只有你能够登录自己的账户并执行这一步操作。</p>
<h2 id="9-参考文章"><a href="#9-参考文章" class="headerlink" title="9. 参考文章"></a>9. 参考文章</h2><p><a href="https://segmentfault.com/a/1190000011168654">Git常规配置与用法_个人文章 - SegmentFault 思否</a></p>
<p><a href="https://blog.csdn.net/shf4715/article/details/46810575">为Github账户设置SSH key_孙海峰的博客-CSDN博客</a></p>
<p><a href="https://www.linuxidc.com/Linux/2012-04/58985.htm">Git错误non-fast-forward后的冲突解决_Linux教程_Linux公社-Linux系统门户网站 (linuxidc.com)</a></p>
<p><a href="https://www.jianshu.com/p/16adec527aed">git之stash - 简书 (jianshu.com)</a></p>
<p><a href="https://segmentfault.com/a/1190000005937408">Git Rebase原理以及黄金准则详解_某熊的全栈之路 - SegmentFault 思否</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/67966662">git rebase onto使用 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go: (五)Goroutine &amp; Channel</title>
    <url>/2021/03/31/Go-%E4%BA%94-Goroutine%E4%B8%8Echannel/</url>
    <content><![CDATA[<p>Go 提供 <code>goroutine</code> ( 函数体 ) 和 channel ( 通道 ) 来供程序员进行并发编程。在其它语言中很难通过开辟上千个线程来建立一个庞大的系统，但在 Go 语言中，我们可以轻松创建十万，百万乃至千万级别的 <code>goroutine</code> 去执行并发任务。Go 非常提倡基于 CSP ( Communicating Sequential Process，顺序通信模型 ) 理论实现并发 ( 见第八章 ) ，但也提供传统的锁模式实现多 <code>goroutine</code> 之间的数据共享 ( 见第九章 ) 。</p>
<h1 id="第八章-Goroutine-amp-通道"><a href="#第八章-Goroutine-amp-通道" class="headerlink" title="第八章 Goroutine  &amp; 通道"></a>第八章 Goroutine  &amp; 通道</h1><blockquote>
<p>Go 箴言 —— 不要通过共享内存来通信，通过通信来共享内存。</p>
</blockquote>
<h2 id="8-1-Goroutine-amp-go-关键字"><a href="#8-1-Goroutine-amp-go-关键字" class="headerlink" title="8.1 Goroutine &amp; go 关键字"></a>8.1 Goroutine &amp; go 关键字</h2><p>如果有两个函数调用互不依赖，则意味这两个调用可以 <strong>并发</strong> 进行。在这里，可以将 Go 语言的 Goroutine 视作是 mini 版 “线程” ( 但实际上，<code>goroutine</code> 和线程存在非常大的数量差别，详见第 9 章 ) 。</p>
<p>在程序启动时，会有一个 <code>goroutine</code> 运行 <code>main</code> 函数，它被称之为主 <code>goroutine</code> 。如果要另启一个新的 <code>goroutine</code>，这只需要在一系列函数调用之前加上一个 <code>go</code> 关键字。和 <code>defer</code> 一样，<code>go</code> 关键字后面必须跟上一个函数调用，不过你可以将一个 <code>func()&#123;...&#125;()</code> 视作是将要被执行的一段语句块。</p>
<p>在下面的例子中，主函数以低效率的方式计算斐波那契数列，而在另一个 <code>goroutine</code> 当中输出一些信息表示系统仍然在运行 ( 因此这两个工作是同时进行的 ) 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-comment">//return fib(x, 1, 1)</span><br>	<span class="hljs-keyword">return</span> slowFib(x)<br>&#125;<br><br><span class="hljs-comment">// 这种计算方式会传递计算结果，并且是尾递归，效率非常高。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n, left, right <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">switch</span> &#123;<br>	<span class="hljs-keyword">case</span> n == <span class="hljs-number">0</span>:<br>		<span class="hljs-keyword">return</span> left<br>	<span class="hljs-keyword">default</span>:<br>		<span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>, right, left+right)<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 这种计算方式做了大量重复计算，因此效率非常低。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slowFib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">switch</span> &#123;<br>	<span class="hljs-keyword">case</span> n &lt; <span class="hljs-number">2</span>:<br>		<span class="hljs-keyword">return</span> n<br>	<span class="hljs-keyword">default</span>:<br>		<span class="hljs-keyword">return</span> slowFib(n<span class="hljs-number">-1</span>) + slowFib(n<span class="hljs-number">-2</span>)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>	<span class="hljs-comment">// 相当于创建了一个 Thread, 然后直接 start().</span><br>	<span class="hljs-comment">// 这个 goroutine 独立于主 goroutine 运行。</span><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-keyword">for</span> &#123;<br>			fmt.Print(<span class="hljs-string">&quot;still running...\n&quot;</span>)<br>			time.Sleep(<span class="hljs-number">250</span> * time.Millisecond)<br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-comment">// 主 goroutine 会持续计算</span><br>	fmt.Print(fibonacci(<span class="hljs-number">46</span>))<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，一旦 <code>main</code> 函数执行完毕并返回，所有的 <code>goroutine</code> 都会被强制结束。所以在本文测试一些代码时，不要忘记使用 <code>time.Sleep(...)</code> 或者 <code>func&#123;&#125;</code> 将主 <code>goroutine</code> 挂起或另其空转。</p>
<h2 id="8-2-通道"><a href="#8-2-通道" class="headerlink" title="8.2 通道"></a>8.2 通道</h2><p>通道是连接 <code>goroutine</code> 之间的桥梁，每一个通道是一个具体类型的导管，称为通道的元素类型。通道的关键字是 <code>chan</code>，下面借助 <code>make</code> 函数创建了一个元素类型为 <code>int</code>  的 <code>chan</code> 。</p>
<p>和 <code>map</code> 散列表相同，<code>make</code> 函数返回的是某个 <code>chan</code> 引用本身。当它被复制或者被传入到某个函数时，调用者和被调用者实际上得到的都是同一个引用。通道的零值是 <code>nil</code>，且通道之间是可以比较的：这仅需要判断两个通道是不是指向同一个引用。</p>
<h3 id="8-2-1-建立双向通道"><a href="#8-2-1-建立双向通道" class="headerlink" title="8.2.1 建立双向通道"></a>8.2.1 建立双向通道</h3><p>通道的用途有两个：发送 ( Send ) 消息，或者接收 ( Receive ) 消息，这两个操作统称为 <strong>通信</strong>。Go 语言引入了 <code>&lt;-</code> 符号来形象地表述通信：<code>ch &lt;- x</code> 表示将值 <code>x</code> 发送到通道 <code>ch</code> ，这个表达式可理解成是一个调用；<code>&lt;-ch</code> 则表示从通道 <code>ch</code> 中接收消息，这个表达式的返回值是通道的元素类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-comment">// 在另一个 goroutine 中可以像该 int chan 发送指定类型的消息。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// do something....</span><br>	<span class="hljs-keyword">var</span> x = <span class="hljs-number">100</span><br>	<br>	<span class="hljs-comment">// 表示将变量 x 的值发送到 ch.</span><br>	ch &lt;- x<br><br>&#125;()<br><br><span class="hljs-comment">// 在另一个 goroutine 中可以接收 int chan 接收指定类型的消息。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 表示将 ch 通道的取值赋值给 y.</span><br>    <span class="hljs-keyword">var</span> y = &lt;- ch<br>    fmt.Print(y)<br>&#125;()<br><br><span class="hljs-comment">// 这个 goroutine 没有消息可以接收。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 该 goroutine 运行到这里之后会陷入阻塞。</span><br>    <span class="hljs-keyword">var</span> y = &lt;- ch<br>    <br>    <span class="hljs-comment">// 这条 string 永远不会被打印在控制台。</span><br>	fmt.Printf(<span class="hljs-string">&quot;get a new message! %v&quot;</span>,y)<br>&#125;()<br><br><span class="hljs-comment">// 注意，主 goroutine 一旦退出，所有任务都会结束，因此这里要尝试阻塞它。</span><br>fmt.Print(fibonacci(<span class="hljs-number">46</span>))<br></code></pre></td></tr></table></figure>

<p>注意，调用 <code>&lt;-ch</code> 即<strong>意味着消费数据 ( 不管有没有使用它 )</strong> ，且每条消息只能被 <strong>消费一次</strong> 。在这个例子中，第一个 <code>goroutine</code> ( 称它是 “生产者” <code>goroutine</code> ) 发送的 <code>100</code> 已经被另一个 “消费者”  <code>goroutine</code> 接收。此时如果又有一个 “消费者” <code>goroutine</code> 调用了 <code> &lt;- ch</code> ，那么它将<strong>陷入阻塞状态</strong>，直到有其它的 <code>goroutine</code> 向这个 <code>ch</code> 发送了新的消息之后，才会执行读取语句。</p>
<p>顺带一提，可以从通道中只取值而不处理，<strong>只是这一条消息会被丢弃</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 从通道中取值，但是不做处理。</span><br>    &lt;- ch<br>	<span class="hljs-comment">// ...</span><br>&#125;()<br></code></pre></td></tr></table></figure>

<p>同样，如果 “生产者” <code>goroutine</code> 向 <code>ch</code> 通道发送消息却没有 “消费者” 处理，则<strong>它就不会发送这条消息</strong> ( 这很重要，见后文的缓冲通道 )。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 这条消息 &quot;无人处理&quot;</span><br>    ch &lt;- <span class="hljs-number">100</span><br><br>    <span class="hljs-comment">// 导致这条消息被阻塞。</span><br>    ch &lt;- <span class="hljs-number">101</span><br>    fmt.Print(<span class="hljs-string">&quot;程序不会执行到这里。&quot;</span>)<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>目前创建的通道没有缓冲空间，<code>ch</code> 只支持 “现发现取”，所以导致任何一方想要发送 / 接收消息时，需要保证旧的消息<strong>已经</strong>被取走 / 新的消息<strong>已经</strong>到达，如果不满足条件，则会陷入阻塞状态。因此，没有缓冲空间的通道又被称之为 <strong>同步通道</strong> 。</p>
<p>两个 <code>goroutine</code> X，Y 如果使用同步通道收发消息，通常意味着 X，Y 的执行存在着严格的前后顺序。比如 Y 必须等到 X 输入变量之后才可以继续运行，或者说 X 必须先于 Y 处理好某个变量并传递。另一种情况是，它们正以<strong>串行受限</strong>地方式交互某个受 “同步锁” 保护的共享变量。</p>
<p>如果 X，Y 没有 ( 或无法描述 ) 执行的先后顺序，那么 X 和 Y 就是<strong>并发</strong>的。我们也会将通信中的每一条消息称作是事件 ( events ) 。当然，通信可以不携带其它信息，仅使用通信动作本身来代表一个任务的完成。</p>
<h3 id="8-2-2-管道"><a href="#8-2-2-管道" class="headerlink" title="8.2.2 管道"></a>8.2.2 管道</h3><p><code>goroutine</code> 之间可以通过 <code>chan</code> 串联起来，从而形成连贯的流水线。这个流水线也可以被称之为 “管道” ( Pipeline ) 。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">from := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>to := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br><span class="hljs-comment">// 将这个 goroutine 命名为 producer.</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        from &lt;- i<br>        log.Printf(<span class="hljs-string">&quot;sent message &#123;%d&#125; to channel [from].&quot;</span>, i)<br>    &#125;<br>&#125;()<br><br><span class="hljs-comment">// 将这个 goroutine 命名为 consumer.</span><br><span class="hljs-comment">// 它将 from 接收的值 x2 之后输入到 to 通道中。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        i := &lt;-from * <span class="hljs-number">2</span><br>        to &lt;- i<br>        log.Printf(<span class="hljs-string">&quot;convert message to &#123;%d&#125; and send to channel [to]&quot;</span>, i)<br><br>    &#125;<br>&#125;()<br><br><span class="hljs-comment">// 将这个 goroutine 命名为 printer.</span><br><span class="hljs-comment">// 它输出 to 通道的消息。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        log.Printf(<span class="hljs-string">&quot;message from channel [to]:&#123;%d&#125;&quot;</span>, &lt;-to)<br>    &#125;<br>&#125;()<br><br><span class="hljs-comment">// 阻塞主 goroutine</span><br>time.Sleep(<span class="hljs-number">500</span> * time.Second)<br></code></pre></td></tr></table></figure>

<p>三个 <code>goroutine</code> 之间有两个通道 <code>from</code> 和 <code>to</code> ( 这个命名是以 consumer 的角度出发的 ) 。程序整体运行起来没有什么问题，只不过我们希望做进一步完善：比如：consumer 不应该向 <code>from</code> 通道 “回送” 消息，也不应该向 <code>to</code> 通道 “撤回” 消息。</p>
<h3 id="8-2-3-通过形参列表约束单向通道"><a href="#8-2-3-通过形参列表约束单向通道" class="headerlink" title="8.2.3 通过形参列表约束单向通道"></a>8.2.3 通过形参列表约束单向通道</h3><p>限制通道的流向是<strong>在函数的形参列表</strong>上进行的。”只发” 和 “只取” 的通道在写法上存在差异：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// chan &lt;- int 表示这是一个只发通道，它对应了在双向通道中的发送动作。</span><br><span class="hljs-comment">// &lt;-chan int  表示这是一个只收通道，它对应了在双向通道中的接收动作。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pipeline</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span> &lt;- <span class="hljs-keyword">int</span>,in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>&#123;<br>	<span class="hljs-comment">// 如果在函数体内错误使用了单向通道，则会在编译期检查出来。</span><br>	out &lt;- <span class="hljs-number">100</span><br>	&lt;- in<br>	<br>	<span class="hljs-comment">// 错误的用法:</span><br>	&lt;- out<br>	in &lt;- <span class="hljs-number">100</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>双向通道 ( 比如 <code>chan int</code> ) 会通过隐式转换兼容 “只发” ( <code>chan &lt;- int</code> ) 或者 “只取” ( <code>&lt;-chan int</code>) 的通道类型。但反过来，单向通道不能再切换成双向通道。</p>
<h3 id="8-2-4-缓冲通道"><a href="#8-2-4-缓冲通道" class="headerlink" title="8.2.4 缓冲通道"></a>8.2.4 缓冲通道</h3><p>可以通过 <code>make</code> 函数主动设置通道的<strong>容量</strong>。当容量为 0 时，缓冲通道会退化为同步通道。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//  在 make 函数后面传入第二个参数表示创建带长度的缓冲通道。</span><br>bufChannel := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<p><strong>同步通道和长度为 1 的非缓冲通道之间是存在差别的</strong>。前文提到，对于同步通道而言，当 “生产者” 发现没有任何 “消费者” 能够接收这条消息时，”生产者” 就<strong>不会发送消息</strong> 并立刻阻塞。而对于长度为 1 的非缓冲通道而言，”生产者” 只有在<strong>准备发送第二条消息</strong>的时候才会开始检查：如果没有 “消费者” ，则等待并阻塞。</p>
<p>当生产者向通道发送消息时，通道的长度加一。同样的，当消费者从通道获取消息时，通道的长度减一。当通道的长度小于容量时，双方可以不受阻塞地收发消息。从逻辑来看，可以将双向通道看作是 FIFO 的队列。</p>
<p>现在，使用 <code>cap(bufChannel)</code> 可以查询缓冲通道的<strong>容量</strong>，使用 <code>len(bufChannel)</code> 可以查询某个缓冲通道在某一刻的<strong>长度</strong>。不过，如果一个程序是持续运行的，且处理消息的速度非常迅速，那么长度通常都是浮动的 —— 大部分情况下仅捕获一次长度都没有太大意义，建议捕获多次长度，并通过统计的形式来判断缓冲通道的容量是否设置得合理。</p>
<p>下面的代码块演示了两个几乎是并发执行的两个 <code>goroutine</code>。由于这个程序是 “一次执行” 的，因此 consumer 在通过 <code>len</code> 察觉到通道内没有新消息之后会返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// producer</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>   ch &lt;- <span class="hljs-number">1</span><br>   ch &lt;- <span class="hljs-number">2</span><br>   ch &lt;- <span class="hljs-number">3</span><br>&#125;()<br><br><span class="hljs-comment">// consumer</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 不能让它在第一个 goroutine 之前运行，否则它会直接退出</span><br>   <span class="hljs-comment">// 因此在这里设置了少量延迟。</span><br>   time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)<br><br>   <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ch) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">break</span>&#125;<br>      fmt.Print(&lt;-ch,<span class="hljs-string">&quot;\n&quot;</span>)<br>   &#125;<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">20</span> * time.Second)<br></code></pre></td></tr></table></figure>

<h3 id="8-2-5-谨防-Goroutine-泄漏"><a href="#8-2-5-谨防-Goroutine-泄漏" class="headerlink" title="8.2.5 谨防 Goroutine 泄漏"></a>8.2.5 谨防 Goroutine 泄漏</h3><p>下面的代码创建三个 <code>goroutine</code> 同时向 Baidu，Github，Gitee 三个站点发出请求，但是该函数最终只会返回最先收到的响应。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cdn</span><span class="hljs-params">()</span> *<span class="hljs-title">http</span>.<span class="hljs-title">Response</span></span>&#123;<br><br>	resp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *http.Response)<br><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		get, err := http.Get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>		<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>			resp &lt;- get<br>			fmt.Printf(<span class="hljs-string">&quot;baidu 请求完毕&quot;</span>)<br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		get, err := http.Get(<span class="hljs-string">&quot;https://www.github.com&quot;</span>)<br>		<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>			resp &lt;- get<br>			fmt.Printf(<span class="hljs-string">&quot;github 请求完毕&quot;</span>)<br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		get, err := http.Get(<span class="hljs-string">&quot;https://www.gitee.com&quot;</span>)<br>		<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>			resp &lt;- get<br>			fmt.Printf(<span class="hljs-string">&quot;gitee 请求完毕&quot;</span>)<br>		&#125;<br>	&#125;()<br>    <br>	<span class="hljs-keyword">return</span> &lt;-resp<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从表面上看，调用这个函数不会出现任何问题。但是它的 Bug 是内在的：一旦有任意一个请求返回，意味着 <code>cdn()</code> 函数将立刻返回并退栈。这对那两个稍慢的 <code>goroutine</code> 而言，没有后续的其它 <code>goroutine</code> 接收它们的消息，因此它们会被一直阻塞到主程序退出。调用 <code>cdn()</code> 函数，可以观察到，直到主程序运行完毕，控制台只会打印一行 “XXX 请求完毕”。</p>
<p>这种现象称之为 <code>goroutine</code> 泄漏。这两个泄漏的 <code>goroutine</code> 不会被垃圾回收器回收。对于这个例子而言，有两种方法可以避免 <code>goroutine</code> 泄漏：</p>
<p>第一种思路：任何一方在抢先发送消息之后调用 <code>close(resp)</code> ( 见后文 ) 禁止其它方再次发送，这里依赖原生的同步通道确保同一时刻只有一条消息发送成功。后来的两个 <code>goroutine</code> 一旦尝试发送消息，则会陷入宕机而非阻塞 —— 这个宕机是预期的，这只需要在延迟调用中恢复状态，然后让它们 “若无其事” 地退出即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cdn</span><span class="hljs-params">()</span> *<span class="hljs-title">http</span>.<span class="hljs-title">Response</span></span>&#123;<br><br>   resp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *http.Response)<br><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>       <br>      <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         <span class="hljs-built_in">recover</span>()<br>         fmt.Printf(<span class="hljs-string">&quot;其它 goroutine 已经获得了响应，routine1 退出。&quot;</span>)<br>      &#125;()<br><br>      get, err := http.Get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>      <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>         resp &lt;- get<br>         fmt.Printf(<span class="hljs-string">&quot;baidu 请求完毕&quot;</span>)<br>         <span class="hljs-built_in">close</span>(resp)<br>      &#125;<br>   &#125;()<br><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>      <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         <span class="hljs-built_in">recover</span>()<br>         fmt.Printf(<span class="hljs-string">&quot;其它 goroutine 已经获得了响应，routine2 退出。&quot;</span>)<br>      &#125;()<br><br>      get, err := http.Get(<span class="hljs-string">&quot;https://www.github.com&quot;</span>)<br>      <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>         resp &lt;- get<br>         fmt.Printf(<span class="hljs-string">&quot;github 请求完毕&quot;</span>)<br>         <span class="hljs-built_in">close</span>(resp)<br>      &#125;<br>   &#125;()<br><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>      <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         <span class="hljs-built_in">recover</span>()<br>         fmt.Printf(<span class="hljs-string">&quot;其它 goroutine 已经获得了响应，routine3 退出。&quot;</span>)<br>      &#125;()<br><br>      get, err := http.Get(<span class="hljs-string">&quot;https://www.gitee.com&quot;</span>)<br>      <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>         resp &lt;- get<br>         fmt.Printf(<span class="hljs-string">&quot;gitee 请求完毕&quot;</span>)<br>         <span class="hljs-built_in">close</span>(resp)<br>      &#125;<br>   &#125;()<br><br>   <span class="hljs-keyword">return</span> &lt;-resp<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二种思路是：将 <code>resp</code> 设置为容量为 3 的缓冲通道，然后确保所有的 <code>goroutine</code> 都能运行完毕。这里还引入了 <code>sync.WaitGroup</code> ，它可被认为是一个 “多 <code>goroutine</code> 安全” 的信号量。在每个子调用的开头和结尾分别埋下 <code>Add(1)</code> 和 <code>Done()</code> ，表示进入 <code>goroutine</code> 时将信号量 + 1，然后在退出时将信号量 - 1。</p>
<p>对它们的父调用 <code>cdn()</code> 而言，如果信号量非 0 就意味着有些子调用没有完成。这时可以通过调用 <code>Wait()</code> 令父调用阻塞，直到后续的 <code>goroutine</code> 完成并最终将信号量重新置 0 为止。为了不耽误 <code>cdn()</code> 正常返回结果，在这里不妨将它交给另一个 <code>goroutine</code> 独立完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cdn2</span><span class="hljs-params">()</span> *<span class="hljs-title">http</span>.<span class="hljs-title">Response</span></span> &#123;<br><br>    resp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *http.Response,<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">var</span> mu sync.WaitGroup<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 进入 goroutine 时信号量 +1，退出 goroutine 时信号量 -1。</span><br>        mu.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">defer</span> mu.Done()<br><br>        get, err := http.Get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>            resp &lt;- get<br>            fmt.Printf(<span class="hljs-string">&quot;baidu 请求完毕&quot;</span>)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>        <span class="hljs-comment">// 进入 goroutine 时信号量 +1，退出 goroutine 时信号量 -1。</span><br>        mu.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">defer</span> mu.Done()<br><br>        get, err := http.Get(<span class="hljs-string">&quot;https://www.github.com&quot;</span>)<br>        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>            resp &lt;- get<br>            fmt.Printf(<span class="hljs-string">&quot;github 请求完毕&quot;</span>)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>        <span class="hljs-comment">// 进入 goroutine 时信号量 +1，退出 goroutine 时信号量 -1。</span><br>        mu.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">defer</span> mu.Done()<br><br>        get, err := http.Get(<span class="hljs-string">&quot;https://www.gitee.com&quot;</span>)<br>        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>            resp &lt;- get<br>            fmt.Printf(<span class="hljs-string">&quot;gitee 请求完毕&quot;</span>)<br>        &#125;<br>    &#125;()<br><br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 直接调用 mu.Wait() 会使函数等到所有的响应之后才返回，</span><br>        <span class="hljs-comment">// 对于该函数的预期功能而言，这没有必要。</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>            mu.Wait()<br>            fmt.Printf(<span class="hljs-string">&quot;剩下的请求也处理完毕。&quot;</span>)<br>            <span class="hljs-built_in">close</span>(resp)<br>        &#125;()<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> &lt;-resp<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-2-6-缓冲通道与同步通道的选择"><a href="#8-2-6-缓冲通道与同步通道的选择" class="headerlink" title="8.2.6 缓冲通道与同步通道的选择"></a>8.2.6 缓冲通道与同步通道的选择</h3><p>如何选择这两类通道，以及缓冲通道的长度都会对程序的性能造成影响。一句话概括就是：”缓冲通道” 不总是银弹。</p>
<p>同步通道提供了强制性的同步保障，在一次 “发送” 必须强制对应一次 “接收” 的场合会很有用，比如 HTTP/1.1 协议中的阻塞队列，浏览器必须要等待上一个请求拿到响应之后才会继续发送下一个请求。</p>
<p>而在 “流水线” 式的管道中，”发送” 和 “接收” 通常都是分离的，此时用缓冲通道则更加适合。假定 X 是 Y 的上游 worker，则 X 只管将处理好的数据存取到缓冲通道留给 Y 去处理，X 就可以继续处理它的上游 worker 发送给它的新数据了—— 这对于 Y 也一样。</p>
<p>并且，当 X 和 Y 的处理效率存在一定差异时，缓冲通道为慢的一方争取到了工作时间。比如 X 的生产速度更快，则较长的缓冲通道让 X 不至于因阻塞而 “无事可做”，流水线的所有结点都能保持 “持续工作” 的状态。</p>
<p>但如果 X 和 Y 的处理效率存在巨大差异，则缓冲通道在大部分时间要么占满 ( X 的效率 &gt;&gt; Y 的效率 )，要么全空 ( Y 的效率 &gt;&gt; X 的效率 )。此时节点之间就又退化到了同步阻塞的状态。此时的解决方法应当是通过创建更多的 workers 平衡工作上的效率差异，而不是一味地扩增缓冲通道的容量 ( 这只是延缓了阻塞的时机，不能解决根本问题 ) 。</p>
<h3 id="8-2-7-通道关闭"><a href="#8-2-7-通道关闭" class="headerlink" title="8.2.7 通道关闭"></a>8.2.7 通道关闭</h3><p>更加正式的做法是：当生产者认为已经没有新消息要发送之后，它会调用 <code>close(...)</code> 主动关闭通道的发送端 —— 这句话的意思是，通道虽然被标记为 <code>closed</code>，但它仍然是可用的 ( 考虑到还在忙碌的消费者 )，只不过后续再向该通道发送消息会引发<strong>宕机</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// producer</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    ch &lt;- <span class="hljs-number">1</span><br>    ch &lt;- <span class="hljs-number">2</span><br>    ch &lt;- <span class="hljs-number">3</span><br>    <span class="hljs-comment">// 关闭通道。</span><br>    <span class="hljs-built_in">close</span>(ch)<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>同散列表 <code>map</code> 类似，消费者在接收消息时可以获取两个值：第一个值是消息本身，第二个 <code>bool</code> 值代表：”这个通道还有待处理的消息，不管该通道有没有被真的关闭，<strong>它还有用</strong>“。如果它的值是 <code>false</code>，则表明 “继续从这个通道读取消息没有意义”，伴随的则是消息类型的零值。</p>
<p>对于消费者而言：<strong>一个被关闭的通道永远是可读的</strong>，它会不受阻塞地读取通道的剩余消息，或者是消息的零值和一个 <code>false</code> 。因此如果不加以控制，消费者将陷入死循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// consumer</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 不能让它在第一个 goroutine 之前运行，否则它会直接退出</span><br>    <span class="hljs-comment">// 因此在这里设置了少量延迟。</span><br>    time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 通过 hasMore 变量判断是否还有要处理的消息</span><br>        i,hasMore := &lt;-ch<br>        <span class="hljs-keyword">if</span> !hasMore &#123;<span class="hljs-keyword">break</span>&#125;<br>        fmt.Print(i,<span class="hljs-string">&quot;\n&quot;</span>)<br>    &#125;<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>只有消息的生产者 ( 或者称 “发送者” ) 应当掌握着关闭通道的权利 —— 在双向通道中，消费者如果 “任性地” 关闭了通道，那会极易导致生产者在发送新消息时意外宕机，而这样的高风险代码却不会在编译期间被检查出来。</p>
<p>在单向通道中，这个约束会更加严格：如果消费者尝试去关闭来自上游的 “只收” 通道，那么这个错误在编译期间就会检查出来。</p>
<h2 id="8-3-Select-多路复用"><a href="#8-3-Select-多路复用" class="headerlink" title="8.3 Select 多路复用"></a>8.3 Select 多路复用</h2><p>假定某一个 Job 有多个worker，不同的 worker 使用独立的通道向主 <code>goroutine</code> ( 或者其它某个 listener <code>goroutine</code> ) 进行消息交互。</p>
<p>遗憾的是，由于代码是顺序执行的，因此 listener 无论决定先专注于监听哪一个 worker ，都会导致其它的 worker 被阻塞。在下面的代码块中，由于 listener 首先阻塞式等待 <code>&lt;- ch1</code> 发送的消息 ( 有 5 秒的延迟 ) ，导致 worker2 的消息处理被推迟，这 5 秒钟的时间被 listener 浪费掉了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br><span class="hljs-comment">// worker1</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>    ch1 &lt;- <span class="hljs-number">1</span><br>&#125;()<br><br><span class="hljs-comment">// worker2</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    ch2 &lt;- <span class="hljs-number">1</span><br>&#125;()<br><br><span class="hljs-comment">//listener</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 阻塞式等待接收 worker1 发来的同步信号</span><br>    &lt;- ch1<br>    fmt.Print(<span class="hljs-string">&quot;worker1 has done.\n&quot;</span>)<br>    <span class="hljs-comment">// 在收到 ch1 的信后之后，再等待接收 worker2 发来的同步信号</span><br>    &lt;- ch2<br>    fmt.Print(<span class="hljs-string">&quot;worker2 has done.\n&quot;</span>)<br>&#125;()<br><br><span class="hljs-comment">// 阻塞主进程</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br></code></pre></td></tr></table></figure>

<p>如果期望 listener 是 “高响应” 的，直接的办法是创建和 workers 等数量的 listeners 。显然，这大概率会直接创建出一大批闲置并阻塞的 <code>goroutine</code>，也会造成资源的浪费。</p>
<p>一个改进方式是：不妨建立一个哨兵 selector，它专门以轮询的形式监听各个通道，当监听到某个通道有新消息之后再创建新的 <code>goroutine</code> 去处理即可。这样，只需要一个阻塞式的 selector 就能同时监听多个通道的消息，并且只会在所有通道都没有新消息的情况下进入阻塞。</p>
<p>这种思路称之为阻塞式<strong>多路复用</strong>，曾被用于各大 OS 内核的线程管理。在 Go 语言中，具体的实现是：使用 <code>select</code> ( 它的语法很像 <code>switch</code> ) 语句来注册多个通道，然后包裹一层 <code>for</code> 循环来实现持续轮询。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-comment">// 一次 select 只会执行一个语句。 </span><br>      <span class="hljs-keyword">select</span> &#123;<br>      <span class="hljs-keyword">case</span> &lt;-ch1: <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;worker1 has done.&quot;</span>)&#125;()<br>      <span class="hljs-keyword">case</span> &lt;-ch2: <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;worker2 has done.&quot;</span>)&#125;()<br>      &#125;<br>   &#125;<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>但偶尔，<code>select</code> 语句也会面临一些抉择，比如有多个通道都有新消息，这种情况在 “监听” 多个缓冲通道时比较常见。不过，一次 <code>select</code> 调用只会执行一条 <code>case</code>，并且执行哪一个将是<strong>随机</strong>的。 </p>
<h2 id="8-4-关闭-Goroutine"><a href="#8-4-关闭-Goroutine" class="headerlink" title="8.4 关闭 Goroutine"></a>8.4 关闭 Goroutine</h2><p>有时，我们需要让多个 <code>goroutine</code> 主动停止自己手头上的任务，比如说客户端在上传文件途中突然取消的情况。子 <code>goroutine</code> 不会自动地随着父 <code>goroutine</code> 的结束而结束 ( 因为这些 <code>goroutine</code> 都是相互平级且独立的。这里的 “父子” 只是代码的调用层级关系的形象描述 ) ，除非这个父 <code>goroutine</code> 是主 <code>goroutine</code>。</p>
<p>我们必须设置一个机制，使得父 <code>goroutine</code> 在认为没必要继续执行任务的时候通知它的子 <code>goroutine</code> 停止运行并退出。现在假定有两个子 <code>goroutine</code> 调用，它们各自以秒为单位向控制台输出奇数 / 偶数。现在的需求是：当在控制台按下任意键时，这两个 <code>goroutine</code> 退出，保持主函数仍然运行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// goroutine1 持续输出偶数</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;[goroutine1]:%v\n&quot;</span>,i)<br>            i = i+<span class="hljs-number">2</span><br>            time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// goroutine2 持续输出奇数</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;[goroutine2]:%v\n&quot;</span>,i)<br>            i = i+<span class="hljs-number">2</span><br>            time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;[main]:still running...\n&quot;</span>)<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或许可以建立一个足够长的缓冲通道，主 <code>goroutine</code> 发送 “足够多” 的信号量，令所有接收到信号量的 <code>goroutine</code> 结束工作。那么如何确定当前正在运行的 <code>goroutine</code> 的数量呢？不确定。尤其是对于复杂的系统来说，如果 <code>goroutine</code> 是可以繁殖的 —— 一个 <code>goroutine</code> 在运行时又创建了 ( 多个 ) <code>goroutine</code> ，再或者某些 <code>goroutine</code> 提前执行完并返回了，这都会导致其数量的浮动。</p>
<p>要解决这类问题，不应让父 <code>goroutine</code> 主动通知子 <code>goroutine</code> ，而是应该让子 <code>goroutine</code> 主动检测父 <code>goroutine</code> 的某个信号量。这里利用一个同步通道来实现；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>	done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br>	<span class="hljs-keyword">var</span> cancel = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<br>		<span class="hljs-keyword">select</span> &#123;<br>		<span class="hljs-comment">// 回想:消费者永远都可以从一个被关闭的通道获取值。</span><br>		<span class="hljs-keyword">case</span> &lt;-done:<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// goroutine1 持续输出偶数</span><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>		<span class="hljs-keyword">for</span> &#123;<br>			<span class="hljs-keyword">if</span> cancel() &#123;<br>				<span class="hljs-keyword">return</span><br>			&#125;<br>			fmt.Printf(<span class="hljs-string">&quot;[goroutine1]:%v\n&quot;</span>, i)<br>			i = i + <span class="hljs-number">2</span><br>			time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-comment">// goroutine2 持续输出奇数</span><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br>		<span class="hljs-keyword">for</span> &#123;<br>			<span class="hljs-keyword">if</span> cancel() &#123;<br>				<span class="hljs-keyword">return</span><br>			&#125;<br>			fmt.Printf(<span class="hljs-string">&quot;[goroutine2]:%v\n&quot;</span>, i)<br>			i = i + <span class="hljs-number">2</span><br>			time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-comment">// 开启另一个 goroutine 用于监听输入</span><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		bufio.NewScanner(os.Stdin).Scan()<br>		<span class="hljs-built_in">close</span>(done)<br>	&#125;()<br><br>	<span class="hljs-keyword">for</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;[main]:still running...&quot;</span>)<br>		time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主程序在接收到输入之后关闭了 <code>done</code> 通道。这样做的结果是：<code>cancel()</code> 函数会立刻接收到消息的 <code>nil</code> 值 ( 参考通道关闭节 ) ，并以此作为停止 <code>goroutine</code> 的信号量。主函数的所有子 <code>goroutine</code> 会在每一轮的迭代工作之前调用 <code>cancel()</code> 局部函数进行检查，结果被告知为 <code>true</code> ，因此相继返回退出。</p>
<h1 id="第九章-共享变量"><a href="#第九章-共享变量" class="headerlink" title="第九章 共享变量"></a>第九章 共享变量</h1><h2 id="9-1-竞态"><a href="#9-1-竞态" class="headerlink" title="9.1 竞态"></a>9.1 竞态</h2><p>假定一个 <code>goroutine</code> X 的内部有三个依次发生的事件：x1，x2，x3 。另一个 <code>goroutine</code> Y 的内部也有三个依次发生的事件，y1，y2，y3。每个事件在各自的 <code>goroutine</code> 能够保证顺序运行，但如果 X 和 Y <strong>并发</strong> 运行，则事件 x<sub>i</sub> 和 y<sub>j</sub> 之间谁先谁后就无法确定了。假定多个 <code>goroutine</code> 并发地调用了同一个函数，而该函数总能返回正确的结果，那么称该函数是<strong>并发安全</strong>的。</p>
<p>然而，不是所有的函数都可以确保这一点，其中一个原因就是数据<strong>竞态</strong>导致的。下面用一个存取款的例子来描述数据竞态如何影响程序运行结果 ( 在数据库教程中，这个例子曾经常用于讲解并发的事务 )：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> balance <span class="hljs-keyword">int</span> = <span class="hljs-number">100</span><br><br><span class="hljs-keyword">var</span> deposit = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	balance = balance + amount<br>&#125;<br><br><span class="hljs-keyword">var</span> show = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> balance&#125;<br></code></pre></td></tr></table></figure>

<p>现在有两个人共享 <code>balance</code> 账户。他们几乎在同一时刻向这个账户中发起存款：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    deposit(<span class="hljs-number">200</span>)<br>&#125;()<br><br><span class="hljs-comment">// B</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    deposit(<span class="hljs-number">100</span>)<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>fmt.Print(show())<br></code></pre></td></tr></table></figure>

<p>在串行化的运行环境中，最终账户的余额是 400，这没有任何争议。但是在并发执行的情况下，情况就不一样了：比如 A 在执行到 <code>balance + amount</code> 时，B 恰好通过 <code>deposit</code> 函数更新了余额，此时意味着 A 现在所持有的 <code>balance</code> 是一个过期的数据。用这个过期的数据更新账户余额，会导致 B 的更新会被覆盖 ( 银行凭空从这个账户中赚了 100 元 ) 。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">balance = 100<br>-------------------------------------<br>Aread = 100    |	<br><span class="hljs-code">               |    Bread  = 100</span><br><span class="hljs-code">               |    Bwrite = 200</span><br>Awrite = 300   |<br>--------------------------------------<br>balance = 300<br></code></pre></td></tr></table></figure>

<p>这种现象就是数据竞态的一种。它发生的前提条件是 —— 两个或者多个 <code>goroutine</code> 共享一个变量，并且至少有一方进行了写入操作。不过这个例子太轻量级了，我们很难看到程序反馈预期外的结果。</p>
<p>另一个例子会引发明显的现象：一个 “薛定谔” 的下标访问。两个 <code>goroutine</code> 同时为一个 <code>x</code> 赋值，而 <code>x</code> 的长度有可能是 10，有可能是 100 ( 取决于哪个 <code>goroutine</code> 后执行 ) 。一旦 <code>x</code> 的长度是 10，那么这个主函数最终就会因下标越界而报错。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x []<span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    x = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-number">100</span>)<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    x = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-number">10</span>)<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">100</span> *time.Millisecond)<br>fmt.Print(x[<span class="hljs-number">99</span>])<br></code></pre></td></tr></table></figure>

<p>有三种方式可以消除数据竞态 —— 第一种，如果数据是<strong>不可变</strong>的，那么它一定是并发安全的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">const</span> (<br>    LENGTH = <span class="hljs-number">100</span><br>)<br><br><span class="hljs-comment">// 两个 goroutine 总是基于常量创建切片。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    x = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,LENGTH)<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    x = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,LENGTH)<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">100</span> *time.Millisecond)<br>fmt.Print(x[<span class="hljs-number">99</span>])<br></code></pre></td></tr></table></figure>

<p>但在一定会执行更新操作的业务中 ( 比如刚才银行账户的例子 ) ，这种方法不现实。第二种方法是：避免在多个 <code>goroutine</code> 下对变量进行改动。</p>
<p>回到银行账户的例子当中，其它的 <code>goroutine</code> 线程只能提交修改请求，这些请求被发送给一个 <code>balance</code> 的代理 <code>goroutine</code> ，只有它能够对 <code>balance</code> 进行修改，或者回显。换句话说， <code>balance</code> 本身将对 A 和 B 不可见，他们被限制以<strong>同步通道</strong>的形式和代理交互数据。这对应了开篇 Go 语言的那句箴言。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">request := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>response := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br><span class="hljs-keyword">var</span> deposit = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    request &lt;- amount<br>&#125;<br><br><span class="hljs-keyword">var</span> show = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> &lt;-response &#125;<br><br><span class="hljs-comment">// A</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    deposit(<span class="hljs-number">200</span>)<br>&#125;()<br><br><span class="hljs-comment">// B</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    deposit(<span class="hljs-number">100</span>)<br>&#125;()<br><br><span class="hljs-comment">// Proxy</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// Read from MySQL</span><br>    <span class="hljs-keyword">var</span> balance = <span class="hljs-number">100</span><br><br>    <span class="hljs-keyword">for</span>&#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> a := &lt;-request: balance += a<br>            <span class="hljs-keyword">case</span> response &lt;- balance:<br>        &#125;<br>    &#125;<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>fmt.Print(show())<br></code></pre></td></tr></table></figure>

<p>有些变量无法在一整个 <code>goroutine</code> 之内做出限制，这时可以通过 <strong>通道</strong> 将这个变量从流水线的上游逐步传递到下游。在流水线的单个节点内部，可以对这个变量做任意的串行操作，但是一旦这个变量发送出去，该节点就不允许再修改变量了。说得再直白些就是：变量首先传递到某个节点串行使用，然后再传递到下一个节点串行使用。这个变量共享的方式称之为<strong>串行受限</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">syncCh1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>syncCh2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>syncCh3 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,out <span class="hljs-keyword">chan</span> &lt;- <span class="hljs-keyword">int</span>)</span></span>&#123;<br>   i := &lt;-in<br>   out &lt;- i + <span class="hljs-number">3</span><br>&#125;(syncCh1,syncCh2)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,out <span class="hljs-keyword">chan</span> &lt;- <span class="hljs-keyword">int</span>)</span></span>&#123;<br>   i := &lt;-in<br>   out &lt;- i * <span class="hljs-number">2</span><br>&#125;(syncCh2,syncCh3)<br><br><br>syncCh1 &lt;- <span class="hljs-number">1</span><br><span class="hljs-comment">// 串行受限方式地计算 ( x + 3 ) * 2。</span><br>fmt.Print(&lt;-syncCh3)<br></code></pre></td></tr></table></figure>

<p>第三种方式则是最熟悉的互斥机制。</p>
<h2 id="9-2-互斥锁-sync-Mutex"><a href="#9-2-互斥锁-sync-Mutex" class="headerlink" title="9.2 互斥锁 sync.Mutex"></a>9.2 互斥锁 sync.Mutex</h2><p>即便不借助任何额外地工具，我们也可以使用容量为 1 的缓冲通道构建一个互斥锁。这个通道表征了一个二进制信号量，有消息表示上锁，没有消息表示无锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    mu = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,<span class="hljs-number">1</span>)<br>    balance = <span class="hljs-number">100</span><br>)<br><br><span class="hljs-keyword">var</span> deposit = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    balance = balance + amount<br>&#125;<br><br><span class="hljs-keyword">var</span> show = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>&#123;<span class="hljs-keyword">return</span> balance&#125;<br><br><span class="hljs-comment">// A</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 加锁</span><br>    mu &lt;- <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">// 以下是临界代码</span><br>    deposit(<span class="hljs-number">100</span>)<br><br>    <span class="hljs-comment">// 放锁</span><br>    &lt;-mu<br>&#125;()<br><br><span class="hljs-comment">// B</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    mu &lt;- <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">// 以下是同步代码</span><br>    deposit(<span class="hljs-number">200</span>)<br><br>    &lt;-mu<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>互斥锁的用途十分广泛，因此 Go 直接提供了 <code>sync.Mutex</code> 。<code>Lock()</code> 方法即加锁，<code>Unlock</code> 方法即放锁：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    mu sync.Mutex<br>    balance = <span class="hljs-number">100</span><br>)<br><br><span class="hljs-keyword">var</span> deposit = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    balance = balance + amount<br>&#125;<br><br><span class="hljs-keyword">var</span> show = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>&#123;<span class="hljs-keyword">return</span> balance&#125;<br><br><span class="hljs-comment">// A</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-comment">// 以下是同步代码</span><br>    deposit(<span class="hljs-number">100</span>)<br><br>    mu.Unlock()<br>&#125;()<br><br><span class="hljs-comment">// B</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-comment">// 以下是同步代码</span><br>    deposit(<span class="hljs-number">200</span>)<br><br>    mu.Unlock()<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>fmt.Print(show())<br></code></pre></td></tr></table></figure>

<p>所有夹杂在 <code>Lock()</code> 和 <code>Unlock()</code> 之间的代码块称之为临界区。在其它 <code>goroutine</code> 通过 <code>Lock()</code> 加锁之后，其它 <code>goroutine</code> 在执行到 <code>Lock()</code> 会陷入阻塞状态 ( 这个原理是Go 提供的这把锁是<strong>不可再入</strong>的，即不能给已经上锁的锁头再加锁 )，直到它抢先获得互斥锁为止。因此，对于上述的例子而言，这保证了同一时间 A 和 B 只可能有一个人调用 <code>deposit()</code> 函数。</p>
<p>另外，在一个 <code>goroutine</code> 内，加锁和放锁操作必须是对应的，否则会导致其它等待释放锁的 <code>goroutine</code> 陷入死等的状态。这时，不如将放锁的动作添加到延迟调用栈中，这样函数将总是可以保证在退出之后 ( 无论是正常退出，还是因为内部发生错误而短路退出的 ) 能够释放锁资源。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">mu.Lock()<br><span class="hljs-keyword">defer</span> mu.Unlock()<br></code></pre></td></tr></table></figure>

<p>一个由互斥锁保护的调用是<strong>并发安全</strong>的，而代价是牺牲少许性能。</p>
<h2 id="9-3-共享锁-sync-RWMutex"><a href="#9-3-共享锁-sync-RWMutex" class="headerlink" title="9.3 共享锁 sync.RWMutex"></a>9.3 共享锁 sync.RWMutex</h2><p>假定银行发现大部分客户对账户的操作是读取而非写入，则可以考虑将一些事务的读操作设置成共享锁 ( 读写锁 ) 而非互斥锁。这样，如果有两个 <code>goroutine</code> 竞争同一个资源，但是它们<strong>都没有对这个竞争资源进行写操作</strong>，则可以共享它。换句话说，只有读-读锁可共存。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    mu sync.RWMutex<br>    balance = <span class="hljs-number">100</span><br>)<br><span class="hljs-comment">// ... 对于写入操作，调用的仍然是 Lock 和 Unlock 方法，因此在这里省略重复代码。</span><br><span class="hljs-keyword">var</span> show = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>&#123;<br>    mu.RLock()<br>    <span class="hljs-keyword">defer</span> mu.RUnlock()<br>    <span class="hljs-keyword">return</span> balance<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，共享锁 ( 即读锁) 保护的临界区不应当存在包括写入数据在内的副作用。另外，共享锁内部机制比互斥锁更加复杂，因此 <code>sync.RWMutex</code> 只有在 goroutines 激烈地竞争读操作时才会比互斥锁更加有优势，否则，它的效率比互斥锁低。</p>
<h2 id="9-4-延迟初始化-sync-Once"><a href="#9-4-延迟初始化-sync-Once" class="headerlink" title="9.4 延迟初始化 sync.Once"></a>9.4 延迟初始化 sync.Once</h2><p>由于 <code>if</code> 或者 <code>switch</code> 这类选择分支的存在，程序不保证所有的变量<strong>在运行时</strong>都会用到。尤其是某些资源的初始化需要比较大的代价时，将它声明为一个 “懒汉式” 单例更为明智一些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> resp <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadResource</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;resp 加载开始...\n&quot;</span>)<br>	<span class="hljs-keyword">if</span> resp == <span class="hljs-literal">nil</span> &#123;<br>		resp = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<br>			<span class="hljs-string">&quot;banner&quot;</span>:     <span class="hljs-string">&quot;/banner.jpg&quot;</span>,<br>			<span class="hljs-string">&quot;body&quot;</span>:       <span class="hljs-string">&quot;/body.jpg&quot;</span>,<br>			<span class="hljs-string">&quot;background&quot;</span>: <span class="hljs-string">&quot;/background.jpg&quot;</span>,<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    loadResource()<br>    <span class="hljs-comment">// 主 goroutine 是串行运行的，因此我们总是能得到正确的结果。</span><br>    fmt.Printf(<span class="hljs-string">&quot;resp = [%v]&quot;</span>, resp[<span class="hljs-string">&quot;body&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码不是 “goroutine 安全” ( 在其它语言中，这个现象称之为 “线程安全” ) 的。现在假定有两个 <code>goroutine</code> 分别执行初始化和访问工作，且其中一个 <code>goroutine</code> 早在 <code>resp</code> 被初始化之前就访问它，那么会得到一个空值，进而可能引发重复的初始化动作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一个 goroutine 正进行初始化。</span><br><span class="hljs-keyword">go</span> loadResource()<br><br><span class="hljs-comment">// 令一个 goroutine 正尝试读。</span><br><span class="hljs-comment">// 如果它没有观测到 resp 被初始化完成，则它会自行执行 loadResource() 函数。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    s,ok := resp[<span class="hljs-string">&quot;body&quot;</span>]<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        loadResource()<br>        fmt.Printf(<span class="hljs-string">&quot;resp = [%v]&quot;</span>,s)<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;fmt.Printf(<span class="hljs-string">&quot;resp = [%v]&quot;</span>,s)&#125;<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>比如在上述代码中，加载函数 <code>loadResource</code> 有可能会被调用多次，这种情况下会造成系统资源浪费。控制台有可能会打印：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang">resp 加载开始...<br>resp 加载开始...<br></code></pre></td></tr></table></figure>

<p>一个有效的方法是使用互斥锁 <code>sync.Mutex</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    loadMu.Lock()<br>    loadResource()<br>    loadMu.Unlock()<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    loadMu.Lock()<br>    s,ok := resp[<span class="hljs-string">&quot;body&quot;</span>]<br>    loadMu.Unlock()<br><br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        loadMu.Lock()<br>        loadResource()<br>        loadMu.Unlock()<br>        fmt.Printf(<span class="hljs-string">&quot;resp = [%v]&quot;</span>,s)<br>    &#125; <span class="hljs-keyword">else</span> &#123;fmt.Printf(<span class="hljs-string">&quot;resp = [%v]&quot;</span>,s)&#125;<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>通常，对某个昂贵资源的初始化工作只需要一次，后续仅仅是对该资源的调用。因此，这里不妨使用共享锁 <code>sync.RWMutex</code> 来代替互斥锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> loadMu sync.RWMutex<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    loadMu.Lock()<br>    loadResource()<br>    loadMu.Unlock()<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    loadMu.RLock()<br>    s,ok := resp[<span class="hljs-string">&quot;body&quot;</span>]<br>    loadMu.RUnlock()<br><br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        loadMu.Lock()<br>        loadResource()<br>        loadMu.Unlock()<br>        fmt.Printf(<span class="hljs-string">&quot;resp = [%v]&quot;</span>,s)<br>    &#125; <span class="hljs-keyword">else</span> &#123;fmt.Printf(<span class="hljs-string">&quot;resp = [%v]&quot;</span>,s)&#125;<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>Go 提供了一个更方便的工具来帮助实现 “goroutine 安全” 的懒汉式加载。下面的代码块将 <code>loadResource</code> 迁移到了一个 <code>sync.Once</code> 变量内：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> resourceOnce sync.Once<br><br><span class="hljs-comment">// worker1 </span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    resourceOnce.Do(loadResource)<br>&#125;()<br><br><span class="hljs-comment">// worker2</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    s,ok := resp[<span class="hljs-string">&quot;body&quot;</span>]<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        <span class="hljs-comment">// sync.Once 保证 loadResource 全局只会被调用一次。</span><br>        resourceOnce.Do(loadResource)<br>        fmt.Printf(<span class="hljs-string">&quot;resp = [%v]&quot;</span>,s)<br>    &#125; <span class="hljs-keyword">else</span> &#123;fmt.Printf(<span class="hljs-string">&quot;resp = [%v]&quot;</span>,s)&#125;<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>其函数调用 <code>Do(loadResource)</code> 总是能够保证在上下文中 <code>loadResource</code> 函数只会被调用一次。如果后续有其它 <code>goroutine</code> “误触” 了此加载函数，则这个 <code>Do</code> 将是一个空调用。</p>
<h2 id="9-5-竞态检测器"><a href="#9-5-竞态检测器" class="headerlink" title="9.5 竞态检测器"></a>9.5 竞态检测器</h2><p>一个残酷的现实是，无论是多么小心翼翼地操纵多个 <code>goroutine</code> ，在并发编程的环境中数据竞态难以避免。Go 提供了便捷的工具来帮助程序员对测试并记录程序在实际运行时出现的数据竞态。如果需要使用它，则在 <code>go</code> 命令后面补充上一个 <code>-race</code> 参数即可。在 GoLand IDE 中，可以通过 <code>Edit Configuration -&gt; Go tool arguments</code> 进行设置。</p>
<p>这个参数会命令 Go 编译器基于我们原有的代码构建一个附带竞态检测器的版本 ( 因此编译的时间可能要更长一些，但相比人工分析数据竞态而言，这点成本可以欣然接受 ) 。竞态检测器随着程序的运行检测事件流，并报告发生冲突的案例，下面是笔者在本机通过竞态检测器分析之前的案例程序并打印出的报告：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">==================<br>WARNING: DATA RACE<br><span class="hljs-keyword">Write</span> at <span class="hljs-number">0</span>x000000443688 by goroutine <span class="hljs-number">7</span>:<br>  main.loadResource()<br>      C:<span class="hljs-regexp">/Users/</span>liJunhu<span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/awesomeProject/m</span>ain/runFirst.go:<span class="hljs-number">13</span> +<span class="hljs-number">0</span>x204<br>  sync.(*Once).doSlow()<br>      C:<span class="hljs-regexp">/Go/</span>src<span class="hljs-regexp">/sync/</span>once.go:<span class="hljs-number">66</span> +<span class="hljs-number">0</span>x10a<br>  sync.(*Once).<span class="hljs-keyword">Do</span>()<br>      C:<span class="hljs-regexp">/Go/</span>src<span class="hljs-regexp">/sync/</span>once.go:<span class="hljs-number">57</span> +<span class="hljs-number">0</span>x72<br>  main.main.func1()<br>      C:<span class="hljs-regexp">/Users/</span>liJunhu<span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/awesomeProject/m</span>ain/runFirst.go:<span class="hljs-number">27</span> +<span class="hljs-number">0</span>x4b<br><br><span class="hljs-keyword">Previous</span> <span class="hljs-keyword">read</span> at <span class="hljs-number">0</span>x000000443688 by goroutine <span class="hljs-number">8</span>:<br>  main.main.func2()<br>      C:<span class="hljs-regexp">/Users/</span>liJunhu<span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/awesomeProject/m</span>ain/runFirst.go:<span class="hljs-number">31</span> +<span class="hljs-number">0</span>x45<br><br>Goroutine <span class="hljs-number">7</span> (running) created at:<br>  main.main()<br>      C:<span class="hljs-regexp">/Users/</span>liJunhu<span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/awesomeProject/m</span>ain/runFirst.go:<span class="hljs-number">26</span> +<span class="hljs-number">0</span>x94<br><br>Goroutine <span class="hljs-number">8</span> (running) created at:<br>  main.main()<br>      C:<span class="hljs-regexp">/Users/</span>liJunhu<span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/awesomeProject/m</span>ain/runFirst.go:<span class="hljs-number">30</span> +<span class="hljs-number">0</span>xb6<br>==================<br></code></pre></td></tr></table></figure>

<p>这段报告的大体意思是说：worker1 ( 即 Goroutine 7 ) 尝试初始化资源 <code>resp</code> ( 地址 <code>0x000000443688</code> ) 之前， worker2 ( Goroutine 8 ) 正准备调用 <code>resp[&quot;body&quot;]</code> 来试图获取一个值，由此引发了这两个 <code>routine</code> 之间的数据竞争。</p>
<p>不过需要注意的是，它只记录本次运行时发生的竞态，不确保这个竞态在将来仍然会发生。</p>
<h2 id="9-6-Goroutine-amp-线程"><a href="#9-6-Goroutine-amp-线程" class="headerlink" title="9.6 Goroutine &amp; 线程"></a>9.6 Goroutine &amp; 线程</h2><p>首先，两者在数量和体量上可以存在巨大的差别。操作系统预留的用户线程占用<strong>固定大小</strong>的栈内存 ( 一般是 2 MB ) ，它用于保存函数调用期间所产出的局部变量。相比之下，一个 <code>goroutine</code> 占用<strong>非固定大小</strong>的栈内存 ( 用途和用户线程的占内存类似 )，并且在程序刚运行时它占用的内存通常都非常小 ( 或许只有 2KB ) 。随着程序的不断深入，一个 <code>goroutine</code> 所占用的占内存可以按需增加 / 减少，甚至说一个 <code>goroutine</code> 就能够占据 1 GB 的空间 ( 这比常规的线程还要庞大 )。</p>
<p>用户线程由操作系统内核来调度。每过几毫秒，一个硬件时钟便会向 CPU 发送中断信号，CPU 通过调用名为<strong>调度器</strong>的内核函数 ( 这会使 CPU 从用户态陷入内核态 ) 实现<strong>上下文</strong>切换：即保存上一个线程的运行状态，并恢复当前线程的运行状态，其整个过程都需要一定的时间成本。假定程序频繁进行线程切换，那么这个时间成本的累计将是可观的。</p>
<p>Go 语言使用自己的调度器实现 <code>goroutine</code> 切换，它建立在 <strong>G-P-M</strong> 模型之上。简单来说，该调度器使用 <strong>m : n</strong> 技术将 m 个 <code>goroutine</code> 映射到了 n 个操作系统的用户线程。它的工作机制和 CPU 的调度方式大体类似，但是它只需要关心 Go 程序如何调度 <code>goroutine</code> ，而不需要关注如何操作用户线程。在此期间，将 <code>goroutine</code> 映射到用户线程的逻辑则交给模型中的 “P” —— Processor，逻辑处理器去管理，它充当了 “中介人” 的身份。</p>
<p>Go 调度器也不依赖硬件时钟来实现切换，而是由 Go 自身的架构来触发。和线程切换相比，它避免了 CPU 直接陷入内核态，因此切换 <code>goroutine</code> 的代价要比切换线程的代价要小。</p>
<p>这里要提要一个 <code>GOMAXPROCS</code> 环境变量，它代表了 “m : n” 当中的 n 。通常，这个数值等于机器中 CPU 的数量。比如对于 8 核机器而言，一个 <code>goroutine</code> 会被分配到 8 个用户线程的其中一个。假定一个用户线程中的某一个 <code>goroutine</code> 因为调用 <code>time.Sleep</code> 函数或者通道通信而阻塞了，那么该用户线程的其它活跃的 <code>goroutine</code> 可以挪动到另一个可用的用户线程继续执行。</p>
<p>但如果一个 <code>goroutine</code> 的执行涉及系统调用，或者依赖由其它语言实现的函数，这就需要另分配用户线程来执行，但这不会计算在 <code>GOMAXPROCS</code> 的数目内。Go 语言鼓励简单的编程风格，因此它特意没有为 <code>goroutine</code> 留下可被寻找的标识：一个函数的运行结果应当只由它的参数列表来决定，而不是 “谁来运行它”。 </p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go: (四)接口</title>
    <url>/2021/03/20/Go-%E5%9B%9B-%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h1><p>接口的本质是 “抽象”。Go 语言中，接口是<strong>隐式实现</strong>的，不需要诸如 <code>implements</code>，<code>extends</code> 的关键字主动定义一个结构体类型打算实现哪些接口。这样设计的好处是：只要某个库的类型是可导出的，我们可以就地为它拓展接口，而不用改动原有的声明 ( 满足 OCP 原则 ) 。</p>
<h2 id="7-1-接口即约定"><a href="#7-1-接口即约定" class="headerlink" title="7.1 接口即约定"></a>7.1 接口即约定</h2><p>如果说之前介绍的类型全部都是具体类型，那么接口就是一个<strong>抽象类型</strong>。接口的具体类型是不确定的，我们仅仅知道接口定义了哪些方法，这些方法各自接收哪些参数，又返回哪些内容。</p>
<p>这里举一个简单的例子：<code>Phone</code> 接口定义了一部手机所应当具备的基本功能：通话，短信，还有网上冲浪。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Phone <span class="hljs-keyword">interface</span> &#123;<br>	<span class="hljs-comment">// 接口内部可以有方法，可以再内嵌其它接口，但是不能声明普通的成员。</span><br>    <span class="hljs-comment">// 这里定义的都是抽象方法，不需要使用 func 关键字定义，且没有 &#123;&#125; 语句块。</span><br>	call()<br>	text()<br>	wifi()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么，任何一个品牌的手机都应该具备这三个基本功能 ( 各个厂商如何实现的，我们也不关心 ) ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 小米手机--------------------------</span><br><span class="hljs-keyword">type</span> XiaoMi <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x XiaoMi)</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Print(<span class="hljs-string">&quot;Are you OK?&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x XiaoMi)</span> <span class="hljs-title">text</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;I&#x27;m fine, thank you!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x XiaoMi)</span> <span class="hljs-title">wifi</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;to Indian Mi Bands!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x XiaoMi)</span> <span class="hljs-title">MiUI</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Mi Ui&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 锤子手机-----------------------------</span><br><span class="hljs-keyword">type</span> Smartisan <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Smartisan)</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;Lao Luo don&#x27;t do this&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Smartisan)</span> <span class="hljs-title">text</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;TNT yyds&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Smartisan)</span> <span class="hljs-title">wifi</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Li Jie Wan Sui&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>顺带一提，GoLand 会随时检测我们新创建的结构体 ( 类型 )，一旦它实现了某个接口的所有功能，其左侧会亮起熟悉的绿色 <code>I</code> 字母图标。另外，我们还可以在结构体内按下 <code>Ctrl</code> + <code>i</code> 并通过搜索接口的方式直接创建出方法模板。</p>
<p>对于用户而言，它仅使用统一的 <code>Phone</code> 接口实现预期的功能，而不再关注具体的实现类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> aPhone Phone<br><br><span class="hljs-comment">// aPhone = Smartisan&#123;&#125;</span><br><span class="hljs-comment">// aPhone = ... 可以是任何实现了 Phone 接口约定的结构体类型，</span><br><span class="hljs-comment">// 接口带来了编程的可取代性。 </span><br>aPhone = XiaoMi&#123;&#125;<br><br>aPhone.call()<br>aPhone.text()<br><br><span class="hljs-comment">// 不能使用</span><br>aPhone.MiUI()<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们可以这样表述：<code>XiaoMi</code> <strong>是</strong> ( is-a 的关系 ) 一个 <code>Phone</code> 类型。当 <code>XiaoMi</code> 被当作一个 <code>Phone</code> 类型使用时，它独有的 <code>MiUI</code> 方法会被禁止直接调用 ( 当然，通过类型断言可以将其重新特化成 <code>XiaoMi</code>，这样我们就可以调用这个方法了，见后文 )。这非常容易理解，因为该方法并不在 <code>Phone</code> 接口的约束范畴。</p>
<p>如果希望某个类型的方法调用是传地址 ( 而非传值 ) 的，那么根据经验，我们会将方法的接收者设置为类型指针，此时称 <code>*XiaoMi</code> 是一个 <code>Phone</code> 类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> XiaoMi <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *XiaoMi)</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;implement me&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *XiaoMi)</span> <span class="hljs-title">text</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;implement me&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *XiaoMi)</span> <span class="hljs-title">wifi</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;implement me&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//....</span><br>aPhone = &amp;XiaoMi&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>注意，” <code>XiaoMi</code> 是一个 <code>Phone</code> “ 和 “<code>*XiaoMi 是一个 Phone</code> 类型 “ 是存在一些微妙区别的。假定 <code>XiaoMi</code> 现在的实现是这个样子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Phone <span class="hljs-keyword">interface</span> &#123;<br>	<span class="hljs-comment">// 接口内部可以有方法，可以再内嵌其它接口，但是不能声明普通的成员。</span><br>	<span class="hljs-comment">// 这里定义的都是抽象方法，不需要使用 func 关键字定义，且没有 &#123;&#125; 语句块。</span><br>	call()<br>	text()<br>	wifi()<br>&#125;<br><br><span class="hljs-keyword">type</span> XiaoMi <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *XiaoMi)</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x XiaoMi)</span> <span class="hljs-title">text</span><span class="hljs-params">()</span></span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *XiaoMi)</span> <span class="hljs-title">wifi</span><span class="hljs-params">()</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>此时， “<code>XiaoMi</code> 是一个 <code>Phone</code> 类型” 不成立，但是 “ <code>*XiaoMi</code> 是一个 <code>Phone</code> 类型”  成立。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p Phone = &amp;XiaoMi&#123;&#125;<br><br><span class="hljs-comment">// 接收者为指针时，语法不报错，方法都可以调用。</span><br>p.text()<br>p.call()<br>p.wifi()<br><br><span class="hljs-keyword">var</span> q Phone = XiaoMi&#123;&#125;<br><br><span class="hljs-comment">// 接收者为指针时，语法报错，原因在于 XiaoMi 被认为仅仅实现了 text() 方法。</span><br>q.wifi()<br>q.call()<br>q.text()<br></code></pre></td></tr></table></figure>

<p>以 <code>XiaoMi</code> 类型的角度去思考，它只实现了 <code>text()</code> 方法，因为该方法的接收者是 <code>*XiaoMi</code> 而不是 <code>XiaoMi</code>。这么看来，<code>*XiaoMi</code> 似乎也没实现 <code>call()</code> 方法，那为什么它却可以当作 <code>Phone</code> 去使用呢？</p>
<p>原因是 Go 提供了这样的语法糖：假定 p 是 <code>XiaoMi</code> 类型，那么该方法调用： <code>p.text()</code> 会被自动转化为 <code>(*p).text()</code>。因此，可以认为 <code>*XiaoMi</code> 也是 <code>text()</code> 方法的接收者，但是反之，接收者 <code>XiaoMi</code> 却 “不享受这样的待遇”。</p>
<p>推广并总结一下：由于接收者为 <code>T</code> 的方法可以被 <code>*T</code> 直接调用，因此 <code>*T</code> 可能会实现比 <code>T</code> 更多的接口。但实际上，当实现某个接口时，方法的接收者一般都是统一的：要么就都是命名类型，要么就都是类型指针，总体而言，接收者为类型指针时更 “赚” 一些，因为它还避免了值复制的开销。</p>
<p>接口内部不能内嵌普通的类型成员，但是可以组合其它的接口。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go 源码库乐于以 &quot;单一职责原则&quot; 定义一些只包含一个方法的接口，然后供其它更复杂的接口加以组合。</span><br><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>	Read()<br>&#125;<br><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>	Write(<span class="hljs-keyword">string</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> IOChannel <span class="hljs-keyword">interface</span> &#123;<br>	<span class="hljs-comment">// 它相当于获得了 Reader 和 Writer 定义的抽象方法。</span><br>	Reader<br>	Writer<br>	<br>	<span class="hljs-comment">// 这不影响该接口定义自己的抽象方法。</span><br>	Close()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上述代码块为例，任何一个实现 <code>IOChannel</code> 接口的类型，它除了实现该结构自身定义的 <code>Close()</code> 方法之外，还要实现 <code>Reader</code> 和 <code>Writer</code> 接口定义的所有方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FileChannel <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *FileChannel)</span> <span class="hljs-title">Read</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">//panic(&quot;implement me&quot;)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *FileChannel)</span> <span class="hljs-title">Write</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> &#123;<br>	<span class="hljs-comment">//panic(&quot;implement me&quot;)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *FileChannel)</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">//panic(&quot;implement me&quot;)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>显然，任何实现 <code>IOChannel</code> 接口的类型 ( 比如 <code>FileChannel</code> ) 都可以去充当 <code>Reader</code> 或者是 <code>Writer</code> 接口，但是反之不成立。</p>
<h2 id="7-2-空接口"><a href="#7-2-空接口" class="headerlink" title="7.2 空接口"></a>7.2 空接口</h2><p>故名思意，空接口就是 <code>interface&#123;&#125;</code>，它里面什么都没有。从语义上来讲，它接近 Java 中的 <code>Object</code> 类型或者是 Scala 中的 <code>Any</code> ，因为任何类型即便是没有声明方法也可以认为是实现了 <code>interface&#123;&#125;</code> 接口。</p>
<p>如果留意之前曾使用的 <code>fmt.Fprintf(...)</code> 等方法，能够发现，其后续的 <code>arg</code> 参数正是 <code>...interface&#123;&#125;</code> 类型，它使得用户在调用该函数时能够传入任何数据结构。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> any <span class="hljs-keyword">interface</span>&#123;&#125;<br>any = <span class="hljs-number">1</span><br>any = <span class="hljs-number">1.00</span><br>any = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>但反之，其逆操作 ( 从一个 <code>interface&#123;&#125;</code> 中还原出具体的值 ) 需要借助<strong>类型断言</strong>来实现。</p>
<h2 id="7-3-接口值与可比较性"><a href="#7-3-接口值与可比较性" class="headerlink" title="7.3 接口值与可比较性"></a>7.3 接口值与可比较性</h2><p>一个接口类型的值包含了两个信息：该接口实际的具体类型 ( <strong>动态类型</strong> ) 以及该类型的值 ( <strong>动态值</strong> )。由于 Go 是一门编译性的语言，因此类型不能直接被当作是一个普通的值来看待，其动态类型是通过引入 <strong>类型描述符</strong> 来获得的。</p>
<p>下面代码块中的接口值 <code>p</code> 经历了一次声明和三次赋值：代码的注释部分标记了在每个过程中该接口值的动态类型以及动态值的变化。在一个接口刚被声明时，它的动态类型和动态值均指向 <code>nil</code>，此时它也被称作是一个 <code>nil</code> 接口。</p>
<p>注意，仅动态值为 <code>nil</code> 但动态类型非 <code>nil</code> 的接口和两者均为 <code>nil</code> 的接口是不一样的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	p 此时的动态类型: nil</span><br><span class="hljs-comment">	p 此时的值: nil</span><br><span class="hljs-comment">	此时调用任何方法都会报错</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">var</span> p Phone<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	p 此时的动态类型: *XiaoMi</span><br><span class="hljs-comment">	p 此时的值: &amp;XiaoMi&#123;&#125;</span><br><span class="hljs-comment">	p.call() =&gt;(&amp;XiaoMi&#123;&#125;).call()</span><br><span class="hljs-comment">*/</span><br>p = &amp;XiaoMi&#123;&#125;<br>p.call()<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	p 此时的动态类型: *HuaWi</span><br><span class="hljs-comment">	p 此时的值: &amp;HuaWei&#123;&#125;</span><br><span class="hljs-comment">	p.text() =&gt;(&amp;HuaWei&#123;&#125;).text()</span><br><span class="hljs-comment">*/</span><br>p = &amp;HuaWei&#123;&#125;<br>p.text()<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	p 此时的动态类型: nil</span><br><span class="hljs-comment">	p 此时的值: nil</span><br><span class="hljs-comment">	此时调用任何方法都会报错</span><br><span class="hljs-comment">*/</span><br>p = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure>

<p>两个接口值是<strong>可以比较</strong>的。如果两个接口值的动态类型相同，且动态值<strong>在可比较的前提下</strong>也完全相等，那么这两个接口值就相同，进而，接口可以充当 <code>map</code> 散列表的 Key，或者是 <code>switch</code> 语句的操作数。</p>
<p>但是，如果两个接口的动态类型相同，但是其动态值是不可比较的类型，那么这个比较就会以宕机告终。比如，我们将切片 <code>[]int8</code> 重新命名类型，然后就地拓展一个 <code>Iterable</code> 接口 ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntSeq []<span class="hljs-keyword">int8</span><br><span class="hljs-keyword">type</span> Iterable <span class="hljs-keyword">interface</span> &#123;<br>	foreach()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s IntSeq)</span> <span class="hljs-title">foreach</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">for</span> i,v := <span class="hljs-keyword">range</span> *s &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;[%v](%v)&quot;</span>,i,v)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下述代码块企图对两个 <code>Iterable</code> ( 或者说对两个 <code>[]int8</code>) 类型的值进行比较，显然，程序会出错：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> seq1 Iterable<br><span class="hljs-keyword">var</span> seq2 Iterable<br><br><span class="hljs-comment">// IntSeq 是[]int8 的命名别称，因此 IntSeq&#123;1,3,4&#125; 等价于 []int8&#123;1,3,4&#125;</span><br>seq1 = IntSeq&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br>seq2 = IntSeq&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   panic: runtime error: comparing uncomparable type main.IntSeq</span><br><span class="hljs-comment">*/</span><br>fmt.Print(seq1 == seq2)<br></code></pre></td></tr></table></figure>

<p>假设 <code>Iterable</code> 接口的实现者不是 <code>IntSeq</code> 而是 <code>*IntSeq</code>，那么这段程序就可以正常运行。原因是：虽然切片值是不可比较的，但是切片的地址是可以比较的。此时比较两个接口动态值是否相同，实际上是在检查两个切片的地址是否指向了同一个内存区域。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> seq1 Iterable<br><span class="hljs-keyword">var</span> seq2 Iterable<br><br><span class="hljs-comment">// IntSeq 是[]int8 的命名别称，因此 IntSeq&#123;1,3,4&#125; 等价于 []int8&#123;1,3,4&#125;</span><br>seq1 = &amp;IntSeq&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><br><span class="hljs-comment">// 如果 seq2 = seq1 ，那么程序的运行结果将是 true.</span><br>seq2 = &amp;IntSeq&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><br><span class="hljs-comment">// 程序的运行结果是 false.</span><br>fmt.Print(seq1 == seq2)<br></code></pre></td></tr></table></figure>

<p>另外，通过 <code>fmt.Printf</code> 和 <code>%T</code> 可以令 <code>fmt</code> 通过反射的形式获取到某个接口的动态类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> seq1 Iterable<br><br><span class="hljs-comment">// IntSeq 是[]int8 的命名别称，因此 IntSeq&#123;1,3,4&#125; 等价于 []int8&#123;1,3,4&#125;</span><br>seq1 = &amp;IntSeq&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><br><span class="hljs-comment">// *main.IntSeq</span><br>fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>,seq1)<br></code></pre></td></tr></table></figure>

<h2 id="7-4-sort-Interface-接口"><a href="#7-4-sort-Interface-接口" class="headerlink" title="7.4 sort.Interface 接口"></a>7.4 sort.Interface 接口</h2><p>接下来我们要了解 Go 标准库当中提供的两个重要接口，在这里首先介绍 <code>sort.Interface</code>  。排序是在编程工作中的通用操作，因此它显然不适合与任意一个具体的元素类型进行绑定。</p>
<p>在其它语言中，排序方法通常都是和已有的序列类型绑定，比如 Java 中的 <code>List</code> ，然后元素类型再通过约束类型边界的形式令其满足 “可排序” 的特征。但在  Go 语言中，<code>sort.Sort(...)</code> 方法允许我们对任何类型的序列进行排序，这个序列类型可以是切片，甚至是由我们自行定义的，满足 “索引序列” 特征的结构体。并且，Go 丝毫不关心序列的元素是什么类型。</p>
<p>但是在此之前，我们需要提前令该序列实现 <code>sort.Interface</code> 接口，以告知程序如何获取这个序列的长度 <code>Len()</code>，如何判别元素 A 小于另一个元素 B <code>less(..)</code>，如何交换两个元素。</p>
<p>下面用两个示例介绍如何配合 <code>sort.Interface</code> 和 <code>sort.Sort(..)</code> 完成对序列的排序。这里规定元素类型是 <code>Person</code>，在第一个例子中，序列选择原生的切片类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Persons []Person<br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;age <span class="hljs-keyword">int8</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Persons)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 由于 Persons 本质上是 []Person 类型，因此可以仅通过调用 len() 方法快速得到长度。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Persons)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// 这里声明 pp 仅仅是为了避免下方代码使用 (*p)[x] 的繁琐写法，下同</span><br>    pp  := *p<br>    <span class="hljs-keyword">if</span>  pp[i].age &lt; pp[j].age &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Persons)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    pp := *p<br>    <span class="hljs-comment">// 多重赋值的写法，在之前提到过。</span><br>    pp[i],pp[j] = pp[j],pp[i]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而在第二个例子中，我们选择对自定义的 <code>PersonList</code> 序列 ( 它本质上是通过递归组织起来的链表) 进行排序。由于 <code>sort.Interface</code> 基于 “索引” 号进行比较，因此这里要额外完善 “索引” 查找的 <code>Get(...)</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PersonList <span class="hljs-keyword">struct</span> &#123;<br>   head *node<br>&#125;<br><br><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;<br>   Person<br>   next *node<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   注意, index 值从 0 开始，在以下两种情况下程序会宕机：</span><br><span class="hljs-comment">   index &lt; 0 或者 index 超过了列表长度;</span><br><span class="hljs-comment">   列表的头结点为 nil。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ps *PersonList)</span> <span class="hljs-title">Get</span><span class="hljs-params">(index <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(target *node)</span></span> &#123;<br><br>   <span class="hljs-comment">// 定义内部递归的局部函数</span><br>   <span class="hljs-keyword">var</span> _get <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*node,<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">node</span></span><br>   _get = <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node,step <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(target *node)</span></span>&#123;<br><br>      <span class="hljs-keyword">switch</span> &#123;<br>      <span class="hljs-keyword">case</span> step == <span class="hljs-number">0</span>: target = n<br>      <span class="hljs-keyword">default</span>:<br>         target = _get(n.next,step<span class="hljs-number">-1</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span><br>   &#125;<br><br>	<span class="hljs-keyword">switch</span> &#123;<br>	<span class="hljs-keyword">case</span> ps.head == <span class="hljs-literal">nil</span>:<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;该 PersonList 为 nil。&quot;</span>)<br>	<span class="hljs-keyword">case</span> index &lt; <span class="hljs-number">0</span>:<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;越界下标&quot;</span>)<br>	<span class="hljs-keyword">case</span> index &gt; ps.Len()<span class="hljs-number">-1</span>:<br>		<span class="hljs-comment">//如果该列表的长度为 0，那么程序必定在此处宕机。</span><br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;越界下标&quot;</span>)<br>	&#125;<br>    <br>   <span class="hljs-keyword">return</span> _get(ps.head,index)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   通过递归的方式来获取列表长度。</span><br><span class="hljs-comment">   如果列表的头结点为 nil，则长度为 0，</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ps *PersonList)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-built_in">len</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br><br>   <span class="hljs-keyword">var</span> iterator <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*node,<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><br>   iterator = <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node, acc <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">len</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br><br>      <span class="hljs-keyword">switch</span> &#123;<br>      <span class="hljs-keyword">case</span> n.next == <span class="hljs-literal">nil</span>: <span class="hljs-built_in">len</span> = acc<br>      <span class="hljs-keyword">default</span>:<br><br>         <span class="hljs-comment">// 注意, 如果直接写 iterator(....) ，函数不会继续递归，而是直接 return.</span><br>         <span class="hljs-built_in">len</span> = iterator(n.next,acc+<span class="hljs-number">1</span>)<br>      &#125;<br><br>      <span class="hljs-keyword">return</span><br>   &#125;<br><br>   <span class="hljs-keyword">if</span> ps.head == <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>   &#125;<br><br>   <span class="hljs-built_in">len</span> = iterator(ps.head,<span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ps *PersonList)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>	<span class="hljs-keyword">return</span> ps.Get(i).age &lt; ps.Get(j).age<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ps *PersonList)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	ps.Get(i).Person,ps.Get(j).Person = ps.Get(j).Person,ps.Get(i).Person<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-5-error-接口"><a href="#7-5-error-接口" class="headerlink" title="7.5 error 接口"></a>7.5 error 接口</h2><p>其实我们早在之前调用 <code>os</code> 等资源库的例子中就接触过这个 <code>error</code> 接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这个 err 实现了 error 接口</span><br>open, err := os.Open(<span class="hljs-string">&quot;/src/name/touch.txt&quot;</span>)<br></code></pre></td></tr></table></figure>

<p><code>error</code> 接口的约束非常简单直接：通过 <code>Error()</code> ( 该方法返回一个 <code>string</code> 类型 ) 对外暴露错误信息。</p>
<p>现在，我们可以通过调用 <code>errors.New</code> 函数主动创建一个 <code>error</code> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(a,b <span class="hljs-keyword">float64</span>)</span> <span class="hljs-params">(r <span class="hljs-keyword">float64</span>,err error)</span></span>&#123;<br><br>	err = <span class="hljs-literal">nil</span><br>	<span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-comment">// New 函数相当于是 error 的 &quot;构造器&quot;</span><br>		err =  errors.New(<span class="hljs-string">&quot;除数不可为0&quot;</span>)<br>		r = math.NaN()<br>	&#125;<br><br>	r = a / b<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>更常用的做法是通过 <code>fmt.Errorf</code> 来实现，因为我们可以通过格式化的方式构造字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">err = fmt.Errorf(<span class="hljs-string">&quot;非法的除数:%v&quot;</span>,b)<br></code></pre></td></tr></table></figure>

<h2 id="7-6-类型断言"><a href="#7-6-类型断言" class="headerlink" title="7.6 类型断言"></a>7.6 类型断言</h2><p>类型断言相当于是将具体类型泛化为接口的逆操作：尝试将某个接口 <code>I</code> 转化成某个具体的类型或者是更加特化的接口 <code>O</code> ( 并不是强制性的，但通常我们没有必要断言更泛化的接口)，如果成功了，那么就可以获得更多的拓展方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> aPhone Phone<br>aPhone = &amp;XiaoMi&#123;&#125;<br><br><span class="hljs-comment">// 由于 MiUI 是小米手机独有的方法，因此这里要借助类型断言将其强制转换为小米手机。</span><br><span class="hljs-comment">// 语法是 (接口值).(目标类型/接口)</span><br>mi := aPhone.(*XiaoMi)<br>mi.MiUI()<br></code></pre></td></tr></table></figure>

<p>类型断言并不总是成功的，因此它有可能引发系统宕机。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> aPhone Phone<br>aPhone = &amp;HuaWei&#123;&#125;<br><br><span class="hljs-comment">// 编译器不报错，但是运行报错</span><br><span class="hljs-comment">// panic: interface conversion: main.Phone is *main.HuaWei, not *main.XiaoMi</span><br>mi := aPhone.(*XiaoMi)<br>mi.MiUI()<br></code></pre></td></tr></table></figure>

<h2 id="7-7-类型分支"><a href="#7-7-类型分支" class="headerlink" title="7.7 类型分支"></a>7.7 类型分支</h2><p>接口有完全不同的两种使用风格。截至目前，我们利用接口的目的是：抽象方法，提供约束，屏蔽实现，分离代码。这种使用风格称之为子类型多态 ( subtype polymorphism ) ：通俗的话就是 “基类” 能做的活 “派生类” 都能做。在 C++ / Java 的世界观中，这种风格通过 “继承” 来体现。</p>
<p>另一种使用风格是，利用接口可以容纳多种类型的能力，将这些多个类型看做是一个联合 ( union ) 。函数接收联合类型，并通过判断它的实际类型来采取 ( 可能是截然不同 ) 的处理策略。当然，和完全的 <strong>泛型</strong> 相比，联合类型是有限数量的。这种接口的使用风格称之为特设多态 ( ad hoc polymorphism ) 。</p>
<p>下面用一个简单的例子来演示：函数通过 <code>interface&#123;&#125;</code> 以接收任何类型的参数，然后根据参数的类型在控制台打印不同的内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">is</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>&#123;<br><br>	<span class="hljs-comment">// a.(type) type 是关键字，该写法在 switch 语句中用于提取 a 的实际类型。</span><br>	<span class="hljs-keyword">switch</span> a.(<span class="hljs-keyword">type</span>) &#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>: fmt.Print(<span class="hljs-string">&quot;空指针&quot;</span>)<br>	<span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>: fmt.Print(<span class="hljs-string">&quot;int 类型&quot;</span>)<br>	<span class="hljs-keyword">case</span> <span class="hljs-keyword">float32</span>: fmt.Print(<span class="hljs-string">&quot;float32 类型&quot;</span>)<br>	<span class="hljs-keyword">case</span> <span class="hljs-keyword">float64</span>: fmt.Print(<span class="hljs-string">&quot;float64 类型&quot;</span>)<br>	<span class="hljs-keyword">default</span>:<br>		fmt.Print(<span class="hljs-string">&quot;其它的类型...&quot;</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go: (三)函数与方法</title>
    <url>/2021/03/17/Go-%E4%B8%89-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>“函数” ( Function ) 特指那些未与任何结构体关联的 <code>func</code> 。而和特定类相关的函数将称之为方法 ( Method ) 。Go 语言是多范式的，这取决于你如何使用它。</p>
<h1 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h1><h2 id="5-1-函数声明"><a href="#5-1-函数声明" class="headerlink" title="5.1 函数声明"></a>5.1 函数声明</h2><p>对于 Go 语言而言，完整的函数声明至少要包含：名字，形参列表，函数体。当函数不通过 <code>return</code> 关键字返回任何值时，声明部分可以将返回列表省略。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">name</span>(params<span class="hljs-operator">-</span>list)</span> [result<span class="hljs-operator">-</span>list] &#123;<br>	<span class="hljs-operator">...</span><br>	[<span class="hljs-keyword">return</span> <span class="hljs-operator">&lt;</span>value<span class="hljs-operator">&gt;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个不返回值的函数，它的作用应当体现在<strong>副作用</strong>上 ( 这包括通过指针修改了某个地址上的值，甚至说是修改了远程的数据库数据 )。既不返回值，又不具备副作用的函数是没有任何意义的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这个函数的作用体现在了其副作用上：通过 fmt 向屏幕输出了 &quot;hello,go&quot;。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Print(<span class="hljs-string">&quot;hello,go&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 这个函数的作用只体现在返回值上，它是一个纯函数。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>,b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(result <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	result = a + b<br>	<span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当形参列表的某些<strong>连续个形参是同一种类型时</strong>，可以参考以下的简写方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a,b <span class="hljs-keyword">int</span>,c,d <span class="hljs-keyword">float64</span>)</span></span>&#123;&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-comment">// func(a int,b int,c float64,d float64)&#123;...&#125;</span><br></code></pre></td></tr></table></figure>

<p>其中，<code>a</code> 和 <code>b</code> 都是 <code>int</code> 类型，而 <code>c</code> 和 <code>d</code> 则均为 <code>float64</code> 类型。</p>
<p>Go 语言将函数视作是一等公民，这意味着函数可以被当作值在任意一处传递。函数的<strong>形参列表</strong>和<strong>返回值</strong>构成了<strong>函数签名</strong>，它将用于规范函数的类型。<strong>函数签名和变量名，返回值的命名都没有关系。</strong></p>
<p>通过格式化输出 <code>fmt.Printf(&quot;%T&quot;,func)</code> 可以查看任意一个函数的函数签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>,greet)<br><span class="hljs-comment">// 输出 func()</span><br>fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>,add)<br><span class="hljs-comment">// 输出 func(int,int) int</span><br></code></pre></td></tr></table></figure>

<p>函数可以递归。经典的例子就是递归方式遍历树结构，因为树结构本身的定义就是递归的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">seek</span><span class="hljs-params">(t *Tree)</span></span>&#123;<br>	<span class="hljs-keyword">if</span> t != <span class="hljs-literal">nil</span> &#123;fmt.Print(t.data,<span class="hljs-string">&quot; &quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span>&#125;<br>	<span class="hljs-keyword">if</span> t.left != <span class="hljs-literal">nil</span> &#123;seek(t.left)&#125;<br>	<span class="hljs-keyword">if</span> t.right != <span class="hljs-literal">nil</span> &#123;seek(t.right)&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Tree <span class="hljs-keyword">struct</span> &#123;<br>	data <span class="hljs-keyword">int8</span><br>	left *Tree<br>	right *Tree<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果选择了用递归解决问题，那么它最好是<strong>尾递归</strong>的，因为这可以避免在深度递归时的栈溢出问题。</p>
<h2 id="5-2-函数返回多个值"><a href="#5-2-函数返回多个值" class="headerlink" title="5.2 函数返回多个值"></a>5.2 函数返回多个值</h2><p>这一点和其它语言不大相同。下面用一个简单的 “除法” 函数举个例子，它的结果有商和余数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 函数签名 func(int,int) (int,int)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span> <span class="hljs-params">(a,b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(result,rem <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	result = a / b<br>	rem = a - b * result<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里存在两个形参列表，第一个是 “入参”，而第二个则是 “出参”。这是一个具名的 “出参” 列表，因此在函数体内可以通过 <code>=</code> 形式为返回值赋值，然后仅使用一个 <code>return</code> 关键字将 “出参” 列表返回 ( 该写法在 Go 语言中称之为 “裸返回” ) 。外界接受到的将是 “出参” 列表中赋好值的 <code>result</code> 和 <code>rem</code>  变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">result, rem := div(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<p>“出参” 列表的局部变量可以是匿名的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(a,b <span class="hljs-keyword">int</span>)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>&#123;<br>	result := a/b<br>	<span class="hljs-keyword">return</span> result,result * b<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果是这样的写法，那么在程序的结尾处，<code>return</code> 后面需要按照声明的类型顺序排列好返回值。</p>
<p>某个函数 <code>f</code> 的返回值可以是通过调用另一个 “出参” 列表相同的函数 <code>g</code> 获得的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 函数 f 和 g 具有相同的返回值列表。因此可以直接返回 g() 的调用结果。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-params">(r1,r2 <span class="hljs-keyword">int</span>)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> g() <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span><span class="hljs-params">(r1,r2 <span class="hljs-keyword">int</span>)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure>

<p>再或者，如果函数 <code>f</code> 的 “出参” 列表和函数 <code>g</code> 的 “入参” 列表一致，那么可以直接将函数 <code>f</code> 作为形参传递到函数 <code>g</code> 中去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 函数 f 的出参和 g 的入参相对应，因此函数 f 可以直接作为函数 g 的形参。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-params">(r1,r2 <span class="hljs-keyword">int</span>)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> r1,r2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">(r1,r2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> r1 + r2&#125;<br><span class="hljs-comment">// 可以在主函数中这样调用：</span><br>b g(f())<br></code></pre></td></tr></table></figure>

<h2 id="5-3-变长函数"><a href="#5-3-变长函数" class="headerlink" title="5.3 变长函数"></a>5.3 变长函数</h2><p>变长函数指某个函数的<strong>最后一个参数是可变长度的</strong>，这在其它语言中也十分常见。在 Go 语言中，它这样表示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moreInt8s</span> <span class="hljs-params">(aInt <span class="hljs-keyword">int8</span>,int8s ...<span class="hljs-keyword">int8</span>)</span></span>&#123;<br>	<span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，<code>int8...</code> 表示 <code>int8s</code> 参数可能表示一个多个 <code>int8</code> 类型的值。在函数内部，这个变长的参数将<strong>被视作</strong>一个切片被处理，因此可以使用 <code>for</code> 循环去遍历它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moreInt8s</span><span class="hljs-params">(int8s ...<span class="hljs-keyword">int8</span>)</span></span>&#123;<br>	fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>,int8s)<br>	<span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> int8s &#123; fmt.Println(v)&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>尽管如此，它和下面的函数 <code>someInt8s</code> 仍然被视作是两类函数，因为它们的函数签名并不相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>	<span class="hljs-comment">//func([]int8)</span><br>	fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>,someInt8s)<br>	<br>	<span class="hljs-comment">//func(...int8)</span><br>	fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>,moreInt8s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moreInt8s</span><span class="hljs-params">(int8s ...<span class="hljs-keyword">int8</span>)</span></span>&#123;<br>	fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>,int8s)<br>	<span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> int8s &#123; fmt.Println(v)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">someInt8s</span><span class="hljs-params">(int8s []<span class="hljs-keyword">int8</span>)</span></span>&#123;<br>	fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>,int8s)<br>	<span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> int8s &#123; fmt.Println(v)&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此不可以直接将一个切片传递到变长函数内：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">ints := []<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br>moreInt8s(ints)<br></code></pre></td></tr></table></figure>

<p>但是有一个语法糖可以解决这个需求：将传入的切片后边加上 <code>...</code> 表示将这个切片视作是变长参数传递到函数内部。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">ints := []<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br>moreInt8s(ints...)<br></code></pre></td></tr></table></figure>

<h2 id="5-4-函数即变量"><a href="#5-4-函数即变量" class="headerlink" title="5.4 函数即变量"></a>5.4 函数即变量</h2><p>函数可以作为变量而被直接声明。下面的代码块创建了一个匿名函数 ( 或者称表达式 ) ，它被赋值给了变量 <code>f</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这个函数将数值 x2。</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int8</span>)</span> <span class="hljs-title">int8</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*i&#125;<br><br><span class="hljs-comment">// 4.</span><br>fmt.Println(f(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>

<p>匿名函数的声明方式是：首先给定一个<strong>函数签名</strong>，然后跟上一个由 <code>&#123;&#125;</code> 括起来的语句块，语句块内的 <code>return</code> 内容取决于函数签名。<strong>注意，如果匿名函数要进行递归，形式上必须先将这个匿名函数赋值给变量，然后通过调用这个变量来实现递归。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> factorial <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int8</span>)</span> <span class="hljs-title">int8</span></span><br><br><span class="hljs-comment">// 通过匿名函数实现的阶乘函数</span><br>factorial = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-keyword">int8</span>)</span> <span class="hljs-title">int8</span></span> &#123;<br>   <span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">1</span> &#123;<br>      <span class="hljs-keyword">return</span> n * factorial(n<span class="hljs-number">-1</span>)<br>   &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>   &#125;<br>&#125;<br><br>fmt.Print(factorial(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure>

<p>任何一个将函数视作一等公民的编程语言都很容易实现高阶函数，或者是一个被柯里化的函数。比如说下面的 <code>foreach</code> 算子 ( 一个最简单的 Monad )  接收另一个函数 <code>to</code> 对 <code>[]int8</code> 进行转换操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// foreach 是一个高阶函数，它接收另一个函数 to 对 ints 切片做变换。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foreach</span><span class="hljs-params">(ints *[]<span class="hljs-keyword">int8</span>,to <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int8</span>)</span> <span class="hljs-title">int8</span>)</span>&#123;<br>	<span class="hljs-keyword">for</span> i,v := <span class="hljs-keyword">range</span> *ints&#123;<br>		(*ints)[i] = to(v)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再比如说，通过函数柯里化在 Go 语言内实现了 “伪” <code>while</code> 循环。这里将条件语句抽象成了 <code>func() bool</code> 函数，而内部的循环体语句块抽象成了 <code>func ()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">While</span><span class="hljs-params">(condition <span class="hljs-keyword">func</span>()</span> <span class="hljs-title">bool</span>) <span class="hljs-title">func</span><span class="hljs-params">(block <span class="hljs-keyword">func</span>()</span>)</span>&#123;<br>	<br>	<span class="hljs-comment">// 外部的 While 函数相当于内部函数 _while_ 的闭包。</span><br>	<span class="hljs-keyword">var</span> _while_  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">func</span>()</span>)</span><br><br>	<span class="hljs-comment">// 1. 这是一个没有任何返回值的尾递归函数，因此它可以被调用任意的深度。</span><br>	<span class="hljs-comment">// 2. 对于这个匿名函数而言，condition() 是一个自由变量，因为它不受 _while() 的控制。</span><br>	_while_ = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-keyword">func</span>()</span>)</span> &#123;<br>		<span class="hljs-keyword">if</span> condition() &#123;b();_while_(b)&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> _while_<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用它的方式是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	想象它是这样的语句：</span><br><span class="hljs-comment">	while(flag &lt; 100)&#123;</span><br><span class="hljs-comment"> 		flag ++</span><br><span class="hljs-comment">		fmt.Print(...)</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">	flag 在 while(...) 语句的作用域外，while 内部通过副作用修改 flag 的值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> flag = <span class="hljs-number">1</span><br>While(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> flag &lt; <span class="hljs-number">100</span><br>&#125;)(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    flag++<br>    fmt.Printf(<span class="hljs-string">&quot;loop :[%v/100]\n&quot;</span>,flag)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="5-5-延迟调用函数-defer"><a href="#5-5-延迟调用函数-defer" class="headerlink" title="5.5 延迟调用函数 defer"></a>5.5 延迟调用函数 defer</h2><p>这里引入一个新的关键字 <code>defer</code>。跟在 <code>defer</code> 关键字后面的函数调用会在外界执行并返回 ( 无论是正常 <code>return</code> 还是因为异常情况而宕机 ) 之后才会被<strong>执行</strong>。这里举一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testDefer</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;after&quot;</span>)<br>	fmt.Println(<span class="hljs-string">&quot;before&quot;</span>)<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>按照一般的顺序执行逻辑，<code>after</code> 应该先于 <code>before</code> 被打印到控制台。但是 <code>defer</code> 声明使得打印 <code>after</code> 的输出语句推迟到 <code>testDefer()</code> <strong>返回之后才执行</strong>，实际上控制台的打印顺序将是：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">before</span><br><span class="hljs-keyword">after</span><br></code></pre></td></tr></table></figure>

<p>下面通过一个示例来介绍什么场合下适合使用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openFile</span><span class="hljs-params">()</span></span>&#123;<br>	open, err := os.Open(<span class="hljs-string">&quot;C:\\Users\\i\\go\\src\\awesomeProject\\vars\\a.go&quot;</span>)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatal(err.Error())<br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>	fmt.Printf(open.Name())<br>	<span class="hljs-comment">// 假定 Close() 是一定执行成功的。</span><br>	_ = open.Close()<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段程序会因 <code>err</code> 出现两种 <code>return</code> 行为：在正常打开文件的情况下，程序将打印出文件名，释放资源并退出；否则。打印错误信息而直接退出。这并不是一段严谨的代码，因为当程序出现错误时，它不会执行到 <code>_ = open.Close()</code>。这样会到导致 <code>open</code> 指向的文件地址就不能够被回收重用 ( 内存泄漏 ) 。</p>
<p>使这段逻辑更健壮的做法是：在判 <code>err</code> 非空的语句块内补充上 <code>Close()</code> 语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openFile</span><span class="hljs-params">()</span></span>&#123;<br>	open, err := os.Open(<span class="hljs-string">&quot;C:\\Users\\i\\go\\src\\awesomeProject\\vars\\a.go&quot;</span>)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatal(err.Error())<br>		_ = open.Close()<br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>	fmt.Printf(open.Name())<br>	_ = open.Close()<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>进一步，很容易联想到：在逻辑更加复杂的函数当中，为了及时地释放资源，我们必须手动在所有会使程序短路退出的语句块内都补充 <code>Close()</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> con1() &#123;<br>    <span class="hljs-comment">//...</span><br>    _ = open.Close()<br>    <span class="hljs-keyword">return</span><br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <br>    _ = open.Close()<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> con2() &#123;<br>    _ = open.Close()<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br>....<br></code></pre></td></tr></table></figure>

<p>而 <code>defer</code> 则保证了某个函数调用只会在被 <code>return</code> 之后执行 ( 不管是在何处 <code>return</code> ，哪怕是因为因为宕机 )，现在 <code>Close()</code> 函数只需要写一次。从逻辑上来看，它的功能类似于一个 “<code>finally</code> “ 语句块，或者将其理解成创建了类似 AOP 的 <code>after(..)</code> 切面也可以。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openFile</span><span class="hljs-params">()</span></span>&#123;<br>	open, err := os.Open(<span class="hljs-string">&quot;C:\\Users\\i\\go\\src\\awesomeProject\\vars\\a.go&quot;</span>)<br>	<span class="hljs-comment">// 无后顾之忧, 因为它总是在 openFile() 返回之后执行.</span><br>    <span class="hljs-comment">// defer 后面只能跟进函数调用，这意味着该写法下 open.Close() 的返回值被忽略了。</span><br>	<span class="hljs-keyword">defer</span> open.Close()<br>	<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatal(err.Error())<br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>	fmt.Printf(open.Name())<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>defer</code> 在需要成对操作的场合会很有用：比如某个连接的握手和断开，资源的打开和关闭，同步锁的加锁和放锁。利用它可以有效保证某些资源总是在函数运行之后就会被释放，而和具体的逻辑无关。</p>
<p><strong>延迟调用函数可以接收返回值列表并操作，比如修改它的值</strong> ( 但这并不是 <code>defer</code> 本身的特性，这实际上是通过函数闭包达到的效果 ) 。除此之外，<code>defer</code> 后面可以直接跟进一个对匿名函数的<strong>调用</strong>，但是写法上要注意一点，匿名函数声明之后一定要主动带上 <code>()</code> 括起来的参数列表，表示 “声明且调用” 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 示例1，接收返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span> <span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(result <span class="hljs-keyword">int</span>)</span></span>&#123;<br>	<span class="hljs-comment">// 利用 defer 实现日志记录操作：</span><br>	<span class="hljs-keyword">defer</span> log.Printf(<span class="hljs-string">&quot;the reuslt is %v&quot;</span>,result)<br>	result = a + b<br>	<span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 示例2，在得到 add2 的返回值之后更改它，以此改变调用该函数得到的最终结果。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add2</span><span class="hljs-params">(a,b <span class="hljs-keyword">int8</span>)</span> <span class="hljs-params">(result <span class="hljs-keyword">int8</span>)</span></span> &#123;<br><br>	result = a+b<br>	<br>	<span class="hljs-comment">// 这里延迟调用的是一个匿名函数，可以利用它去承载一个语句块，</span><br>    <span class="hljs-comment">// 因为一段语句块可以被抽象成无入参且无返回值的 func() 。</span><br>    <span class="hljs-comment">// 后面必须要再加上一个() 来表示这是一个函数的 (延迟) 调用。</span><br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		result += <span class="hljs-number">1</span><br>	&#125;()<br>	<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-5-1-多个-defer-调用会倒序执行"><a href="#5-5-1-多个-defer-调用会倒序执行" class="headerlink" title="5.5.1 多个 defer 调用会倒序执行"></a>5.5.1 多个 defer 调用会倒序执行</h3><p>一个函数内部可以有任意多个 <code>defer</code> 延迟调用，它们在函数 <code>return</code> 之后按照声明的<strong>倒序</strong>执行，可以想象成：每一个 <code>defer</code> 调用都是将一个延迟调用的函数压入了一个栈内存储，函数 <code>reuturn</code> 之后的 “善后” 工作，是通过从这个栈中不断 <code>pop</code> 并执行的。</p>
<p>这是出于 “先打开的资源后关闭 “ 的角度考量的。举个例子来说，我们生活中正常开机并工作的顺序是这样的：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">(<span class="hljs-number">1</span>) <span class="hljs-keyword">Open</span> PC =&gt; (<span class="hljs-number">2</span>) <span class="hljs-keyword">Open</span> OS =&gt; (<span class="hljs-number">3</span>) Start Coding<br></code></pre></td></tr></table></figure>

<p>等到下班时，是 “先关电脑后保存文件”，还是 “先保存文件再关电脑” 呢？显然答案是后者。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><code class="hljs lisp">(<span class="hljs-number">3</span>) Shut Down PC &lt;= (<span class="hljs-number">2</span>) Shut Down OS &lt;= (<span class="hljs-number">1</span>) Commit Code<br></code></pre></td></tr></table></figure>

<p>另一方面，程序员习惯于 “在局部代码块内关闭最近使用过的资源”，因此代码结构更倾向于这个样子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一段伪代码</span><br>&#123;<br>	os = pc.Open()<br>	<span class="hljs-keyword">defer</span> pc.Close()<br>	<br>	<span class="hljs-keyword">if</span> os != <span class="hljs-literal">nil</span> &#123;<br>		app = os.open()	<br>         <span class="hljs-keyword">defer</span> os.Close()<br>		<br>        <span class="hljs-keyword">if</span> app != <span class="hljs-literal">nil</span> &#123;<br>            app.Coding()									<br>            <span class="hljs-keyword">defer</span> app.Git()<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从声明的层次顺序来看，<code>pc.Close()</code> 是最 “前面的”。假使程序按照 <code>defer</code> 声明的顺序逐个关闭资源，那么显然依赖于 <code>pc</code> 的 <code>os.Close()</code> 和 <code>app.Git()</code> 都会因为 <code>pc.Close()</code> 提前执行而导致出现 “空指针异常” 。因此 Go 干脆将 <code>defer</code> 设计成 FILO 的栈结构，让程序员保持习惯的同时，让资源也能够被正确地按顺序关闭。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 程序总是输出 123 而非 321.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testDefer</span><span class="hljs-params">()</span></span> &#123;<br>	a, b, c := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br>	<span class="hljs-keyword">if</span> a == <span class="hljs-number">1</span> &#123;<br>		<span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;3&quot;</span>)<br>		<span class="hljs-keyword">if</span> b == <span class="hljs-number">2</span> &#123;<br>			<span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;2&quot;</span>)<br>			<span class="hljs-keyword">if</span> c == <span class="hljs-number">3</span> &#123;<br>				<span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;1&quot;</span>)<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-5-2-defer-延迟调用函数的赋参时机"><a href="#5-5-2-defer-延迟调用函数的赋参时机" class="headerlink" title="5.5.2 defer 延迟调用函数的赋参时机"></a>5.5.2 defer 延迟调用函数的赋参时机</h3><p>我们传统印象中的 “函数调用” 就是 “传参并执行” 的连续操作，但是对于 <code>defer</code> 声明的延迟函数调用而言，这个过程被分开了：传参过程早在程序执行到 <code>defer</code> 声明时就已经完成，<strong>只有执行函数体的过程被推迟了</strong>。</p>
<p>这是一个简单的验证：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testDefer</span><span class="hljs-params">()</span></span> &#123;<br>   a := <span class="hljs-number">1</span><br>   <span class="hljs-comment">// a 在程序执行到这条 defer 声明时就被赋值给了 fmt.Print(..) 函数，显然此刻的 a == 1 ，传入函数的形参值也是 1。</span><br>   <span class="hljs-keyword">defer</span> fmt.Print(a)<br><br>   <span class="hljs-comment">// 因此，后续的代码块无论对 a 做何修改，最终控制台打印的结果仍然是 1 .</span><br>   a += <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面的例子巧妙地利用了这个特性，通过计算 <code>defer</code> 延迟调用函数从 “被赋值” 到 “被执行” 的这段时间差 (delta time) 来测量另一个函数的执行耗时。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这个例子中用到了 Go 的官方库 time：</span><br><span class="hljs-comment">// time.Time 		=&gt; time 包中通用的，表示 &quot;时间&quot; 的类型。</span><br><span class="hljs-comment">// time.Since(..)	=&gt; 计算从现在到过去某一个时间的时间差。</span><br><span class="hljs-comment">// time.Now()		=&gt; 生成当前时间。</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(before time.Time)</span></span>&#123;<br>	log.Printf(<span class="hljs-string">&quot;takes time:%s&quot;</span>,time.Since(before))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>想要使用它测试某个函数的执行时间，只要在此函数的开头部分通过 <code>defer</code> “设下埋点” 就可以了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openFile</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">defer</span> trace(time.Now())<br>	<span class="hljs-comment">//..openFile() 的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面的例子则是更 “花哨” 的版本，因为它是配合函数闭包来使用的 <code>defer</code> 延迟调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这个函数用于测试并记录某个程序的运行时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">()</span> <span class="hljs-params">(deltaTime <span class="hljs-keyword">func</span>()</span>)</span> &#123;<br>    <span class="hljs-comment">// time 是官方库，Now() 函数可以获取当前时间</span><br>	start := time.Now()<br>	<span class="hljs-comment">// Since(...) 函数可以获取当前时间到传入时间的这段时间差。</span><br>    deltaTime = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;log.Printf(<span class="hljs-string">&quot;takes time:%s&quot;</span>,time.Since(start))&#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这相当于将真正希望推迟执行的函数 ( 暂且称之为 “目标函数” ) 以及依赖的参变量提取到了另一个高阶函数内，实现了 “打包” 的效果 ( 它确实就叫 “闭包” )。这样，<code>defer</code> 只需要简单地调用这个高阶函数就可以直接完成一系列复杂的初始化步骤，然后拿到目标函数<strong>等待被延迟调用</strong>。</p>
<p>使用它测试某个函数的执行时间，写法是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> trace()()<br></code></pre></td></tr></table></figure>

<p>这里有两层 <code>()</code> 小括号的原因是：在这里期望延迟调用的是 <code>trace()</code> 函数返回的 <code>deltaTime()</code> ，而不是 <code>trace()</code> 函数本身。</p>
<p>当传入的参数需要一系列更加复杂的计算时，显然不太可能只通过一行 <code>defer</code> 声明将复杂工作全部完成 ，此时需要将这一系列操作打包到一个匿名函数调用，或者是直接使用具名的高阶函数。</p>
<p>下面的例子演示了如何利用 <code>defer</code> 做一个环绕型通知：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">defer</span> AOP()()<br>	log.Printf(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AOP</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br><br>	<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>		log.Printf(<span class="hljs-string">&quot;before ...&quot;</span>)<br>	&#125;()<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>		log.Printf(<span class="hljs-string">&quot;after ...&quot;</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序的运行结果将是：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2021</span>/<span class="hljs-number">03</span>/<span class="hljs-number">07</span> <span class="hljs-number">16</span>:<span class="hljs-number">56</span>:<span class="hljs-number">59</span> before ...<br><span class="hljs-attribute">2021</span>/<span class="hljs-number">03</span>/<span class="hljs-number">07</span> <span class="hljs-number">16</span>:<span class="hljs-number">56</span>:<span class="hljs-number">59</span> hello<br><span class="hljs-attribute">2021</span>/<span class="hljs-number">03</span>/<span class="hljs-number">07</span> <span class="hljs-number">16</span>:<span class="hljs-number">56</span>:<span class="hljs-number">59</span> after ...<br></code></pre></td></tr></table></figure>

<h2 id="5-6-循环内的匿名函数共享迭代遍历地址"><a href="#5-6-循环内的匿名函数共享迭代遍历地址" class="headerlink" title="5.6 循环内的匿名函数共享迭代遍历地址"></a>5.6 循环内的匿名函数共享迭代遍历地址</h2><blockquote>
<p>原版的 《 Go 程序设计语言》 函数章节的 警告：捕获迭代变量 段落使用了较为复杂的案例做陈述，这里笔者做了简化。</p>
</blockquote>
<p>通过循环语句创建出的多个匿名函数，它们将共享迭代变量 ( 如下面代码块的 <code>i</code> 和 <code>v</code> ) 的地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这个循环将创建出 三个匿名函数副本，它们将共享循环变量 i,v 的地址。</span><br><span class="hljs-comment">// 在有些情况下，这会导致一些预料之外的错误。</span><br><span class="hljs-keyword">for</span> i,v := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; &#123;<br>    <span class="hljs-comment">// 注意，这个表达式声明后面带上了参数列表()，表示声明并且调用。</span><br>   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>      fmt.Printf(<span class="hljs-string">&quot;index is %v and the value is %v\n&quot;</span>,i,v)<br>   &#125;()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行代码，看起来没有任何问题：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">index</span> <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> and the value <span class="hljs-keyword">is</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">index</span> <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> and the value <span class="hljs-keyword">is</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">index</span> <span class="hljs-keyword">is</span> <span class="hljs-number">2</span> and the value <span class="hljs-keyword">is</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>现在换个做法：每创建出一个匿名函数，不立刻执行它，而是先将其暂存到一个 <code>[]func()</code> 切片内，等到循环结束之后再统一运行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> jobs []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">for</span> i,v := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; &#123;<br><br>    job := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>        fmt.Printf(<span class="hljs-string">&quot;index is %v and the value is %v\n&quot;</span>,i,v)<br>    &#125;<br>    jobs = <span class="hljs-built_in">append</span>(jobs,job)<br>&#125;<br><br><span class="hljs-keyword">for</span> _,job := <span class="hljs-keyword">range</span> jobs &#123;<br>    job()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>问题出现了。程序打印的是：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">index</span> <span class="hljs-keyword">is</span> <span class="hljs-number">2</span> and the value <span class="hljs-keyword">is</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">index</span> <span class="hljs-keyword">is</span> <span class="hljs-number">2</span> and the value <span class="hljs-keyword">is</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">index</span> <span class="hljs-keyword">is</span> <span class="hljs-number">2</span> and the value <span class="hljs-keyword">is</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>如果笔者用顺序结构复现上述代码的逻辑，它是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forBlock</span><span class="hljs-params">(Range []<span class="hljs-keyword">int8</span>)</span></span> &#123;<br><br>    <span class="hljs-comment">// 模拟 for 的迭代变量 //</span><br>    <span class="hljs-keyword">var</span> i <span class="hljs-keyword">int8</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> v <span class="hljs-keyword">int8</span> = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">// 第一次迭代</span><br>    v = Range[i]<br>    expr1 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;index is %v and the value is %v\n&quot;</span>, i, v)<br>    &#125;<br><br>    <span class="hljs-comment">// 第二次迭代</span><br>    i++<br>    v = Range[i]<br>    expr2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;index is %v and the value is %v\n&quot;</span>, i, v)<br>    &#125;<br><br>    <span class="hljs-comment">// 第三次迭代</span><br>    i++<br>    v = Range[i]<br>    expr3 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;index is %v and the value is %v\n&quot;</span>, i, v)<br>    &#125;<br><br>    <span class="hljs-comment">// 模拟从刚才的 jobs 当中读取每一个 job() 执行</span><br>    expr1()<br>    expr2()<br>    expr3()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以这么理解，在刚才的 for 循环中，三个匿名函数其实全部处于一个闭包下 ( 在这里你可以理解为它们都在一个大的 <code>forBlock</code> 函数内部 ) ，它们内部的自由变量 <code>i</code> 和 <code>v</code> 其实是全部指向了最开始声明的那两个 <code>i</code> 和 <code>v</code> 变量。</p>
<p>那为什么在本节的最开始，程序是按既定的规则输出的？原因就在于之前的匿名函数是 “边声明边调用的”。这样，即便是 <code>i</code> 和 <code>v</code> 被改动了，它也不会影响到已经执行完毕的结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forBlock</span><span class="hljs-params">(Range []<span class="hljs-keyword">int8</span>)</span></span> &#123;<br><br>   <span class="hljs-comment">// 模拟 for 的迭代变量 //</span><br>   <span class="hljs-keyword">var</span> i <span class="hljs-keyword">int8</span> = <span class="hljs-number">0</span><br>   <span class="hljs-keyword">var</span> v <span class="hljs-keyword">int8</span> = <span class="hljs-number">0</span><br><br>   <span class="hljs-comment">// 第一次迭代,这个匿名函数已经创建被执行完了，后续 i,v 的更改和它无关。</span><br>   v = Range[i]<br>   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;index is %v and the value is %v\n&quot;</span>, i, v)<br>   &#125;()<br><br>   <span class="hljs-comment">// 第二次迭代</span><br>   i++<br>   v = Range[i]<br>   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;index is %v and the value is %v\n&quot;</span>, i, v)<br>   &#125;()<br><br>   <span class="hljs-comment">// 第三次迭代</span><br>   i++<br>   v = Range[i]<br>   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;index is %v and the value is %v\n&quot;</span>, i, v)<br>   &#125;()<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-7-错误处理"><a href="#5-7-错误处理" class="headerlink" title="5.7 错误处理"></a>5.7 错误处理</h2><p>我们在之前已经见识过 Go 标准库如何利用函数返回多值的特性来实现 “抛出异常”：通常前者是期望的计算结果，后者则是实现了 <code>Error</code> 接口的返回值。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">file,err := os.Open(<span class="hljs-string">&quot;/usr/share/music.mp3&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>Go 没有像其它语言一样设计类似 <code>try</code> … <code>catch</code> … <code>fianlly</code> 的异常捕捉语句块，而是将异常视作是一个普通的值，我们因此只要简单地使用一个 <code>if</code> 语句块来捕获异常：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在 Go 语言中，通用的处理异常的办法。</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	log.Fatal(<span class="hljs-string">&quot;something was wrong!&quot;</span>)<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于捕获到的 <code>Error</code> 异常有两种处理策略，除了像上述代码块直接通过 <code>return</code> 退出程序以外，在面对一些 “因临时的不可抗力导致的异常” 时，如请求的资源正在被加锁，或因当时的网络状态差导致请求网络资源失败等情况，更合理的做法是选择有限地重试，直到超出重试次数或等待时间为止，而不应该是立刻退出程序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> *<span class="hljs-title">http</span>.<span class="hljs-title">Response</span></span> &#123;<br>   <span class="hljs-comment">// 设置超时等待时间</span><br>   limitTime :=  <span class="hljs-number">1</span> * time.Minute<br>   ddl := time.Now().Add(limitTime)<br>   <br>   <span class="hljs-comment">// 如果失败，则该程序通过退避策略不断重试。</span><br>   <span class="hljs-keyword">for</span> tries:=<span class="hljs-number">0</span>;time.Now().Before(ddl);tries++&#123;<br>      resp,err := http.Get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         <br>         <span class="hljs-comment">// 每失败一次，就退避更长时间重试。</span><br>         time.Sleep(time.Second &lt;&lt; tries)<br>         <span class="hljs-keyword">continue</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> resp<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-8-宕机"><a href="#5-8-宕机" class="headerlink" title="5.8 宕机"></a>5.8 宕机</h2><p>Go 语言的类型系统会捕获异常错误，但是有些错误只能在运行期间进行检查，比如数组是否进行了越界访问，或者引用了一个空指针。这些错误是严重的内部错误，因此它们会导致程序宕机。</p>
<p>一旦发生宕机，程序就相当是立刻 <code>return</code> 返回， <code>defer</code> 声明的调用会开始执行，并且在最后留下异常退出的日志消息。和抛出一个 <code>Error</code> 异常不同，宕机时输出的日志包含了完整的栈跟踪消息，我们通常可以借助它来排查代码出错的原因。</p>
<p>并不是所有的宕机都是程序运行时的内部错误，比如可以主动通过 <code>panic(...)</code> 函数的方式来触发一个宕机，该函数可以接收任何值。发生宕机通常是意味着 “遇到了比 <code>Error</code> 还棘手的麻烦”—— 只有出现<strong>一些逻辑上不应该出现的，或者是预料之外的错误</strong>时才应该使用它。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">str := <span class="hljs-string">&quot;go1&quot;</span><br><span class="hljs-keyword">switch</span> str &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;go&quot;</span>:<br>    	fmt.Print(<span class="hljs-string">&quot;hello,go&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;java&quot;</span>:<br>    	fmt.Print(<span class="hljs-string">&quot;hello,java&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;c&quot;</span>:<br>    	fmt.Print(<span class="hljs-string">&quot;hello,c&quot;</span>)<br>    <span class="hljs-keyword">default</span>:<br>         <span class="hljs-comment">// 其实这个异常是可通过判断检查的，因此使用 Error 更合适一些。</span><br>    	<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;value of str should be one of : (go,java,c)&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发生宕机不一定会导致程序立刻退出，因为程序仍然可以在执行 <code>defer</code> 延迟调用函数时进行一步 “自救” —— 在延迟调用函数内可以通过调用 <code>recover()</code> 令程序回到正常状态。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	unsafe()<br>	<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;主函数正常执行并退出&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unsafe</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		err := <span class="hljs-built_in">recover</span>()<br>		log.Printf(<span class="hljs-string">&quot;unsafe 在执行时曾发生了一个严重的错误。%v\n&quot;</span>,err)<br>		bytes := [<span class="hljs-number">4096</span>]<span class="hljs-keyword">byte</span>&#123;&#125;<br>		runtime.Stack(bytes[:],<span class="hljs-literal">false</span>)<br>		s := <span class="hljs-keyword">string</span>(bytes[:])<br>		<span class="hljs-built_in">print</span>(s)<br>	&#125;()<br>	<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;错误信息&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>recover()</code> 函数还能够接受到 <code>panic(...)</code> 留下的错误信息并返回 ( 如果外部函数是正常执行并返回的，则该返回值为 <code>nil</code>) ，以便于程序员为分析代码错误留下线索。除此之外，本例通过 <code>runtime.Stack(...)</code> 函数主动向控制台输出了栈跟踪信息。</p>
<p>直接使用 <code>recover(...)</code> 的场合其实并不多，因为发生宕机意味着程序大概率将不能正常继续运行。</p>
<p>假设下面的函数用于检查用户名。文件内部定义了三个空结构体来表示错误类型 “字符过长”，”包含特殊字符”，”首字符非大写” ，它们均会导致宕机。延迟调用函数能够处理 “首字母非大写” 的情况并使程序恢复到正常状态。但如果是前两种情形，则延迟调用函数会重新进入宕机状态。</p>
<p>不过，这个例子虽然展现出了宕机和恢复的工作机制，但是违背了宕机不应该用于 “预期的错误” 的准则。更合理的做法是将 “可预料的错误” 当作 <code>Error</code> 来处理或者是抛出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkName</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span></span> &#123;<br><br>   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      maybeErr := <span class="hljs-built_in">recover</span>()<br>      <span class="hljs-keyword">switch</span> maybeErr &#123;<br>      <span class="hljs-keyword">case</span> firstCharNotUpperException&#123;&#125;:<br><br>         lowerRune := []<span class="hljs-keyword">rune</span>(name)[<span class="hljs-number">0</span>]<br>         upperRune := unicode.ToUpper(lowerRune)<br>         strings.Replace(name, <span class="hljs-keyword">string</span>(lowerRune), <span class="hljs-keyword">string</span>(upperRune), <span class="hljs-number">1</span>)<br>         fmt.Print(<span class="hljs-string">&quot;按照要求，首字母被转换为了大写。&quot;</span>)<br>      <span class="hljs-keyword">default</span>:<br>         <span class="hljs-built_in">panic</span>(maybeErr)<br>      &#125;<br><br>   &#125;()<br><br>   <span class="hljs-comment">// 如果下面任何一个表达式匹配成功都会导致程序退出。</span><br>   <span class="hljs-keyword">switch</span> &#123;<br><br>   <span class="hljs-keyword">case</span> utf8.RuneCount([]<span class="hljs-keyword">byte</span>(name)) &gt; <span class="hljs-number">6</span>:<br>      <span class="hljs-built_in">panic</span>(toLongCharacterError&#123;&#125;)<br><br>   <span class="hljs-keyword">case</span> strings.ContainsAny(name, <span class="hljs-string">&quot;&lt;&gt;!?&amp;&quot;</span>):<br>      <span class="hljs-built_in">panic</span>(invalidCharacterError&#123;&#125;)<br><br>   <span class="hljs-keyword">case</span> unicode.IsUpper([]<span class="hljs-keyword">rune</span>(name)[<span class="hljs-number">0</span>]):<br>      <span class="hljs-built_in">panic</span>(firstCharNotUpperException&#123;&#125;)<br><br>   <span class="hljs-keyword">default</span>:<br>      fmt.Print(<span class="hljs-string">&quot;验证通过，上传数据库&quot;</span>)<br>   &#125;<br><br>&#125;<br><br><span class="hljs-keyword">type</span> toLongCharacterError <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">type</span> invalidCharacterError <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">type</span> firstCharNotUpperException <span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第六章-方法"><a href="#第六章-方法" class="headerlink" title="第六章 方法"></a>第六章 方法</h1><h2 id="6-1-方法声明"><a href="#6-1-方法声明" class="headerlink" title="6.1 方法声明"></a>6.1 方法声明</h2><p>方法声明和函数声明类似，但是在前面增加了参数。下面的代码块演示了 <code>Position</code> 类型的声明，以及针对该类型的测距方法 <code>distance(...)</code> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Position)</span> <span class="hljs-title">distance</span><span class="hljs-params">(q Position)</span></span>&#123;<br><br>	y := math.Abs(<span class="hljs-keyword">float64</span>(p.Y - q.Y))<br>	x := math.Abs(<span class="hljs-keyword">float64</span>(p.X - q.X))<br><br>	sqrt := math.Sqrt(x*x + y*y)<br>	fmt.Printf(<span class="hljs-string">&quot;%g&quot;</span>,sqrt)<br>	<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := Position&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>	q := Position&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br><br>    <span class="hljs-comment">//(this).op(that)</span><br>	p.distance(q)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种写法相当于是将 <code>distance(...)</code> 函数绑定到了 <code>p</code> 所属的类型上 ，称 <code>p</code> 是这个函数的<strong>接收者</strong>。值 <code>p</code> 语义上接近其它语言中的 “<code>this</code>“ 或者是 <code>&quot;self&quot;</code>，它代表了任意一个属于 <code>Position</code> 类的对象，而值 <code>q</code> 语义上是被操作数  “<code>that</code>“ 。</p>
<p>上述代码块的 <code>p.distance</code> 被称为是 <strong>选择子</strong>，可以简单理解成是 “调用了 <code>p</code> 对象的 <code>distance</code> 方法” 。<strong>方法名和字段名共享一个命名空间</strong>，这意味着 <code>Position</code> 类不能再包含名为 <code>Distance</code> 的字段；同样，也不能再声明一个名为 <code>X</code> 或 <code>Y</code> 的方法，否则编译器就会提示错误。</p>
<p>通过 <code>type</code> 定义的 “类型别称” 也可以绑定方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Paragraph []<span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// 这个方法适用于 Paragraph 类型，但是不适用于 []string 类型。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Paragraph)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> p &#123;<br>      fmt.Println(v)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>	paragraph := Paragraph&#123;<br>		<span class="hljs-string">&quot;hello world&quot;</span>,<br>		<span class="hljs-string">&quot;hello go&quot;</span>,<br>		<span class="hljs-string">&quot;hello scala&quot;</span>,<br>		<span class="hljs-string">&quot;hello java&quot;</span>,<br>	&#125;<br><br>	paragraph.read()<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-2-接收者可以为指针"><a href="#6-2-接收者可以为指针" class="headerlink" title="6.2 接收者可以为指针"></a>6.2 接收者可以为指针</h2><p>当一个结构体的数据量比较庞大时，最好使用指针，因为这样可以免去值复制的过程。下面的代码块是 <code>distance(..)</code> 方法的指针接收者版本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Position <span class="hljs-keyword">struct</span>&#123;X,Y <span class="hljs-keyword">int16</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Position)</span> <span class="hljs-title">distance_</span><span class="hljs-params">(q *Position)</span></span>&#123;<br><br>    <span class="hljs-comment">// 重点: (*p).X 可以直接写成 p.X。</span><br>    <span class="hljs-comment">// 这个语法糖带来的影响我们会在 接口 章节继续探讨。</span><br>	y := math.Abs(<span class="hljs-keyword">float64</span>(p.Y - q.Y))<br>	x := math.Abs(<span class="hljs-keyword">float64</span>(p.X - q.X))<br><br>	sqrt := math.Sqrt(x*x + y*y)<br>	fmt.Printf(<span class="hljs-string">&quot;%g&quot;</span>,sqrt)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>接收者的类型要么是一个命名类型，要么就是指向一个命名类型的指针，比如 <code>Position</code> 和 <code>*Position</code>。注意，如果一个 “类型别称” 指向一个指针，那它就不能充当接收者，下面演示了这个反例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PointOfPosition *Position<br><br><span class="hljs-comment">// 编译不通过。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p PointOfPosition)</span> <span class="hljs-title">distance</span><span class="hljs-params">(q PointOfPosition)</span></span>&#123;<br>	<span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当接收者为指针时，应格外注意调用该方法时的写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如果该变量本身是字面量，则需要使用 &amp; 号传地址。</span><br>p := Position&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;<br>q := Position&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;<br>(&amp;p).distance_(&amp;q)<br><br><br><span class="hljs-comment">// 如果该变量本身是指针，则可以省去 * 号。</span><br>l := &amp;Position&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;<br>k := &amp;Position&#123;<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;<br><br><span class="hljs-comment">// 等效于 (*l).distance_(k)</span><br>l.distance_(k)<br></code></pre></td></tr></table></figure>

<p>但是，<strong>如果想要通过调用方法来修改接收者自身成员的内容，此时的接收者必须为地址</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// import ...</span><br><span class="hljs-comment">// 在主函数中测试运行的结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>	position := Position&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br>	<span class="hljs-comment">// 没影响</span><br>	position.goLeft()<br>    fmt.Print(position)<br><br>	<span class="hljs-comment">// 有影响</span><br>	position.goRight()<br>	fmt.Print(position)<br><br>&#125;<br><br><span class="hljs-keyword">type</span> Position <span class="hljs-keyword">struct</span> &#123;<br>	X,Y <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// 注意，这个接收者是指针，这个修改会影响到接收者。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Position)</span> <span class="hljs-title">goRight</span><span class="hljs-params">()</span></span>  &#123;<br>   p.X += <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 这个接收者是命名类型，因此接收者接收的仍然只是一个值副本，换句话说，</span><br><span class="hljs-comment">// 执行这个方法不会影响到原接收者本身。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Position)</span> <span class="hljs-title">goLeft</span><span class="hljs-params">()</span></span>&#123;<br>   p.X -= <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-2-1-警惕接收者为-nil-的情况"><a href="#6-2-1-警惕接收者为-nil-的情况" class="headerlink" title="6.2.1 警惕接收者为 nil 的情况"></a>6.2.1 警惕接收者为 nil 的情况</h3><p>当方法的接收者是一个指针时，最好在方法体内加入判空的逻辑保证程序足够健壮。以上述的 <code>distance_(...)</code> 函数为例，如果用户无意间这样做了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *Position <br>q := &amp;Position&#123;<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;<br><br><span class="hljs-comment">// p =&gt; nil</span><br>(p).distance_(q)<br></code></pre></td></tr></table></figure>

<p>访问 <code>nil</code> 指针的成员会导致宕机：</p>
<p><code>panic: runtime error: invalid memory address or nil pointer dereference</code></p>
<p>最体面的解决方式是，当判断接收者为 <code>nil </code> 时，给出一个警告或返回 <code>Error</code>，避免访问空指针的成员。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Position)</span> <span class="hljs-title">distance_</span><span class="hljs-params">(q *Position)</span></span>&#123;<br><br>	<span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;warning: value p is a nil pointer.&quot;</span>);<span class="hljs-keyword">return</span>&#125;<br>	y := math.Abs(<span class="hljs-keyword">float64</span>(p.Y - q.Y))<br>	x := math.Abs(<span class="hljs-keyword">float64</span>(p.X - q.X))<br><br>	sqrt := math.Sqrt(x*x + y*y)<br>	fmt.Printf(<span class="hljs-string">&quot;%g&quot;</span>,sqrt)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>但有些情况下，接收者为 <code>nil</code> 仍然是有意义的。比如下面的例子定义了一个 <code>ListInt</code> 链表类型，它内部有统计长度的 <code>length()</code> 方法。该方法允许接收者 <code>p</code> 是一个 <code>nil</code> ，这将表明 “统计一个空链表的长度”，显然此时的返回值是 <code>0</code> 。</p>
<p>这里的 <code>ListInt</code> 是一个递归定义，因此 ( 包括后续的 ) 相关方法也尽可能采取尾递归的方式实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ListInt <span class="hljs-keyword">struct</span> &#123;<br>	v    <span class="hljs-keyword">int16</span><br>	tail *ListInt<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *ListInt)</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-title">int16</span></span> &#123;<br><br>	<span class="hljs-keyword">var</span> loop <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*ListInt, <span class="hljs-keyword">int16</span>)</span> <span class="hljs-title">int16</span></span><br><br>	loop = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(l *ListInt, acc <span class="hljs-keyword">int16</span>)</span> <span class="hljs-title">int16</span></span> &#123;<br>		<span class="hljs-keyword">switch</span> &#123;<br>		<span class="hljs-keyword">case</span> l == <span class="hljs-literal">nil</span>: &#123;<span class="hljs-keyword">return</span> acc&#125;<br>		<span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> loop(l.tail,acc+<span class="hljs-number">1</span>)<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> loop(l, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-comment">// 为了方便测试，这里给出其它的操作方法：</span><br><span class="hljs-comment">// append 方法接收一个元素，并返回被更改后的列表。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *ListInt)</span> <span class="hljs-title">append</span><span class="hljs-params">(x <span class="hljs-keyword">int16</span>)</span> *<span class="hljs-title">ListInt</span></span> &#123;<br><br>	<span class="hljs-keyword">if</span> l == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> &amp;ListInt&#123;x, <span class="hljs-literal">nil</span>&#125;<br>	&#125;<br><br>	p := l<br>	q := l<br>	<span class="hljs-keyword">for</span> p.tail != <span class="hljs-literal">nil</span> &#123;<br>		p = p.tail<br>	&#125;<br><br>	p.tail = &amp;ListInt&#123;x, <span class="hljs-literal">nil</span>&#125;<br>	<span class="hljs-keyword">return</span> q<br>&#125;<br><br><span class="hljs-comment">// appends 是 append 方法的变长参数版本，允许一次性添加多个元素，内部通过递归实现。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *ListInt)</span> <span class="hljs-title">appends</span><span class="hljs-params">(xs ...<span class="hljs-keyword">int16</span>)</span> *<span class="hljs-title">ListInt</span></span> &#123;<br><br>	<span class="hljs-keyword">var</span> loop <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(l *ListInt, xxs ...<span class="hljs-keyword">int16</span>)</span> *<span class="hljs-title">ListInt</span></span><br>	loop = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(l *ListInt, xxs ...<span class="hljs-keyword">int16</span>)</span> *<span class="hljs-title">ListInt</span></span> &#123;<br>		<span class="hljs-keyword">switch</span> &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(xxs) == <span class="hljs-number">0</span>:<br>			<span class="hljs-keyword">return</span> l<br>		<span class="hljs-keyword">default</span>:<br>			l = l.<span class="hljs-built_in">append</span>(xs[<span class="hljs-number">0</span>])<br>			xs = xs[<span class="hljs-number">1</span>:]<br>			<span class="hljs-keyword">return</span> loop(l, xs...)<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> loop(l, xs...)<br>&#125;<br><br><span class="hljs-comment">// toString 方法将列表转换成 &quot;1,2,3,4...&quot; 形式的字符串，以便查看内容。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *ListInt)</span> <span class="hljs-title">toString</span><span class="hljs-params">(sep <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br><br>	<span class="hljs-keyword">var</span> loop <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*ListInt, <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span><br><br>	loop = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(l *ListInt, buf <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>		<span class="hljs-keyword">switch</span> l &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br>			<span class="hljs-keyword">return</span> buf<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-keyword">return</span> loop(l.tail, buf+sep+strconv.Itoa(<span class="hljs-keyword">int</span>(l.v)))<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> strings.Replace(loop(l, <span class="hljs-string">&quot;&quot;</span>), sep, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-2-2-无法更改指针接收者的引用"><a href="#6-2-2-无法更改指针接收者的引用" class="headerlink" title="6.2.2 无法更改指针接收者的引用"></a>6.2.2 无法更改指针接收者的引用</h3><p>方法内对<strong>指针接收者的引用本身</strong>做任何 “重定向” 操作都不会产生任何作用。比如说下面的 <code>clear()</code> 方法试图将接受者重新指向一个 <code>nil</code> 来达到将非空列表 “清除” 的目的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *ListInt)</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	IDE 的警告：</span><br><span class="hljs-comment">	Assignment to method receiver propagates only to callees but not to callers</span><br><span class="hljs-comment">	Inspection info: Reports assignment to method receiver.</span><br><span class="hljs-comment">	When assigning a value to the method receiver it won&#x27;t be reflected outside of the method itself.</span><br><span class="hljs-comment">	Values will be reflected in subsequent calls from the same method.</span><br><span class="hljs-comment">	*/</span><br>	l = <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然而，通过实际运行代码证明，这个 <code>clear()</code> 并没有生效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">head := ListInt&#123;<span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>&#125;<br>head.appends(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br><br>head.clear()<br><br><span class="hljs-comment">// 长度非 0，说明 clear() 方法没起效果。</span><br><span class="hljs-built_in">println</span>(head.length())<br></code></pre></td></tr></table></figure>

<h2 id="6-3-通过结构体内嵌组合类型"><a href="#6-3-通过结构体内嵌组合类型" class="headerlink" title="6.3 通过结构体内嵌组合类型"></a>6.3 通过结构体内嵌组合类型</h2><p>相比 Java “is-a” 的 OOP 视角 ( 在这里主要是继承，多态 )，Go 则更倾向于使用 “has-a” 的逻辑去表达。在下面的示例中，有三个类型以及相关方法 <code>Item</code>，<code>Position</code> 和 <code>Atlas</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Atlas <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// 相当于 Atlas 本身具备了 Name, X, Y 成员。</span><br>	Item<br>	Position<br>&#125;<br><br><span class="hljs-keyword">type</span> Item <span class="hljs-keyword">struct</span> &#123;<br>	Name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Position <span class="hljs-keyword">struct</span> &#123;<br>	X,Y <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Atlas)</span> <span class="hljs-title">PinPoint</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;Position(%v) has a (%v)&quot;</span>, a.Position, a.Name)<br>&#125;<br><br><span class="hljs-comment">// Distance 方法的指针版本，接收者和参数都是指针。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Position)</span> <span class="hljs-title">DistanceP</span><span class="hljs-params">(q *Position)</span> <span class="hljs-params">(d <span class="hljs-keyword">float64</span>)</span></span> &#123;<br>	sqrt := math.Sqrt<br>	abs := math.Abs<br>	p2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> &#123;<br>		<span class="hljs-keyword">return</span> math.Pow(x, <span class="hljs-number">2</span>)<br>	&#125;<br><br>	x1 := p2(abs(<span class="hljs-keyword">float64</span>(p.X - q.X)))<br>	y1 := p2(abs(<span class="hljs-keyword">float64</span>(p.Y - q.Y)))<br><br>	d = sqrt(x1 + y1)<br>	<span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// Distance 方法的值传递版本。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Position)</span> <span class="hljs-title">DistanceV</span><span class="hljs-params">(q Position)</span> <span class="hljs-params">(d <span class="hljs-keyword">float64</span>)</span></span>&#123;<br>	sqrt := math.Sqrt<br>	abs := math.Abs<br>	p2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> &#123;<br>		<span class="hljs-keyword">return</span> math.Pow(x, <span class="hljs-number">2</span>)<br>	&#125;<br><br>	x1 := p2(abs(<span class="hljs-keyword">float64</span>(p.X - q.X)))<br>	y1 := p2(abs(<span class="hljs-keyword">float64</span>(p.Y - q.Y)))<br><br>	d = sqrt(x1 + y1)<br>	<span class="hljs-keyword">return</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i *Item)</span> <span class="hljs-title">Info</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;the name of this item: %s&quot;</span>, i.Name)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，<code>Atlas </code> 相当于组合了 <code>Item</code> 和 <code>Position</code> ，或者说 <code>Item</code> 和 <code>Position</code> 被纳入到 <code>Atlas</code> 类型中。这样做的结果是，<code>Atlas</code> 获得了这两个类型的方法和成员：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">atlas := Atlas&#123;<br>    Item:     Item&#123;<span class="hljs-string">&quot;Apple&quot;</span>&#125;,<br>    Position: Position&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 实际上是，atlas.Position.Distance(...)</span><br>fmt.Println(atlas.Distance(&amp;Position&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;))<br><br><span class="hljs-comment">// 实际上是，atlas.Item.Name(...)</span><br>fmt.Println(atlas.Name)<br></code></pre></td></tr></table></figure>

<p>不过值得注意的是，无论是对于 <code>Distance</code> 方法和 <code>Name</code> 方法，它们的接收者类型始终不变。Go 编译器相当于做了一步适配工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Atlas)</span> <span class="hljs-title">Distance</span><span class="hljs-params">(q *Position)</span> <span class="hljs-title">float64</span></span> &#123;<br>	p.Position.Distance(q)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-4-方法变量"><a href="#6-4-方法变量" class="headerlink" title="6.4 方法变量"></a>6.4 方法变量</h2><p>在上述代码中，选择子 <code>atlas.Distance</code> 可以像匿名函数一样赋值给一个变量，这个变量称之为方法变量。<strong>它本质上是一个已经指派好接收者的函数</strong>。再或者可以理解成：<code>atlas</code> 是当前 <code>Distance</code> 函数的 “闭包”，这个函数依赖的自由变量是 <code>atlas</code> 的成员。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">atlas := Atlas&#123;<br>    Item:     Item&#123;<span class="hljs-string">&quot;Apple&quot;</span>&#125;,<br>    Position: Position&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>&#125;<br><br>distanceFromA := atlas.Distance<br><span class="hljs-comment">// 是否有点函数柯里化的既视感？</span><br>fmt.Println(distanceFromA(&amp;Position&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;))<br></code></pre></td></tr></table></figure>

<p>由此可以进一步理解，方法是一种自带闭包的特殊函数，只是保存状态的职责交给了对象，而不再是另一个高阶函数。在 Go 语言中，方法类型和去掉接收者的函数类型完全一致。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">atlas := Atlas&#123;<br>    Item:     Item&#123;<span class="hljs-string">&quot;Apple&quot;</span>&#125;,<br>    Position: Position&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>&#125;<br><br>distanceFromA := atlas.Distance<br><br><span class="hljs-comment">//func(*main.Position) float64，和去掉接收者之后的函数类型一致。</span><br>fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>,distanceFromA)<br></code></pre></td></tr></table></figure>

<p>一方面，如果想以 “面向对象” 的角度实现柯里化，又或者是想简化调用的表达式，方法变量会变得特别有用。另外一方面，如果想用一个符号 ( 变量 ) 来表达多个同种类型的方法，它也可以派上用场。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Calculator <span class="hljs-keyword">struct</span> &#123;<br>	a,b <span class="hljs-keyword">int</span><br>	ifAdd <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-comment">// 方法的类型仍然是 func() int</span><br><span class="hljs-comment">// 这个方法将两个成员 a，b 相加。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Calculator)</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">return</span> c.a + c.b<br>&#125;<br><br><span class="hljs-comment">// 方法的类型仍然是 func() int</span><br><span class="hljs-comment">// 这个方法将两个成员 a，b 相减。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Calculator)</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">return</span> c.a - c.b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Calculator)</span> <span class="hljs-title">do</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-comment">// func() int 在此处代表了 Calculator 的一个可能的方法。</span><br>	<span class="hljs-comment">// 其实，抛出语境来看，op 可以是函数变量，也可以是方法变量，这取决于你如何为它赋值。</span><br>	<span class="hljs-keyword">var</span> op <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span><br>	<span class="hljs-keyword">if</span> c.ifAdd &#123;<br>		<span class="hljs-comment">// c.add 是一个方法变量。</span><br>		op = c.add<br>	&#125;<span class="hljs-keyword">else</span> &#123;<br>		op = c.sub<br>	&#125;<br>	<span class="hljs-keyword">return</span> op()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果选择子的 <code>.</code> 操作符前面不是某个具体变量，而是命名类型 ( 或对应的指针类型 )，则它是一个<strong>方法表达式</strong>，如：<code>Atlas.DistanceV</code>，<code>(*Atlas).DistanceP</code>。想要调用一个方法表达式，需要同时传入接收者和参数列表。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 选择子的 . 符号前面是命名类型(以及指针)，而非某个具体的变量。</span><br><span class="hljs-comment">// 因此，distanceByPointer 和 distanceByValue 被称作是方法表达式。</span><br><span class="hljs-comment">// distanceByPointer 要求接收者是 Atlas 类型，而后者要求 *Atlas 类型。这取决于方法中定义的接收者是值还是指针地址。</span><br>distanceByPointer := Atlas.DistanceV<br>distanceByValue := (*Atlas).DistanceP<br><br><span class="hljs-comment">// 使用方式发生了变化，使用方法表达式需要首先传入接收者，然后再传入后续的参数列表。</span><br><span class="hljs-built_in">println</span>(distanceByPointer(atlas, Position&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;))<br><span class="hljs-built_in">println</span>(distanceByValue(&amp;atlas, &amp;Position&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;))<br></code></pre></td></tr></table></figure>

<p>Go 对方法表达式的参数列表做了以下处理：将接收者的值或者是地址 ( 这取决于方法表达式的写法 ) 头插到原方法的参数列表的首个位置。从表面上看，方法表达式 <code>distance</code>  变成了一个普通的函数，因为这种写法隐去了 <code>.</code> 操作符。</p>
<p>到这里，有必要做一些说明：假设某一个类型为 <code>T</code> ，那么接收者设置为 <code>T</code> 和 <code>*T</code> 是存在区别的，比如在 <strong>接口</strong> 章节就会有所体现 ( 是 <code>T</code> 实现了接口还是 <code>*T</code> 实现了接口呢？)。由于 Go 语言的语法机制导致了这样的一个现象：假设某个方法的接收者为 <code>T</code> ，那么这个方法可以被 <code>T</code> 和 <code>*T</code> 类型所用。但反之，如果某个方法的接收者为 <code>*T</code> ，那么这个方法只可以被 <code>*T</code> 或者辅以 <code>&amp;</code> 取址符的方式调用。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go: (二)复合数据</title>
    <url>/2021/03/17/Go-%E4%BA%8C-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>本专题记载了 Go 语言的复合类型：数组，切片 Slice，结构体 ( 以及和 JSON 数据之间的相互转换)，散列表 <code>map</code> 。其中，切片是一个比较难理解的部分，因此它占据了大部分章节。</p>
<h1 id="第四章-复合数据类型"><a href="#第四章-复合数据类型" class="headerlink" title="第四章 复合数据类型"></a>第四章 复合数据类型</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p>了解数组是了解 Go 语言切片的前提。数组是具备固定长度的，由 0 ~ 多个相同元素组成的连续序列。数组内的元素通过索引 ( 或者称之 “下标号” ) 访问。下面的代码演示了如何创建一个可容纳 3 个 <code>int8</code> 空间的数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ints [<span class="hljs-number">3</span>]<span class="hljs-keyword">int8</span><br></code></pre></td></tr></table></figure>

<p>默认情况下，数组的零值就是指内部元素类型的零值。如果要在创建数组时赋初始值，则可以使用数组字面量来完成。( 如果字面量的数量不够，之后的元素仍采用零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ints = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> ints&#123;<br>    fmt.Printf(<span class="hljs-string">&quot;index %v is %v\n&quot;</span>,index,value)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以不主动指定数组的长度，这样的话实际长度将由数组字面量的个数来决定。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ints = [...]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment">// len 函数可以返回该数组的长度。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(ints))<br></code></pre></td></tr></table></figure>

<p>注意，数组的长度也是数组类型的一部分。比如说 <code>[3]int</code> 和 <code>[4]int</code> 就是完全不同的两个类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ints = [...]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><br><span class="hljs-comment">// %T 会打印该变量的数据类型。数组的数据类型包含数组长度。</span><br>fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>,ints)<br></code></pre></td></tr></table></figure>

<p>数组之间是可以比较的，前提是内部的元素类型也是可比较的。假定有表达式 <code>arr1 == arr2</code> ，其中两个变量均为数组类型。那么程序会依次判断两数组内部的元素是否都完全相等。若为真，则该表达式结果为 <code>true</code> 。</p>
<p><strong>如果两个数组的长度不同，那么它们就必定是不同的</strong>。对不同类型的变量进行比较，Go 会直接给出一个编译错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr1 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> arr2 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">var</span> arr3 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> arr4 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment">//false</span><br><span class="hljs-built_in">println</span>(arr1==arr2)<br><br><span class="hljs-comment">//ture</span><br><span class="hljs-built_in">println</span>(arr1==arr3)<br><br><span class="hljs-comment">// 编译不通过，原因是 [3]int 和 [5]int 不是同一种类型。</span><br><span class="hljs-built_in">println</span>(arr1==arr4)<br></code></pre></td></tr></table></figure>

<p>如果函数中出现了与数组相关的形参，它将是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这个函数将 ints 内的三个元素全部 + 1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add_1</span><span class="hljs-params">(ints [3]<span class="hljs-keyword">int</span>)</span></span>&#123;<span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> ints&#123;v++&#125;&#125;<br></code></pre></td></tr></table></figure>

<p>但是当在主程序使用它时，会发现外部传入的数组并没有发生改变：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">ints := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><br>add_1(ints)<br><br><span class="hljs-comment">// ints 并没有因为 add_1 函数的操作而发生改变。</span><br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> ints&#123;<span class="hljs-built_in">println</span>(v)&#125;<br></code></pre></td></tr></table></figure>

<p>这是由于当调用 Go 函数时，传入的参数都是一个副本 ( 值拷贝 )。当传入的是一个大数组时，这种方式将变得十分低效。并且，函数内部修改的都是其数组的副本，而不是传入的那个数组本身。但是在其它语言当中，数组可能是隐式地引用方式传递。</p>
<p>行之有效的方法是令函数接收一个 <code>[3]int</code> 类型的指针，然后根据下标修改数组的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add_1</span><span class="hljs-params">(pInt3 *[3]<span class="hljs-keyword">int</span>)</span></span>&#123;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pInt3 &#123;<br>		pInt3[i]++<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>值得一提的是，下面这种方式也不会改变原有的数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add_1</span><span class="hljs-params">(pInt3 *[3]<span class="hljs-keyword">int</span>)</span></span>&#123;<br>	<span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> pInt3 &#123;<br>		<span class="hljs-comment">// 这种方式只是将数组内的元素拷贝给局部变量 v 并使 v 自增，但是并没有影响到数组内的元素本身。</span><br>		v++<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果不采取指针的方式，也可以在函数运行结束之后将改动后的数组值传回到外部：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add_1</span><span class="hljs-params">(ints [3]<span class="hljs-keyword">int</span>)</span> [3]<span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">for</span> i,v := <span class="hljs-keyword">range</span> ints &#123;<br>		ints[i] = v+<span class="hljs-number">1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> ints<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于数组天然就是不可变的，因此它没有定义有关扩容，或者收缩的操作。在实际开发中，很少直接使用不可变的数组，而是其依附于数组的切片 Slice。</p>
<h2 id="2-切片"><a href="#2-切片" class="headerlink" title="2. 切片"></a>2. 切片</h2><p>切片表示一个长度可变的，由同类元素组成的序列。切片的类型为 <code>[]T</code>，和数组类型的最大区别是，它不指派长度。切片和不可变的数组紧密相关，又或者称切片是依附于某个数组的。这个数组被称为<strong>底层数组</strong>。切片包含了三个内容：指针，长度，和容量。</p>
<p><img  src="https://i.im5i.com/2021/03/17/hmKxl.png"  ><span class="image-caption">len 和 cap</span></p>
<p>指针，记录了这个切片从数组的哪个位置 “切入”，因此笔者习惯额外称它是 “头指针”。上述演示的代码块中，<code>arr[1:6]</code> 表示从 <code>arr[1]</code> 这个 “切点” 切入并得到了一个左闭 ( 含 <code>arr[1]</code> ) 右开 ( 不包含 <code>arr[6]</code> ) 区间的切片。</p>
<p>容量 <code>cap</code> 是一个和长度 <code>len</code> 不同的概念。<strong>这个数值通常等于切片指针到底层数组末端的这段距离</strong>，<code>cap &gt;= len</code> 恒成立。 <code>cap - len</code> 则代表了 “这个切片的可拓展空间” 。比如，在通常情况下 <code>cap(arr[1:6]) = len(arr) - 1 = 9</code>  ( 底层数组长 - 此切片 “头” 指针对应底层数组的下标 ) 。后文会通过例子介绍 <code>cap</code> 存在的意义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><br><span class="hljs-comment">// 由于切片 slice[m:n] 的前闭后开区间，因此计算长度很容易：n - m.</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-built_in">println</span>(<span class="hljs-built_in">len</span>(arr[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>]))<br><br><span class="hljs-comment">// 通常都是 len(arr) - m</span><br><span class="hljs-comment">// 9</span><br><span class="hljs-built_in">println</span>(<span class="hljs-built_in">cap</span>(arr[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>]))<br></code></pre></td></tr></table></figure>

<p>注意，切片的可访问下标范围仅在 <code>0</code> ~ <code>len-1</code> 之间，这和 <code>cap</code> 没有关系。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><br><span class="hljs-comment">//len = 6 - 3 = 3</span><br><span class="hljs-comment">//cap = 10 - 3 = 7</span><br><span class="hljs-comment">//可用的下标号为 0 ~ 2,在本例中，值依次对应 3 ~ 5</span><br>slice := arr[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>]<br><br>fmt.Print(slice[<span class="hljs-number">0</span>])<br>fmt.Print(slice[<span class="hljs-number">1</span>])<br>fmt.Print(slice[<span class="hljs-number">2</span>])<br><br><span class="hljs-comment">// 编译通过，但是运行错误。</span><br><span class="hljs-comment">// panic: runtime error: index out of range [3] with length 3</span><br>fmt.Print(slice[<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure>

<p>切片字面量的初始化方式和数组字面量非常相似，但是不会像数组那样声明长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 得到的是切片</span><br>a := []<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment">// 得到的是数组</span><br>b := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>,a)<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>,b)<br></code></pre></td></tr></table></figure>

<p>格外要注意的点是，<strong>切片之间不允许相互比较</strong>。切片唯一能够比较的值是 <code>nil</code>，用来判断它是否是一个空切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// a 和 b 相等吗? 或者说可比较吗?</span><br>a := []<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>b := []<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment">// 提示 []int8 没有定义 == 操作符。</span><br><span class="hljs-built_in">println</span>(a == b)<br><span class="hljs-built_in">println</span>(a != <span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure>

<p>一个底层数组可以覆盖多个切片。切片可以从底层数组的任意一点 “切入”，并且切片之间可以相互<strong>重叠</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><br>slice1 := arr[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// 可以像访问数组元素那样，从切片中摘出某一个元素。</span><br><span class="hljs-comment">// 对于 slice1 而言，它的第一个元素相当于是底层数组的第二个元素，因此这个值是1.</span><br><span class="hljs-built_in">println</span>(slice1[<span class="hljs-number">3</span>])<br><span class="hljs-comment">// 这个切片修改了底层数组</span><br>slice1[<span class="hljs-number">3</span>] = <span class="hljs-number">127</span><br><br><span class="hljs-comment">// 切片之间可以相互重叠。</span><br>slice2 := arr[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>]<br><span class="hljs-comment">// 切片对底层数组的修改可能会导致另外的切片也随之变化。</span><br><span class="hljs-comment">// 打印结果将是 127，因为这个位置的元素被 slice1 修改过。</span><br><span class="hljs-built_in">println</span>(slice2[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure>

<p>切片之间相互重叠的情况下要格外小心：一个切片对底层数组的重叠位置做了修改，这个行为会影响到另一个切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><br><span class="hljs-comment">//arr[1] ~ arr[7],length = 6;</span><br>slice1 := arr[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>]<br>slice2 := slice1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br><br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> slice2 &#123;<span class="hljs-built_in">println</span>(v)&#125;<br></code></pre></td></tr></table></figure>

<p>一个切片 B 可以切于令一个切片 A，切片 A，B 会共享底层数组。这种情况下必定会引起切片 A，B 发生重叠，且切片 B 的长度未必就比 A 短。</p>
<p>下面用图示方式举了一个例子：切片 B 的末端可以越过切片 A 的末端，这将导致切片 A 被 “暂时动态扩容”。<strong>有一点可以肯定的是：切片 B 的前端一定不会越过切片 A 的前端。</strong></p>
<p>这时，切片 A 的 <code>cap</code> 就是一个关键量。在这里按默认情况计算 <code>sliceA</code> 的 <code>cap = 10 - 3 = 7</code> 。 也就是说如果 <code>sliceB := sliceA[n:m]</code> ，这个 <code>m</code> 的最大值可以为 <code>7</code> 。 </p>
<p>下面的图示中，<code>m == 6</code> 。显然，如果 <code>m</code> 的取值大于 <code>7</code> ( <code>cap(sliceA)</code> )  ，那么就说明 <code>sliceB</code> 的末端已经延展到了底层数组的外界，这会引发程序错误。</p>
<p><img  src="https://i.im5i.com/2021/03/17/hmGtn.png"  ><span class="image-caption">通过 &quot;扩容&quot; 创建切片的切片</span></p>
<p>下面将用程序来演示这个过程。值得强调的一点是，上文使用了”暂时动态扩容” 的措辞，这是一种 “形象” 又便于理解的说法，同时还暗示了：在创建切片 B 的前后，<strong>切片 A 的长度没有因此发生任何变化</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><br>sliceA := arr[<span class="hljs-number">3</span>:<span class="hljs-number">7</span>]<br><span class="hljs-comment">//输出切片 A 的长: 7 - 3.</span><br><span class="hljs-built_in">println</span>(<span class="hljs-built_in">len</span>(sliceA))<br><br><span class="hljs-comment">// 切片 B 截取自切片 A</span><br>sliceB := sliceA[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>]<br><span class="hljs-comment">// 切片 A 的长度不变</span><br><span class="hljs-built_in">println</span>(<span class="hljs-built_in">len</span>(sliceA))<br><br><span class="hljs-comment">// 查看切片 B 的最后一个元素：8</span><br><span class="hljs-built_in">println</span>(sliceB[<span class="hljs-built_in">len</span>(sliceB)<span class="hljs-number">-1</span>])<br></code></pre></td></tr></table></figure>

<p>通过这个例子展现了 <code>cap</code> 的一般意义：它提供一种保证，以防止其它切片在某一个切片为基准 “切入” 时，不慎拓展到底层数组的 “外面” 。不过，<code>cap</code> 并不总是切片指针到数组末端的距离长，后文演示了如何主动设置 <code>cap</code> 值。</p>
<h3 id="2-1-append-函数"><a href="#2-1-append-函数" class="headerlink" title="2.1 append 函数"></a>2.1 append 函数</h3><p><code>append</code> 函数可以为切片扩容。直观的用法是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">sliceA := []<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>sliceB := <span class="hljs-built_in">append</span>(sliceA,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)<br><br><span class="hljs-comment">//&#123;1,2,3,4,5,6,7&#125;</span><br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> sliceB &#123;fmt.Print(v,<span class="hljs-string">&quot; &quot;</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>相比于用法，<code>append</code> 函数更值得探讨的地方在于：如果在一般的情形中使用了 <code>append</code> 函数，这是否会影响到原切片所引用的底层数组？答案是：不确定。前文已经介绍了一个切片具有的两个量值：<code>len</code> 长度和 <code>cap</code> 容量。下文为了方便叙述，会将 <code>cap - len</code> 这片空间称之为 “剩余空间” 。</p>
<p>第一种情况是：作为参数的切片 <code>sliceA</code> 的剩余空间足够容纳 <code>appned</code> 函数新添加的元素：( 比如下面的代码块中，<code>append</code> 只添加了一个新元素 <code>10</code> ) 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">i8s := [...]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// len = 4 , cap = 5 , usable = 5 - 4 = 1.</span><br>sliceA := i8s[:<span class="hljs-number">4</span>]<br>sliceB := <span class="hljs-built_in">append</span>(sliceA,<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// 显然 slice 序列里有 &#123;1, 2, 3, 4, 10&#125;</span><br>fmt.Println(<span class="hljs-string">&quot;sliceB:&quot;</span>)<br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> sliceB &#123;fmt.Print(v,<span class="hljs-string">&quot; &quot;</span>)&#125;<br><br><span class="hljs-comment">// 此时的底层数组也被改变了:&#123;1, 2, 3, 4, 10&#125;</span><br>fmt.Println(<span class="hljs-string">&quot;\n[after] i8s:&quot;</span>)<br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> i8s &#123;fmt.Print(v,<span class="hljs-string">&quot; &quot;</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>这种情况下，<code>append</code> 函数相当于是基于切片 <code>sliceA</code> 的底层数组创建了另一个切片 <code>sliceB</code> 。为了能够在原切片的基础上新增一个值 <code>10</code>，<code>append</code> 函数的做法是修改了 <code>sliceA</code> 的底层数组 <code>i8s[4]</code>，将原来的元素值 <code>5</code> 修改成了 <code>10</code> 。</p>
<p><img  src="https://i.im5i.com/2021/03/17/hmVh7.png"  ><span class="image-caption">剩余空间足够时的情形</span></p>
<p>第二种情况是：<code>append</code> 函数添加的元素数量多于 <code>sliceA</code> 的剩余空间。下面的例子中，新增的元素数量有 3 个，但是 <code>sliceA</code> 的剩余空间只有 1 个。如果按照默认方式计算 <code>cap(sliceA)</code> ，这其实还表明了 <code>sliceA</code> 的底层数组没有办法装下多出来的那 2 个元素。由于数组本身又是不可变的，<code>append</code> 函数自然就无法再基于 <code>sliceA</code> 的底层数组 <code>i8s</code> 做处理了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">i8s := [...]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// len = 4 , cap = 5 , usable = 5 - 4 = 1.</span><br>sliceA := i8s[:<span class="hljs-number">4</span>]<br><span class="hljs-comment">// element Count = 3 &gt; usable</span><br>sliceB := <span class="hljs-built_in">append</span>(sliceA,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>)<br><br><span class="hljs-comment">// &#123;1, 2, 3, 4, 5, 10, 11, 12&#125;</span><br>fmt.Println(<span class="hljs-string">&quot;sliceB:&quot;</span>)<br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> sliceB &#123;fmt.Print(v,<span class="hljs-string">&quot; &quot;</span>)&#125;<br><br><span class="hljs-comment">// 此时的 sliceA 的底层数组没有变化，&#123;1, 2, 3, 4, 5&#125;</span><br>fmt.Println(<span class="hljs-string">&quot;\n[after] i8s:&quot;</span>)<br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> i8s &#123;fmt.Print(v,<span class="hljs-string">&quot; &quot;</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>这时 <code>append</code> 的逻辑是：索性在内存空间中在原有底层数组的基础上复制出一个有更多空余空间的<strong>新数组</strong>，返回的新切片将以这个新数组作为底层数组。</p>
<p>说得再直白一些，此时得到的 <code>sliceB</code> 已经和 <code>sliceA</code> 及其底层数组 <code>i8s</code>  没有联系了。</p>
<p><img  src="https://i.im5i.com/2021/03/17/hmdJ2.png"  ><span class="image-caption">剩余空间不足时的情形</span></p>
<p>总之， <code>append</code> 函数可能会引发副作用，这取决于被放入的 <code>sliceA</code> 剩余空间 <code>cap - len</code> 是否足够容纳这些被添加的元素。</p>
<p>如果要强制令 <code>append</code> 为新切片 <code>sliceB</code> 分配一个新的底层数组 ( 如果你想实现这样的效果 )，这里有两个思路：</p>
<p>思路一：限定 <code>sliceA</code> 的剩余空间为 0，表明 “不可在 <code>sliceA</code> 之上做拓展”。这其实只要限制切片的 <code>cap == len</code> 即可。Go 提供这样的语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// index - start = len;</span><br><span class="hljs-comment">// max -start = cap</span><br><span class="hljs-comment">// start &lt;= index &lt;= max</span><br><span class="hljs-comment">// avaliable: [start,index)</span><br>array[start:index:max]<br></code></pre></td></tr></table></figure>

<p>该语法在 <code>array[m：n]</code> 的基础上增添了第三项：<code>max</code> 。其中，<code>start</code> 可以被缺省，默认为 0，写法为 <code>array[:index:max]</code> 。</p>
<p>程序通过计算 <code>max - start</code> 来设置此切片的 <code>cap</code> 容量。如果该 <code>max == len(array)</code> ，则两者声明方式等价。本例则通过设置 <code>max == index</code> 来使切片的剩余空间为 <code>0</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr =[...]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br><br><span class="hljs-comment">// start = 2, index = 5, max = 5</span><br><span class="hljs-comment">// len(sliceA) = 5 - 2 = 3</span><br><span class="hljs-comment">// cap(sliceA) = 5 - 2 = 3</span><br><span class="hljs-comment">// usable = cap - len = 0</span><br><span class="hljs-comment">// sliceA: &#123;3, 4, 5&#125;</span><br><span class="hljs-comment">// 使用 &quot;arr[2:5]&quot; 和 &quot;arr[2:5:5]&quot; 观察会对 arr 数组有何影响.</span><br>sliceA := arr[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>:<span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// sliceB: &#123;3, 4, 5, 16, 17&#125;</span><br>sliceB := <span class="hljs-built_in">append</span>(sliceA, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;arr...&quot;</span>)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;fmt.Print(v,<span class="hljs-string">&quot; &quot;</span>)&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;\nsliceB...&quot;</span>)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> sliceB &#123;fmt.Print(v,<span class="hljs-string">&quot; &quot;</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>思路二：如果不想令某一个数组会随着切片而改变，那么只需要让切片在创建时引用另一个底层数组，且这两个数组通过值拷贝的方式共享数据，以此达到切片和原数组 “松耦合” 的效果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr =[...]<span class="hljs-keyword">int8</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br><br><span class="hljs-comment">// make(slice type, len, cap)，这个空切片引用的是一个长度为 cap 的零值数组。</span><br>sliceA := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">30</span>)<br><br><span class="hljs-comment">// slice = &#123;3, 4, 5&#125;</span><br><span class="hljs-built_in">copy</span>(sliceA,arr[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])<br><br><span class="hljs-comment">// sliceB = &#123;3, 4, 5, 100, 101&#125;</span><br>sliceB := <span class="hljs-built_in">append</span>(sliceA,<span class="hljs-number">100</span>,<span class="hljs-number">101</span>)<br><br><span class="hljs-comment">// arr is 1 2 3 4 5 6 7</span><br>fmt.Println(<span class="hljs-string">&quot;arr is...&quot;</span>)<br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> arr&#123;<br>    fmt.Print(v,<span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// sliceB is 3 4 5 100 101</span><br>fmt.Println(<span class="hljs-string">&quot;\nsliceB is...&quot;</span>)<br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> sliceB&#123;<br>    fmt.Print(v,<span class="hljs-string">&quot; &quot;</span>)<br>&#125;                                		<br></code></pre></td></tr></table></figure>

<p>首先，这里的 <code>sliceA</code> 没有直接引用 <code>arr[2:5]</code> 片段 ，它通过 <code>make</code> 函数完成了初始化。这使切片 <code>sliceA</code> 引用一个<strong>新的零值数组作为底层数组</strong>，而不是 <code>arr</code> 本身。 </p>
<p><code>sliceA</code> 需要获取到 <code>arr[2:5]</code> 的内容，而这一步通过内置的 <code>copy</code> 函数将 <code>arr[2:5]</code> 片段上的值拷贝到了 <code>sliceA</code> 的底层数组。</p>
<p><img  src="https://i.im5i.com/2021/03/17/hmfoP.png"  ><span class="image-caption">通过 copy 实现 &quot;低耦合&quot; append</span></p>
<h2 id="3-散列表-map"><a href="#3-散列表-map" class="headerlink" title="3. 散列表 map"></a>3. 散列表 map</h2><p>散列表是一个拥有键值对元素的无序集合。散列表的键 ( key ) 总是唯一的。在 Go 程序中，需要借助内置的 <code>make</code> 函数来得到一个散列表 <code>map</code> 的引用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// K: Key 的类型。</span><br><span class="hljs-comment">// V: Value 的类型。</span><br><span class="hljs-comment">// 通过 make 函数得到的是一个非 nil，但是内容为空的 map 散列表。</span><br>aMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[K]V)<br></code></pre></td></tr></table></figure>

<p>从写法上来看，键占据了一个相对更重要的地位：Go 要求它的类型必须是可以通过 <code>==</code> 符号比较的，这样 <code>map</code> 才能快速检测某个键是否已经存在了。可以使用 <code>map</code> 字面量在初始化时插入 K-V，不管这个键值对是不是列表中的最后一个，它总是需要以 <code>,</code> 收尾 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通过 map 字面量赋值的方式可以在初始化时就在内部插入键值对。</span><br>aMap := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>&#123;<br>    <span class="hljs-comment">// 无论后面有没有 k-v 对，总是需要使用半角,符号收尾。</span><br>    <span class="hljs-string">&quot;age&quot;</span>:   <span class="hljs-number">20</span>,<br>    <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">100</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-1-注意初始化问题"><a href="#3-1-注意初始化问题" class="headerlink" title="3.1 注意初始化问题"></a>3.1 注意初始化问题</h3><p>当如下方式声明一个 <code>map</code> 时，得到的是一个 <code>nil</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明却不赋值</span><br><span class="hljs-keyword">var</span> aMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span><br></code></pre></td></tr></table></figure>

<p>这样的 <code>map</code> 是没有意义的，因为它还没有被初始化 ( 如果要得到一个内容为空的 <code>map</code> 引用，则应该使用 <code>make</code> 函数 )，除非在之后为它赋值了一个 <code>map</code> 字面量，这个字面量里面可以不包含任何内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span><br><br><span class="hljs-comment">// 也可以这样赋值: a = map[string]int8&#123;&#125;</span><br><span class="hljs-comment">// 这将等价于 =&gt; make(map[string]int8)</span><br>a = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>&#123;<br>   <span class="hljs-string">&quot;java&quot;</span>:<span class="hljs-number">2017</span>,<br>   <span class="hljs-string">&quot;scala&quot;</span>:<span class="hljs-number">2020</span>,<br>   <span class="hljs-string">&quot;go&quot;</span>:<span class="hljs-number">2021</span>,<br>&#125;<br><br>fmt.Println(a[<span class="hljs-string">&quot;python&quot;</span>])<br></code></pre></td></tr></table></figure>

<h3 id="3-2-有关散列表的查找删除"><a href="#3-2-有关散列表的查找删除" class="headerlink" title="3.2 有关散列表的查找删除"></a>3.2 有关散列表的查找删除</h3><p>在 <code>map</code> 中的查找，删除操作都是安全的。如果程序没有找到某个 Key，则会在访问时返回 Value 类型的零值；同样的，如果要删除某个不存在的 Key，那么这个 <code>map</code> 就不会发生任何变化。</p>
<p>散列表维持了 “下标” 方式访问元素的传统，因此在写法上保留了方括号 <code>[]</code>。不过，这里 “下标” 指代的是 Key 值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">aMap := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>&#123;<br>	<span class="hljs-string">&quot;age&quot;</span>:   <span class="hljs-number">20</span>,<br>	<span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">100</span>,<br>&#125;<br><br><span class="hljs-comment">//访问 key = &quot;age&quot; 的 value 值。</span><br><span class="hljs-built_in">println</span>(aMap[<span class="hljs-string">&quot;age&quot;</span>])<br><br><span class="hljs-comment">//修改 key = &quot;score&quot; 的 value 值。</span><br>aMap[<span class="hljs-string">&quot;score&quot;</span>] = <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure>

<p>上述代码块的赋值语句要分两个情况考虑：如果这个 Key 之前并不存在，那么这条语句相当于插入了一个新的键值对。否则，由于 <code>map</code> 中 Key 不允许重复，这会修改原来这个 Key 所对应的 Value。</p>
<p>因此，下面的这一条语句包含了两条信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// aMap is a type of map[string]int8</span><br>aMap[<span class="hljs-string">&quot;age&quot;</span>] ++<br></code></pre></td></tr></table></figure>

<p>如果这个 Key 未曾存在过，那么这条语句会在 <code>aMap</code> 表内插入一条 <code>&quot;age&quot;:0</code> ，然后再做自增操作 ( 这样的话，该键的返回值就是 1 ) 。否则，就将 Value 在之前的基础上自增 1 。换句话说，<code>aMap[&quot;age&quot;]++</code> 得到的值将至少为 1 。</p>
<p>无论一个 Key 是否存在于 <code>map</code> 中，Go 程序总是至少会返回一个零值，因此避免了 “<code>NullPointerException</code>“。但是，这种 “贴心” 的做法也会带来混淆的情况，比如说用户程序恰好插入的就是 Value 为零值的键值对：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">_3dPosition := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>&#123;<br>    <span class="hljs-string">&quot;x&quot;</span>:<span class="hljs-number">100</span>,<br>    <span class="hljs-string">&quot;y&quot;</span>:<span class="hljs-number">80</span>,<br>    <span class="hljs-string">&quot;z&quot;</span>:<span class="hljs-number">0</span>,<br>&#125;<br><br>_,isExist := _3dPosition[<span class="hljs-string">&quot;z&quot;</span>]<br><span class="hljs-keyword">if</span>(isExist)&#123;fmt.Println(<span class="hljs-string">&quot;value of z is 0&quot;</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>为了避免这种混淆，Go 语言做了如下设计：当访问 <code>map</code> 元素时，实际上会得到两个值，一个是 Value 本身，另一个则是布尔类型的值，它表达了程序是否在此 <code>map</code> 找到了预期的 Value。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">_3dPosition := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>&#123;<br>    <span class="hljs-string">&quot;x&quot;</span>:<span class="hljs-number">100</span>,<br>    <span class="hljs-string">&quot;y&quot;</span>:<span class="hljs-number">80</span>,<br>    <span class="hljs-string">&quot;z&quot;</span>:<span class="hljs-number">0</span>,<br>&#125;<br><br>_,isExist := _3dPosition[<span class="hljs-string">&quot;z&quot;</span>]<br><span class="hljs-keyword">if</span>(isExist)&#123;fmt.Println(<span class="hljs-string">&quot;value of z is 0&quot;</span>)&#125;<br><br>_2dPosition:=<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>&#123;<br>    <span class="hljs-string">&quot;x&quot;</span>:<span class="hljs-number">100</span>,<br>    <span class="hljs-string">&quot;y&quot;</span>:<span class="hljs-number">80</span>,<br>&#125;<br><br>_,isExist = _2dPosition[<span class="hljs-string">&quot;z&quot;</span>]<br><span class="hljs-keyword">if</span>(!isExist)&#123;fmt.Println(<span class="hljs-string">&quot;have no param of &#x27;z&#x27;&quot;</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>注意，无法获取 <code>map</code> 元素的地址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">&amp;aMap[<span class="hljs-string">&quot;age&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>原因是因为随着 <code>map</code> 散列表的增长，内部元素的地址可能会发生改变 ( 它们可能会被挪到一个新的地址 ) 。<code>map</code> 被视作下标为 “Key” 的特殊序列，因此 <code>for</code> 循环中的 <code>range</code> 关键字对它仍然适用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span>  aMap &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;the key is %v, and the value is %v\n&quot;</span>,k,v)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-3-有序遍历-map-散列表的思路"><a href="#3-3-有序遍历-map-散列表的思路" class="headerlink" title="3.3 有序遍历 map 散列表的思路"></a>3.3 有序遍历 map 散列表的思路</h3><p>值得一提的是，<code>map</code> 依赖足够随机的散列算法来避免碰撞，这也导致直接对 <code>map</code> 进行 <code>for</code> 循环遍历时，程序并不保证其迭代的顺序。如果要按照某种顺序遍历 <code>map</code>，一种委婉的方法是：单独创建一个切片有序保管 Key 值，然后按照遍历顺序去访问 <code>map[Key]</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">nameList := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>&#123;<br>   <span class="hljs-string">&quot;Li Lei&quot;</span>:    <span class="hljs-number">100</span>,<br>   <span class="hljs-string">&quot;Wang Fang&quot;</span>: <span class="hljs-number">80</span>,<br>   <span class="hljs-string">&quot;A Wei&quot;</span>:     <span class="hljs-number">70</span>,<br>&#125;<br><br><span class="hljs-comment">//make(type of slice,len,cap)</span><br>names := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nameList))<br><br><span class="hljs-comment">// 1.将 map 内的 key 全部插入到 names 切片</span><br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> nameList&#123;<br>   names = <span class="hljs-built_in">append</span>(names,key)<br>&#125;<br><br><span class="hljs-comment">// 2.这个包的作用相当于对 names 切片就地进行了一步重排序。</span><br><span class="hljs-comment">// 字符串的排序是按首字母 A-Z 顺序排列的。</span><br>sort.Strings(names)<br><br><span class="hljs-comment">// 3.按照有序的 key 列表去访问 map.</span><br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> names &#123;<br>   fmt.Println(nameList[v])<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-4-将不可比较的类型设置为-Key-的思路"><a href="#3-4-将不可比较的类型设置为-Key-的思路" class="headerlink" title="3.4 将不可比较的类型设置为 Key 的思路"></a>3.4 将不可比较的类型设置为 Key 的思路</h3><p>前文提到作为 Key 的类型必须是可使用 <code>==</code> ，<code>!=</code> 比较的类型，因此声明下面的 <code>map</code> 不会通过编译，因为 Key 是一个不可比较的字符串切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">map</span>[[]<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>&#123;<br>    []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;go&quot;</span>&#125;:<span class="hljs-number">3</span>,<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>答案是适配器设计思想。我们只需要设计一个助手函数 <code>k</code>，将不可变的 <code>[]string</code> 映射成 <code>string</code>，就可以通过一种 “委婉” 的方式实现这个需求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>	slice := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>&#125;<br><br>	aMap := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>&#123;&#125;<br>	Insert(aMap, slice, <span class="hljs-number">3</span>)<br>	r, rExist := GetOrReturn(aMap, []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>&#125;, <span class="hljs-number">-1</span>)<br>	<span class="hljs-keyword">if</span> rExist &#123;<br>		<span class="hljs-built_in">println</span>(r)<br>	&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">k</span><span class="hljs-params">(key []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%q&quot;</span>, key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Insert</span><span class="hljs-params">(thisMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>, key []<span class="hljs-keyword">string</span>, value <span class="hljs-keyword">int8</span>)</span></span> &#123;<br>	thisMap[k(key)] = value<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetOrReturn</span><span class="hljs-params">(thisMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>, key []<span class="hljs-keyword">string</span>, ifNone <span class="hljs-keyword">int8</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int8</span>, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>	result, ifExist := thisMap[k(key)]<br>	<span class="hljs-keyword">if</span> !ifExist &#123;<br>		result = ifNone<br>	&#125;<br>	<span class="hljs-keyword">return</span> result, ifExist<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-5-结构体"><a href="#3-5-结构体" class="headerlink" title="3.5 结构体"></a>3.5 结构体</h2><p>结构体是将 0 个或者多个类型的变量组合在一起的聚合数据类型，可以将它理解成是一张数据库的表。声明方式类似于 C 语言：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// type 和 struct 是两个关键字</span><br><span class="hljs-comment">// not &#x27;Class&#x27;</span><br><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>    name,address <span class="hljs-keyword">string</span><br>    age <span class="hljs-keyword">int8</span><br>    salary <span class="hljs-keyword">int32</span><br>    boss *Employee<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，结构体 <code>S</code> 内部的成员可以是基本数据类型，或者是其它类型的结构体 <code>V</code> 或其指针 <code>*V</code>，异或是自身类型的指针 <code>*S</code>，但是，<strong>不可以</strong>是自身类型 <code>S</code> 。</p>
<p>结构体内可以定义任意数量的成员。如果有多个成员属于同一种数据类型，则可以将它们写在一行，使用 <code>,</code> 分割。总体来看，结构体内部成员的排列顺序是由左至右，由上到下的。</p>
<p>使用点操作符 <code>.</code> 来访问一个结构体变量的成员：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">Bob.name<br></code></pre></td></tr></table></figure>

<p>结构体可以通过指针方式来访问，如果对结构体指针使用 <code>.</code> 操作符，则等价于对指针指向的结构体变量使用 <code>.</code> 操作符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p2Employee *Employee = &amp;Bob<br><span class="hljs-comment">// 等价于*(p2Employee).name</span><br><span class="hljs-built_in">println</span>(p2Employee.name)<br></code></pre></td></tr></table></figure>

<h3 id="3-5-1-结构体成员的可导出性"><a href="#3-5-1-结构体成员的可导出性" class="headerlink" title="3.5.1 结构体成员的可导出性"></a>3.5.1 结构体成员的可导出性</h3><p>如果结构体内部定义的成员名是首字母大写的，则意味着该成员可以被跨包访问，或者称可以被导出 ( 相当于 <code>public</code> 成员 ) 。比如在 B 包定义一个这样的结构体，注意，<code>info</code> 成员为小写开头。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Protocol <span class="hljs-keyword">struct</span> &#123;<br>	info <span class="hljs-keyword">string</span><br>	Host <span class="hljs-keyword">string</span><br>	Port <span class="hljs-keyword">int32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在另一个 A 包中，可以导入 B 包并创建一个 <code>Protocol</code> 类型的变量，但是只能够为 <code>Host</code> 和 <code>Port</code> 成员赋值。在 A 包操作 <code>Protocol</code> 类型的结构体时，成员 <code>info</code> 会如同不存在一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;B&quot;</span><br><br>client := B.Protocol&#123;<br>    Host: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    Port:  <span class="hljs-number">8000</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同理，如果结构体本身以小写字母开头命名，则在其它包中就无法使用此结构体。除非要实现 “密封类” 的效果，一般情况下结构体总是大写字母开头，而需要被保护的个别成员则使用小写字母开头。</p>
<h3 id="3-5-2-结构体赋值"><a href="#3-5-2-结构体赋值" class="headerlink" title="3.5.2 结构体赋值"></a>3.5.2 结构体赋值</h3><p>结构体一般情况下通过两种方式赋值：调用函数并使用返回值赋值，或者是直接使用结构体字面量赋值。结构体字面量的完整写法类似于 json ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-comment">// Employee&#123;...&#125; 部分又称之为结构体字面量，不需要使用诸如 new 之类的关键字。内部写法类似于 map.</span><br>    Tim := Employee&#123;<br>        name:    <span class="hljs-string">&quot;Tim&quot;</span>,<br>        address: <span class="hljs-string">&quot;UK&quot;</span><br>        age:     <span class="hljs-number">26</span>,<br>        salary:  <span class="hljs-number">10000</span>,<br>        boss:    <span class="hljs-literal">nil</span>,<br>    &#125;<br><br>    Bob := Employee&#123;<br>        name:    <span class="hljs-string">&quot;Bob&quot;</span>,<br>        address: <span class="hljs-string">&quot;UK&quot;</span><br>        age:     <span class="hljs-number">18</span>,<br>        salary:  <span class="hljs-number">15000</span>,<br>        boss:    &amp;Tim,<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>在结构体的结构非常简单的场合，结构体字面量可以直接写值而忽略掉成员名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Position&#123;X,Y <span class="hljs-keyword">int</span>&#125;<br>p := Position&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure>

<p>这意味着代码将不会显式地提示每个数值的意义，这时需要程序员自己保证赋值顺序要和成员声明的顺序严格一致，以保证每个值对应正确的语义。当结构体的结构比较复杂时，这种写法并不会推荐，因为这会为后续的维护工作带来难度。</p>
<p>结构体字面量的写法只能在上述两种取其一：要么显式地带上所有的成员名，要么就一个都不带。尤其对于第二种赋值方式而言，要格外注意结构体成员的排列顺序 ( 前文提到的：从上到下，从左到右 ) 。对于这样 “模棱两可” 的结构体字面量赋值， Go 会拒绝编译：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">Bob := Employee&#123;<br>    name:    <span class="hljs-string">&quot;Bob&quot;</span>,<br>    address: <span class="hljs-string">&quot;UK&quot;</span><br>    <span class="hljs-number">18</span>,<br>    <span class="hljs-number">15000</span>,<br>    boss:    &amp;Tim,<br>&#125;    <br></code></pre></td></tr></table></figure>

<h3 id="3-5-3-在函数中传递结构体"><a href="#3-5-3-在函数中传递结构体" class="headerlink" title="3.5.3 在函数中传递结构体"></a>3.5.3 在函数中传递结构体</h3><p>结构体及其指针都可以作为函数的参数或者返回值。首先假定有以下两组函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 好耶</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PayRaise</span><span class="hljs-params">(employee Employee)</span></span> &#123;<br>	employee.salary += <span class="hljs-number">5000</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PayRaiseP</span><span class="hljs-params">(employee *Employee)</span></span>&#123;<br>	employee.salary += <span class="hljs-number">5000</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一个函数 <code>PayRaise</code> 接收 <code>Employee</code> 类型，而第二个函数 <code>PayRaiseP</code> 接收的是其指针，两个函数的逻辑均是将传进来的员工信息 “涨薪” 5000。下面在主程序中调用这两个函数，并观察传入的值 <code>Tim</code> 是否真的被改变了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">Tim := Employee&#123;<br>    name:    <span class="hljs-string">&quot;Tim&quot;</span>,<br>    address: <span class="hljs-string">&quot;EN&quot;</span>,<br>    age:     <span class="hljs-number">26</span>,<br>    salary:  <span class="hljs-number">10000</span>,<br>    boss:    <span class="hljs-literal">nil</span>,<br>&#125;<br><br>PayRaise(Tim)<br>fmt.Println(Tim.salary)<br><br>PayRaiseP(&amp;Tim)<br>fmt.Println(Tim.salary)<br></code></pre></td></tr></table></figure>

<p>通过运行代码可以观察到：调用 <code>PayRaise</code> 方法时， <code>Tim</code> 的实际工资并没有上涨；但是在调用了 <code>PayRaiseP</code> 方法之后，<code>Tim</code> 的实际工资真的被改变了。这表明当形参列表中出现的是结构体类型时，参数只是简单地值传递。然而，如果要在函数内部对外界的结构体做出修改时，此时传入的应该是结构体指针。</p>
<p>下面有另两组函数，它们分别返回结构体类型及其指针类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewEmployee</span><span class="hljs-params">()</span> <span class="hljs-title">Employee</span></span>&#123;<br>	<span class="hljs-keyword">return</span> Employee&#123;<br>		name:    <span class="hljs-string">&quot;John&quot;</span>,<br>		address: <span class="hljs-string">&quot;UK&quot;</span>,<br>		age:     <span class="hljs-number">30</span>,<br>		salary:  <span class="hljs-number">16000</span>,<br>		boss:    <span class="hljs-literal">nil</span>,<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewEmployeeP</span><span class="hljs-params">()</span> *<span class="hljs-title">Employee</span></span>&#123;<br>	<span class="hljs-keyword">return</span> &amp;Employee&#123;<br>		name:    <span class="hljs-string">&quot;John&quot;</span>,<br>		address: <span class="hljs-string">&quot;UK&quot;</span>,<br>		age:     <span class="hljs-number">30</span>,<br>		salary:  <span class="hljs-number">16000</span>,<br>		boss:    <span class="hljs-literal">nil</span>,<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这两者返回的内容及其相似，只不过一个是结构体字面量的值，另一个则是结构体字面量的地址。<strong>出于效率的考虑，函数中接收，返回的通常都是结构体指针</strong>，因为这避免了一次 “值拷贝” 的过程。除非你不希望函数在原有的数据进行改动，而是返回一个新的结构体数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 该变量将是一个普通的结构体类型</span><br>newEmployee := NewEmployee()<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>,newEmployee)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>,newEmployee.name)<br>newEmployee = Tim<br><br><span class="hljs-comment">// 该变量是 *Employee 类型。</span><br>newEmployeeP := NewEmployeeP()<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>,newEmployeeP)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>,newEmployeeP.name)<br>newEmployeeP = &amp;Tim<br></code></pre></td></tr></table></figure>

<h3 id="3-5-4-结构体的可比较性"><a href="#3-5-4-结构体的可比较性" class="headerlink" title="3.5.4 结构体的可比较性"></a>3.5.4 结构体的可比较性</h3><p>当且仅当一个结构体内部的成员全部可以比较时，这个结构体才是可以比较的。如果这个结构体是可比较的，那么它就可以作为 <code>map</code> 散列表的键 Key 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">p := Position&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br>q :=Position&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><br><span class="hljs-comment">// 如果结构体内部全是可比较的，那么这个结构体本身就是可比较的。</span><br><span class="hljs-built_in">println</span>(p==q)<br><br><span class="hljs-comment">// 如果一个结构体是可以比较的，则它可以充当 map 的 key。</span><br>_ = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[Position]<span class="hljs-keyword">string</span>)<br></code></pre></td></tr></table></figure>

<h3 id="3-5-5-结构体嵌套结构和匿名成员"><a href="#3-5-5-结构体嵌套结构和匿名成员" class="headerlink" title="3.5.5 结构体嵌套结构和匿名成员"></a>3.5.5 结构体嵌套结构和匿名成员</h3><p>结构体内部的成员可以是其它的结构体类型或指针。假设有一个名为 <code>Item</code> 的结构体，它内部成员由 <code>ItemName</code> 和嵌套的 <code>Position</code> 结构体组成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Position <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-keyword">int</span> &#125;<br><span class="hljs-keyword">type</span> Item <span class="hljs-keyword">struct</span> &#123;<br>	p        Position<br>	ItemName <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要访问某个 <code>Item</code> 的 <code>X</code> 坐标，则需要两次 <code>.</code> 操作符来完成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">item := Item&#123;<br>    P:        Position&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>    ItemName: <span class="hljs-string">&quot;apple&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 写起来很麻烦。</span><br><span class="hljs-built_in">println</span>(item.p.X)<br></code></pre></td></tr></table></figure>

<p>从语法上来看，这不难理解：成员 <code>X</code> 属于 <code>p</code> ，而非 <code>item</code>。因此如果要访问成员 <code>X</code>，这需要首先访问 <code>Item</code> 得到 <code>p</code> 才行。如果有一种办法可以令 <code>X</code> 和 <code>Y</code> 能 “直属于” <code>Item</code>，那么访问它们就会容易得多了。</p>
<p>Go 语言提供这样的语法糖，我们要做的是就是将那个 <code>Position</code> 类型的成员 <code>p</code> 改成 “匿名” 成员：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Position <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-keyword">int</span> &#125;<br><span class="hljs-keyword">type</span> Item <span class="hljs-keyword">struct</span> &#123;<br>	Position<br>	itemName <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>从访问的逻辑上看，这相当于做了一步 <code>flat</code> 操作：</p>
<figure class="highlight tp"><table><tr><td class="code"><pre><code class="hljs tp">Item&#123;Position&#123;<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>&#125;,ItemName&#125; =&gt; Item&#123;<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>,ItemName&#125;<br></code></pre></td></tr></table></figure>

<p>这么做的好处是：仅仅需要一个 <code>.</code> 操作符就可以直接访问到原本不直接属于 <code>Item</code> 结构体的成员 <code>X</code> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// before:</span><br><span class="hljs-comment">// println(item.p.X)</span><br><br><span class="hljs-built_in">println</span>(item.X)<br></code></pre></td></tr></table></figure>

<p>然而，”匿名成员” 的说法其实并不准确，因为 Go 其实仍然会为 “匿名成员” 隐式地指派一个名字，这个名字就是结构体类型。在这个例子中，仍然可以通过 <code>item.Position.X</code> 的方式来访问到 X 坐标，只是在此处没有必要这么做而已。</p>
<p>同时，这种做法其实还含蓄的表达了：”匿名成员” 的可导出性将由这个结构体的可导出性决定。</p>
<h2 id="4-JSON"><a href="#4-JSON" class="headerlink" title="4. JSON"></a>4. JSON</h2><p>有关 JSON 本身在此处应该无需赘言了，它是目前使用最广泛的一种网络发送和接收格式化信息的标准 ( 它并不是唯一的标准，类似的还有 XML ) 。在 Go 语言中，无论是将结构体转换为 JSON ( 这个过程在 Go 程序里称之为 “<code>marshal</code>“，意为 “整理，排序” )，还是 JSON 转换回结构体数据都十分简单，不需要从外部导入一些 <code>fastjson</code> 或是 <code>gson</code> 包的依赖 …… </p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">item := Item&#123;<br>    Position:Position&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<br>    ItemName: <span class="hljs-string">&quot;apple&quot;</span>,<br>&#125;<br><br>marshal, err := json.Marshal(item)<br><br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,marshal)<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    log.Fatal(err.Error())<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Go-to-JSON"><a href="#Go-to-JSON" class="headerlink" title="Go to JSON"></a>Go to JSON</h3><p><code>json.Marshal(...)</code> 函数返回两个值：一个是 <code>[]uint8</code>  ( 或者称 <code>[]byte</code> ) 类型的转换结果，另一个变量则是可能出现的错误情况。对于转换结果可以使用 <code>fmt.Sprintf(...)</code> 等方法将其转换成字符串形式。上述代码会在控制台打印以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;X&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">&quot;Y&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">&quot;ItemName&quot;</span>:<span class="hljs-string">&quot;apple&quot;</span>&#125;<br></code></pre></td></tr></table></figure>

<p>当 JSON 数据结构比较复杂时，将其打印在一行可能难以阅读。<code>json.MarshalIndent</code> 函数可以输出更加整齐的格式化结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在第一个参数种传入要被转换的 Go 数据。</span><br><span class="hljs-comment">// 第二个参数是前缀符号。通常情况下它都是 &quot;&quot;，不过在这里出于演示效果而使用了其它符号。</span><br><span class="hljs-comment">// 第一个参数是定义的缩进字符串，这里使用了制表符 `\t` 。</span><br>marshal, err := json.MarshalIndent(item,<span class="hljs-string">&quot;|&quot;</span>,<span class="hljs-string">&quot;\t&quot;</span>)<br><br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,marshal)<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    log.Fatal(err.Error())<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码会在控制台打印以下内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">&#123;<br>|	<span class="hljs-string">&quot;X&quot;</span>: <span class="hljs-number">1</span>,<br>|	<span class="hljs-string">&quot;Y&quot;</span>: <span class="hljs-number">2</span>,<br>|	<span class="hljs-string">&quot;ItemName&quot;</span>: <span class="hljs-string">&quot;apple&quot;</span><br>|&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，<code>json</code> 包只针对可被导出 ( 首字母大写命名 ) 的成员，<strong>对于不可导出的成员，在处理过程中会被直接忽略</strong>。</p>
<h3 id="成员标签定义"><a href="#成员标签定义" class="headerlink" title="成员标签定义"></a>成员标签定义</h3><p>在定义结构体时，可以通过标记 <strong>成员标签定义( field flag)</strong> 令 <code>json</code> 在处理数据时做一些额外工作：比如说你希望将某个成员 <code>s</code> 导出成 JSON 数据时，能够换成另一个名字 <code>v</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Item <span class="hljs-keyword">struct</span> &#123;<br>	Position <span class="hljs-string">`json:&quot;position&quot;`</span><br>	ItemName <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，<code>json:&quot;position&quot;</code> 就是一个成员标签定义。它本身其实可以是任何一个字符串，但是它通常都以 <code>key:&quot;value&quot;</code> 的写法来定义。重新运行这段代码，观察控制台的打印结果会发生什么变化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">item := Item&#123;<br>    Position:Position&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<br>    ItemName: <span class="hljs-string">&quot;apple&quot;</span>,<br>&#125;<br><br>marshal, err := json.Marshal(item)<br><br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,marshal)<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    log.Fatal(err.Error())<br>&#125;<br></code></pre></td></tr></table></figure>

<p>匿名成员 <code>Position</code> 转换为 JSON 输出时，它的名字从 <code>Position</code> 变成了小写开头的 <code>position</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;position&quot;</span>:&#123;<span class="hljs-attr">&quot;X&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">&quot;Y&quot;</span>:<span class="hljs-number">2</span>&#125;,<span class="hljs-attr">&quot;ItemName&quot;</span>:<span class="hljs-string">&quot;apple&quot;</span>&#125;<br></code></pre></td></tr></table></figure>

<p><code>json</code> 还提供一个额外的标签 <code>omitempty</code>，它表示：<strong>如果在转换为 JSON 的过程中发现这个成员是零值，那么就忽略它</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Item <span class="hljs-keyword">struct</span> &#123;<br>	Position <span class="hljs-string">&#x27;json:&quot;position,omitempty&quot;&#x27;</span><br>	ItemName <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="JSON-to-Go"><a href="#JSON-to-Go" class="headerlink" title="JSON to Go"></a>JSON to Go</h3><p>相对地，将 JSON 转回结构体数据使用的是 <code>json.Unmarshal(...)</code> 函数。它可能比 <code>json.Marshal(...)</code> 函数更容易出现错误，因为你需要预留一个合适的结构体指针装载数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">item := Item&#123;<br>    Position:Position&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<br>    ItemName: <span class="hljs-string">&quot;apple&quot;</span>,<br>&#125;<br><br>marshal, _ := json.Marshal(item)<br><br><span class="hljs-keyword">var</span> parsedItem Item<br><br>err := json.Unmarshal(marshal, &amp;parsedItem)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// &quot;%#v&quot; 会输出完整的成员名称，包括匿名成员。</span><br>    fmt.Printf(<span class="hljs-string">&quot;%#v&quot;</span>,parsedItem)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Unmarshal</code> 函数需要两个参数，一个是符合 JSON 语法的字符串字节形式 <code>[]byte</code> ，一个是合理的结构体指针。它会就地将数据存放到指定的指针，因此返回值只有一个 <code>err</code> 。这里额外给出一个提示，可以通过 <code>[]byte(&quot;.....&quot;)</code> 得到 <code>string</code> 值的字节序列。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">bytes := []<span class="hljs-keyword">byte</span>(<span class="hljs-string">`</span><br><span class="hljs-string">	&#123;</span><br><span class="hljs-string">		&quot;AInt&quot;:12</span><br><span class="hljs-string">	&#125;</span><br><span class="hljs-string">	`</span>)<br></code></pre></td></tr></table></figure>

<p>如果只希望得到 <code>Item</code> 中的 <code>position</code> 数据，那只需要设置一个仅包含了 <code>position</code> 的匿名结构体变量 ( 其它数据会在转换过程中被丢弃 ) ，然后传递它的指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">item := Item&#123;<br>    Position:Position&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<br>    ItemName: <span class="hljs-string">&quot;apple&quot;</span>,<br>&#125;<br><br>marshal, _ := json.Marshal(item)<br><br><span class="hljs-keyword">var</span> parsedPosition <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-comment">// 由于结构体通过标签 `json:position` 将匿名成员 &quot;重命名&quot; 为了 position，</span><br>    <span class="hljs-comment">// 故这里也设置了一个同为小写字母开头的成员 position。</span><br>    <span class="hljs-comment">// 如果不这样做，Json.Unmarshal 就找不到合适的数据类型。</span><br>    position Position<br>&#125;<br><br>err := json.Unmarshal(marshal,&amp;parsedPosition)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%#v&quot;</span>,Position&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-文本模板"><a href="#5-文本模板" class="headerlink" title="5. 文本模板"></a>5. 文本模板</h2><p>对于简单的格式化输出，或许使用 <code>fmt.Fprint(...)</code> 就足够了。但如果格式化的是一个足够复杂的段落，这种情况下要求格式和嵌入的数据相互分离。而 Go 的 <code>text/template</code> 包则提供了这个功能 ( 其实 Go 还提供了渲染 HTML 模板的包：<code>text/html</code> ，但是本章暂时不考虑它 ) 。</p>
<p>这里首先给出一个简单的示例，然后逐步通过代码分析 <code>text/template</code> 提供的功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 模板字符串。内部含有占位符 &#123;&#123;.&#125;&#125;</span><br><span class="hljs-keyword">const</span> templ = <span class="hljs-string">`</span><br><span class="hljs-string">		ISSUE:&#123;&#123;.Issue&#125;&#125;</span><br><span class="hljs-string">		AUTHOR:&#123;&#123;.Author&#125;&#125;</span><br><span class="hljs-string">	`</span><br><span class="hljs-comment">// 生成模板。</span><br>parse, err := template.New(<span class="hljs-string">&quot;Hello&quot;</span>).Parse(templ)<br><br><span class="hljs-comment">// 准备插入的数据，这里直接使用了一个匿名结构体。</span><br><span class="hljs-keyword">var</span> data = <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 注意，这些数据必须是可导出的，否则会在创建模板的过程中出现错误。</span><br>    Issue <span class="hljs-keyword">string</span><br>    Author <span class="hljs-keyword">string</span><br>&#125;&#123;<span class="hljs-string">&quot;Hello,go&quot;</span>,<span class="hljs-string">&quot;me&quot;</span>&#125;<br><br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 执行模板</span><br>    err := parse.Execute(os.Stdout, data)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err.Error())&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数大体上分为三个步骤：定义一个字符串形式的模板，然后通过 <code>text/template</code> 的 <code>Parse(...)</code> 函数创建它，最终通过 <code>Execute(...)</code> 函数执行这个模板，同时将外部数据插入到了模板中。程序最终的执行结果是：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">ISSUE:</span>Hello,go<br><span class="hljs-symbol">AUTHOR:</span><span class="hljs-keyword">me</span><br>	<br></code></pre></td></tr></table></figure>

<p>在字符串模板中，形如 <code>&#123;&#123;.XXX&#125;&#125;</code> 的片段起到了 “占位符” 的作用。如 <code>&#123;&#123;.Issue&#125;&#125;</code> 表示：在这个位置，将来会从传入的结构体数据 <code>data</code> 中摘出 <code>Issue</code> 成员的值替代之，<code>&#123;&#123;.Author&#125;&#125;</code> 同理。</p>
<p><code>template.New(&quot;name&quot;).Parse(templ)</code> 是一串链式调用，首先 <code>New(...)</code> 函数为这个新的模板指定了一个名字，随后 <code>Parse(...)</code> 函数接收刚才定义好的字符串模板，并返回了一个可以被执行的文本模板，还有可能发生的错误 <code>err</code>。</p>
<p>下一步则是准备好要插值的数据。注意，<strong>模板接收的是一整个结构体变量，因此在这里需要将模板所需要的各种数值打包到一个结构体变量内</strong>。至于这个结构体是什么类型 <code>parse.Execute(...)</code> 函数并不关心，它可以是临时定义的匿名类型，也可以是在外部声明的具名类型。</p>
<p>这个结构体内部的成员名要和模板的占位符对应，而且要保证这些成员是可以被导出的，否则程序就不能正确地渲染数据。</p>
<p>上述流程全部就绪后，可以调用 <code>parse.Execute(...)</code> 函数指定输出流 ( 这里选择输出到控制台，标准输出流 <code>os.Stdout</code>) 和刚才准备好的结构体变量 <code>data</code> ，然后得到预期的结果。</p>
<p>上面是使用文本模板的基本流程，下面补充细节：</p>
<h3 id="5-1-将函数绑定到模板内"><a href="#5-1-将函数绑定到模板内" class="headerlink" title="5.1 将函数绑定到模板内"></a>5.1 将函数绑定到模板内</h3><p>首先，如果某些<strong>函数具备返回值</strong>，则它们可以被 “安装” 到文本模板中用于渲染数值。这些函数需要被传递到 <code>template.FuncMap</code> 散列表内 ( 在 Go 语言中，函数是一等公民，我们很快就会提到它 )，然后通过调用 <code>Funcs(...)</code> 函数将这个散列表和文本模板绑定起来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 这里的 &#123;&#123;greet&#125;&#125; 相当于调用了 FuncMap[&quot;greet&quot;] 的那个函数。</span><br>	<span class="hljs-keyword">const</span> template_ = <span class="hljs-string">`</span><br><span class="hljs-string">		===========</span><br><span class="hljs-string">		&#123;&#123;greet&#125;&#125;</span><br><span class="hljs-string">		===========</span><br><span class="hljs-string">    `</span><br><br>	parse, err := template.New(<span class="hljs-string">&quot;evokeFunction&quot;</span>).Funcs(<br>		template.FuncMap&#123;<span class="hljs-string">&quot;greet&quot;</span>: greet&#125;,<br>	).Parse(template_)<br><br>	<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>		err := parse.Execute(os.Stdout, <span class="hljs-literal">nil</span>)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			log.Fatal(err.Error())<br>		&#125;<br>	&#125;<br><br>&#125;<br><br><span class="hljs-comment">// 这个函数只返回字符串，什么都不做。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello,go&quot;</span>&#125;<br></code></pre></td></tr></table></figure>

<p>假定这个函数的执行需要参数，则可以借助管道符号 <code>|</code> 实现参数传递 ( 在 *nix 系统中我们曾经常这么做 ) ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 将访问到的 &#123;&#123;.Name&#125;&#125; 值传给了 FuncMap[&quot;greet&quot;] 函数。</span><br>	<span class="hljs-keyword">const</span> template_ = <span class="hljs-string">`</span><br><span class="hljs-string">		===========</span><br><span class="hljs-string">		&#123;&#123;.Name | greet&#125;&#125;</span><br><span class="hljs-string">		===========</span><br><span class="hljs-string">	`</span><br><br>	safeParse := template.Must(<br>		template.New(<span class="hljs-string">&quot;newTemplate&quot;</span>).<br>			Funcs(template.FuncMap&#123;<span class="hljs-string">&quot;greet&quot;</span>: greet&#125;).<br>			Parse(template_))<br><br>	data := <span class="hljs-keyword">struct</span>&#123;<br>		Name <span class="hljs-keyword">string</span><br>	&#125;&#123;<span class="hljs-string">&quot;John&quot;</span>&#125;<br><br>	<span class="hljs-keyword">if</span> err := safeParse.Execute(os.Stdout, data);err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatal(err.Error())<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果一个函数需要更多的参数，笔者的做法是将多个参数绑定到一个结构体再进行整体传递。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>	<span class="hljs-keyword">const</span> template_ = <span class="hljs-string">`</span><br><span class="hljs-string">		===========</span><br><span class="hljs-string">		&#123;&#123;.GreetArgs | greet&#125;&#125;</span><br><span class="hljs-string">		===========</span><br><span class="hljs-string">    `</span><br><br>	safeParse := template.Must(<br>		template.New(<span class="hljs-string">&quot;evokeFunction&quot;</span>).Funcs(<br>			template.FuncMap&#123;<span class="hljs-string">&quot;greet&quot;</span>: greet&#125;,<br>		).Parse(template_),<br>	)<br><br>	data := <span class="hljs-keyword">struct</span> &#123;<br>		GreetArgs <span class="hljs-keyword">struct</span> &#123;<br>			BoyName  <span class="hljs-keyword">string</span><br>			GirlName <span class="hljs-keyword">string</span><br>		&#125;<br>	&#125;&#123;<span class="hljs-keyword">struct</span> &#123;<br>		BoyName  <span class="hljs-keyword">string</span><br>		GirlName <span class="hljs-keyword">string</span><br>	&#125;&#123;BoyName: <span class="hljs-string">&quot;John&quot;</span>, GirlName: <span class="hljs-string">&quot;River&quot;</span>&#125;&#125;<br><br>	<span class="hljs-keyword">if</span> err := safeParse.Execute(os.Stdout, data); err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatal(err.Error())<br>	&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(args <span class="hljs-keyword">struct</span> &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">	BoyName  <span class="hljs-keyword">string</span></span></span><br><span class="hljs-function"><span class="hljs-params">	GirlName <span class="hljs-keyword">string</span></span></span><br><span class="hljs-function"><span class="hljs-params">&#125;)</span> <span class="hljs-title">string</span></span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;hello,%s and %s&quot;</span>, args.BoyName, args.GirlName)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，如果将频繁使用的匿名结构体提取出来并定义为具名结构体，则代码的可读性会更高。</p>
<h3 id="5-2-“错误拦截器”-template-Must"><a href="#5-2-“错误拦截器”-template-Must" class="headerlink" title="5.2 “错误拦截器”  template.Must"></a>5.2 “错误拦截器”  template.Must</h3><p>由于 <code>Parse(...)</code> 和 <code>Execute(...)</code> 函数都有可能抛出异常，这将迫使程序员通过写嵌套的 <code>if</code> 语句来处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// parse,err := .... Parse(...)</span><br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">if</span> err := parse.Execute(os.Stdout, <span class="hljs-literal">nil</span>);err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，由于文本模板通常在编译阶段就被固定下来了，如果 <code>Parse(...)</code> 函数执行出错将是一个严重的程序 BUG 。Go 提供了一个帮助函数 <code>template.Must(...)</code> ，它负责检查执行 <code>Parse(...)</code> 的过程中是否会出现异常，如果是，则程序会结束。如果一切正常，则过滤掉 <code>err</code> ，只返回一个创建成功的模板。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> template_ = <span class="hljs-string">`</span><br><span class="hljs-string">		===========</span><br><span class="hljs-string">		&#123;&#123;greet&#125;&#125;</span><br><span class="hljs-string">		===========</span><br><span class="hljs-string">    `</span><br><br>safeParse := template.Must(<br>    template.New(<span class="hljs-string">&quot;evokeFunction&quot;</span>).Funcs(<br>        template.FuncMap&#123;<span class="hljs-string">&quot;greet&quot;</span>: greet&#125;,<br>    ).Parse(template_),<br>)<br><br><span class="hljs-keyword">if</span> err := safeParse.Execute(os.Stdout, <span class="hljs-literal">nil</span>);err != <span class="hljs-literal">nil</span>  &#123;<br>    log.Fatal(err.Error())<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-3-模板内的循环体"><a href="#5-3-模板内的循环体" class="headerlink" title="5.3 模板内的循环体"></a>5.3 模板内的循环体</h3><p>如果希望模板遍历一个切片数据并渲染每一个元素，需要在文本模板内插入循环语句，这种感觉有点像在 <code>.jsp</code> 中写 EL 表达式。在这个例子中，文本模板渲染的是 <code>[]Employee</code> 类型的结构体切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>	<span class="hljs-keyword">const</span> temp = <span class="hljs-string">`</span><br><span class="hljs-string">         Author: &#123;&#123;.Name&#125;&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">		&#123;&#123;range .Employees&#125;&#125;</span><br><span class="hljs-string">		====================</span><br><span class="hljs-string">		name : &#123;&#123;.Name&#125;&#125;</span><br><span class="hljs-string">		age  : &#123;&#123;.Age&#125;&#125;</span><br><span class="hljs-string">		====================</span><br><span class="hljs-string">		&#123;&#123;end&#125;&#125;</span><br><span class="hljs-string">	`</span><br><br>	employees := []Employee&#123;<br>		&#123;<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">25</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;River&quot;</span>,<span class="hljs-number">23</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;NASA&quot;</span>,<span class="hljs-number">30</span>&#125;,<br>	&#125;<br><br>	data := <span class="hljs-keyword">struct</span>&#123;<br>		Employees []Employee<br>		Name <span class="hljs-keyword">string</span><br>	&#125;&#123;employees,<span class="hljs-string">&quot;Li&quot;</span>&#125;<br><br>	err := template.Must(template.New(<span class="hljs-string">&quot;aTest&quot;</span>).Parse(temp)).<br>		Execute(os.Stdout, data)<br><br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err.Error())&#125;<br><br>&#125;<br><br><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>	Name <span class="hljs-keyword">string</span><br>	Age <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在文本模板内，通过 <code>&#123;&#123;range ...&#125;&#125;</code> 展开了一个循环体，它以 <code>&#123;&#123;end&#125;&#125;</code> 作为结尾。首先，<code>range .Employees</code> 表明了它遍历的是 <code>data</code> 数据内的 <code>[]Employee</code> 切片，其次，该循环体内部的 <code>&#123;&#123;.Name&#125;&#125;</code> 指代的将是 “切片内每一个 <code>Employee</code> 数据的 <code>Name</code> 成员”，而非单指 <code>data</code> 数据内的 <code>.Name</code> 成员。</p>
<p>因此，运行此程序，控制台打印的结果将是：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">       Author: Li</span><br><br><br>====================<br>name : John<br>age  : 25<br>====================<br><br>====================<br>name : River<br>age  : 23<br>====================<br><br>====================<br>name : NASA<br>age  : 30<br>====================<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go: (一)入门</title>
    <url>/2021/03/15/Go%20(%E4%B8%80)%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>这篇主题包含 Go 语言的基本内容：变量声明，数据类型，字符串，( 无类型 ) 常量。</p>
<h1 id="第一章-入门"><a href="#第一章-入门" class="headerlink" title="第一章 入门"></a>第一章 入门</h1><h2 id="1-1-Hello-go"><a href="#1-1-Hello-go" class="headerlink" title="1.1 Hello, go!"></a>1.1 Hello, go!</h2><p>笔者的 IDE 为 Jet Brains 公司的 GoLand，辅导书籍为机械工业出版社的《Go 程序设计语言》。</p>
<p>Go 是一个编译型的语言。它像 C 语言那样将 <code>.go</code> 后缀的源代码直接编译，连接成本平台直接可用的 app 。下面的示例是第一个 Hello World 程序。注意，包含主程序的 <code>.go</code> 文件路径必须在名为 <code>main</code> 的目录下，主函数的名称也必须命名为 <code>main</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>	fmt.Print(<span class="hljs-string">&quot;Hello,世界&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以使用 <code>run</code> 命令直接编译并运行这段代码，也可以使用 <code>build</code> 命令将它编译成可被直接运行的二进制文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-variable">$sudo</span> go run ../main/goFirst.go<br><span class="hljs-variable">$sudo</span> go build ../main/goFirst.go<br></code></pre></td></tr></table></figure>

<p>在初学 go 语言时，还需要注意其它的杂项：</p>
<ol>
<li>在源代码中，不需要主动使用 <code>;</code> 做为一行代码的结尾，除非你将多行代码写到了同一行。</li>
<li>如果你引入了一个未被使用的包，或者是<u>在函数内声明了一个未被使用的局部变量</u>，go 编译器会给出一个 Error ，而不是 Warning。</li>
<li>你可以在 GoLand 的 Output Directory 中设置一个路径，以获得可直接运行的二进制文件。这样在下次运行程序时便无需编译了。</li>
</ol>
<h2 id="1-2-有关于命令行参数"><a href="#1-2-有关于命令行参数" class="headerlink" title="1.2 有关于命令行参数"></a>1.2 有关于命令行参数</h2><p>go 语言的命令行参数不会直接体现在 <code>main</code> 函数的参数列表上，而是需要借助一个 <code>os</code> 包去完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// Go 约定导入顺序应当按首字母顺序进行排列，但是这并不是必须的。</span><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 索引下标为 0 (即第一个命令行参数) 是编译后的 go 文件名本身。</span><br>	fmt.Print(os.Args[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; &quot;</span>)<br><br>	<span class="hljs-comment">// 用户输入的命令行参数从 1 开始。</span><br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(os.Args);i++ &#123;<br>		fmt.Print(os.Args[i] + <span class="hljs-string">&quot; &quot;</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，这里使用到了 <code>go</code> 语言当中的循环语句和短变量声明 ( 代码块中的 <code>i:=1</code> )，这并不妨碍去理解这个代码。通过 <code>os.Args[i]</code>  能获取到第 <code>i</code> 个命令行参数，其中，下标为 0 的命令行参数总是存在且被保留的。</p>
<p>在 GoLand IDE 中，可以在右上角的 <code>Edit Configurations =&gt; Configuration =&gt; Program arguments</code> 设置命令行参数。</p>
<h2 id="1-3-有关于-os-Args"><a href="#1-3-有关于-os-Args" class="headerlink" title="1.3 有关于 os.Args"></a>1.3 有关于 os.Args</h2><p><code>os.Args</code> 是一个 <code>string</code> 类型的 slice ，可以暂且将它理解成是其它编程语言中的数组 ( 这是一种妥协，实际上切片 slice 和数组 array 是两回事 )。刚才通过 <code>os.Args[i]</code> 访问了其中一个元素。</p>
<p>还可以简便的形式获取该 slice 的一个前闭后开区间，形如：<code>os.Args[m:n]</code>，这个切片包含 <code>os.Args[m]</code>，但是不会包含 <code>os.Args[n]</code>。其中，<code>0 &lt;= m &lt;= n &lt;= len(os.Args)</code>。对于任何一个 slice，都可以通过 <code>len(..)</code> 获取它的长度。</p>
<p>该写法存在缺省形式。比如：<code>os.Args[:n]</code>，此时被缺省的 <code>m</code> 即代表 <code>0</code> ；同样的，<code>os.Args[m:]</code>，此时被缺省的 <code>n</code> 即代表 <code>len(os.Args)</code> 。</p>
<p>鉴于下标为 0 的命令行参数总是保留的，因此通常都是使用 <code>os.Args[1:]</code> 来获取用户输入的命令行参数。如果你要获取一个完整的 <code>os.Args</code>，那就不需要带上任何中括号表示的位置，或区间。</p>
<h2 id="1-4-go-语言中的-for-循环"><a href="#1-4-go-语言中的-for-循环" class="headerlink" title="1.4 go 语言中的 for 循环"></a>1.4 go 语言中的 for 循环</h2><p>刚才的示例使用到了 for 循环。go 语言的循环语句只通过 <code>for</code> 关键字来实现。传统的 for 循环是这个样子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// go 语言中，它们不需要被一个()小括号括起来。</span><br><span class="hljs-keyword">for</span> init;condition;post &#123;<br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要实现一个 “while” 循环，则只需要给定一个 condition：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> condition &#123;<br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要实现一个无限循环，则什么都不加。这需要用户自己在循环体内部定义程序应在满足什么样的条件时跳出它，通过 <code>return</code> 或者是 <code>break</code> 来完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="1-5-range-关键字"><a href="#1-5-range-关键字" class="headerlink" title="1.5 range 关键字"></a>1.5 range 关键字</h2><p>下面的 for 循环中 ( 实际上这是一个 “while” 循环 ) 存在两个变量，一个是 <code>index</code>，一个是 <code>value</code>。故名思意，在每一次迭代中，它们一个用于获取 slice 下标，一个用于获取对应位置上的值。这里是通过 <code>range</code> 关键字来实现的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> index,value := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>	fmt.Println(<span class="hljs-string">&quot;index is &quot;</span>,index,<span class="hljs-string">&quot; and the value is &quot;</span>,value)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果不需要额外地处理获取到的下标 <code>index</code>，可以改用下划线 <code>_</code> 表示 “它是一个语法上必须存在而实际上不会被用到的变量” 以通过编译器的检查，因为 go 语言原则上不允许出现一个 “无用” 的变量。</p>
<p>下面的 for 循环相当于 Java 语言中的 for-each 循环，因为该循环体不关心切片的下标。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _,value := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:]&#123;<br>   <span class="hljs-comment">// 这是 go 语言中，输出信息到控制行的第二种形式：不引入 fmt 包，直接通过 print 关键字来完成。</span><br>   <span class="hljs-comment">// 该形式的输出不允许使用 + 将所有值拼接成一个字符串。 </span><br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;value is &quot;</span>,value,<span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>附，可以将 <code>(index,value)</code> 泛化成一个二元组整体，而 <code>range</code> 则允许你通过简易地方式提取出二元组的第一个和第二个元素。如果将它用于遍历这个切片，那么第一个元素是下标号，第二个元素是指定位置上存储的值。在后面的例子中，用到了 <code>range</code> 关键字从 map 数据结构中提取 k,v 键值对。</p>
<h2 id="1-6-关于声明变量"><a href="#1-6-关于声明变量" class="headerlink" title="1.6 关于声明变量"></a>1.6 关于声明变量</h2><p>前文出现了 Go 语言中的短变量声明方式，即：<code>i := value</code> 。在这种声明方式中，<code>i</code> 实际是什么类型将取决于 <code>value</code>。短变量声明只能用在函数内部的局部变量中，但是在函数内部，它是一种经常被使用的赋值方式。详情可参考第二章：关于变量：短变量声明。</p>
<p>另一个完整的变量声明格式是：<code>var i type = expr </code>。其中，<code>var</code> 是声明变量的关键字，<code>type</code> 是 Go 语言内置的，或是包中定义的数据类型。它可以声明在函数外部。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int8</span> = <span class="hljs-number">100</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="1-7-一个查找重复行的例子"><a href="#1-7-一个查找重复行的例子" class="headerlink" title="1.7 一个查找重复行的例子"></a>1.7 一个查找重复行的例子</h2><p>尝试实现这样的功能，程序接收若干次用户输入 ( 每一次输入况且称之为 “line” )，并且在用户输入结束后进行检查，查找出现次数大于 1 次的 line 。显然，在这里需要以下两样工具，然后体验如何在 Go 语言中利用它们：</p>
<ol>
<li><code>map</code> 类型的数据结构，用于记录用户的输入内容以及它出现的次数。</li>
<li>输入流。</li>
</ol>
<p>对于第一条，Go 语言使用下面的语法创建一个 map，然后将<strong>它的引用</strong>赋值给 count 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">count := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>)<br><span class="hljs-comment">// 设置一个键值对：(&quot;hello&quot;,1)</span><br>count[<span class="hljs-string">&quot;hello&quot;</span>] = <span class="hljs-number">1</span><br><span class="hljs-comment">// 或者，直接将 key &quot;hello&quot; 对应的值进行自增操作：</span><br>count[<span class="hljs-string">&quot;hello&quot;</span>] ++<br></code></pre></td></tr></table></figure>

<p>对于第二条，可以使用 <code>bufio</code> 包下的 <code>NewScanner</code> 获取一个监控标准输入流 stdin 的扫描器 ( Scanner ) 以获取用户通过键盘传输的内容，这和其它语言相比并没有什么不同。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">input := bufio.NewScanner(os.Stdin)<br><span class="hljs-comment">// 阻塞式等待用户输入</span><br>input.Scan()<br><span class="hljs-comment">// 输出刚才用户输入的一行内容</span><br>input.Text()<br></code></pre></td></tr></table></figure>

<p>额外的，Go 提供一种格式化输出形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">100</span><br>fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,i)<br></code></pre></td></tr></table></figure>

<p>这些信息已经足够实现出功能了。代码块如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;bufio&quot;</span><br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>	counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>)<br>	input := bufio.NewScanner(os.Stdin)<br><br>	<span class="hljs-comment">// 相当于一个 while 循环。如果输入 -1 则退出。</span><br>	<span class="hljs-keyword">for</span> input.Scan() &#123;<br>		<span class="hljs-keyword">if</span> input.Text() == <span class="hljs-string">&quot;-1&quot;</span> &#123;<span class="hljs-keyword">break</span>&#125;<br>		counts[input.Text()]++<br>	&#125;<br><br>    <span class="hljs-comment">// 有关 range 的介绍请参考前文。</span><br>	<span class="hljs-keyword">for</span> key,count := <span class="hljs-keyword">range</span> counts &#123;<br>		<span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">1</span> &#123;<br>			fmt.Printf(key + <span class="hljs-string">&quot; 的出现次数大于 1 次。实际出现了：%d 次。&quot;</span>,count)<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="1-8-尝试从本地文件中读取内容"><a href="#1-8-尝试从本地文件中读取内容" class="headerlink" title="1.8 尝试从本地文件中读取内容"></a>1.8 尝试从本地文件中读取内容</h2><p>从刚才查找重复行的例子继续讨论。这一次不再通过控制台输入的方式进行人机交互，而是在运行程序时直接指定一个文本文件，然后让程序去实现相同的功能。至少，应当知道如何令 Go 程序根据一个 <code>string</code> 类型的路径去尝试打开对应的文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">os.Open(<span class="hljs-string">&quot;/usr/hello_world.txt&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>这个函数将返回两个值 ( <strong>在 Go 语言中，一个函数可以返回多个值</strong>。而笔者则倾向于理解成返回一个包含多个值的多元组 )，因此需要两个变量去分别接收它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">file,err := os.Open(<span class="hljs-string">&quot;/usr/hello_world.txt&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>为了弄清楚这两个值的类型和作用，需要跟进到源码当中去一探究竟：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*File, error)</span></span> &#123;<br>	<span class="hljs-keyword">return</span> OpenFile(name, O_RDONLY, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显然，第一个返回值是一个 <code>File</code> 类型的指针，而第二个值代表着在打开文件时可能遇到的错误，比如给定的文件路径并不存在。在正常情况下，第二个值应当为 <code>nil</code> ( 表示第二个值为空 ) ，否则说明打开文件的过程中遇到了问题。</p>
<p>除此之外，在这里仍然使用 <code>bufio.NewScanner</code> 获取一个 Scanner，但是它的参数不再是 stdin，而是刚才通过 <code>os.Open</code> 获取的那个指向文件的指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">scanner := bufio.NewScanner(file)<br></code></pre></td></tr></table></figure>

<p>下面给定完整的程序逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;bufio&quot;</span><br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	path := os.Args[<span class="hljs-number">1</span>]<br>	open, err := os.Open(path)<br>	counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int8</span>)<br><br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		fmt.Printf(err.Error())<br>		os.Exit(<span class="hljs-number">-1</span>)<br>	&#125;<br><br>	input := bufio.NewScanner(open)<br><br>	<span class="hljs-keyword">for</span> input.Scan() &#123;<br>		counts[input.Text()]++<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> k,n := <span class="hljs-keyword">range</span> counts&#123;<br>		<span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v 出现的次数大于 1 次，实际出现了：%d 次。&quot;</span>,k,n)&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="1-9-从网络中获取信息"><a href="#1-9-从网络中获取信息" class="headerlink" title="1.9 从网络中获取信息"></a>1.9 从网络中获取信息</h2><p>使用 Go 提供的包能够非常便捷地获取 / 发送来自网络上的信息。对于一些应用而言，它的数据源可能并不在本地，而是来自另一个主机。因此，访问网络数据和访问本地文件一样重要。</p>
<p>这里需要使用到两个包：<code>net/http</code> 以及 <code>io/ioutil</code> 。其中，通过 <code>http.Get(&quot;...&quot;)</code> 获取网络信息，参数是一个字符串类型的 URL 。它的返回值同样有两个：一个是请求成功的响应，另一个代表可能出现的异常。</p>
<p>当请求成功时，可以使用 <code>ioutil.ReadAll(...)</code> 一次性将内容暂存到缓冲区，以便于后续对响应报文的内容进做一步分析。在这个简单的示例中，仅仅是将它输出到控制台中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	resp, httpErr := http.Get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br>	<span class="hljs-keyword">if</span> httpErr != <span class="hljs-literal">nil</span> &#123; fmt.Printf(httpErr.Error());os.Exit(<span class="hljs-number">-1</span>)&#125;<br><br>	body, respErr := ioutil.ReadAll(resp.Body)<br>	<span class="hljs-keyword">if</span> respErr != <span class="hljs-literal">nil</span> &#123;fmt.Printf(respErr.Error());os.Exit(<span class="hljs-number">-1</span>)&#125;<br><br>	<span class="hljs-comment">// 通过 %s 直接将字节流格式化并输出成字符串。</span><br>	fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,body)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果想在获取到响应内容之后直接在控制台 ( 对应 <code>os.Stdout</code> ) 中输出，那么可以通过 <code>os.Copy</code> 来实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">resp, httpErr := http.Get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><span class="hljs-keyword">if</span> httpErr != <span class="hljs-literal">nil</span> &#123; fmt.Printf(httpErr.Error());os.Exit(<span class="hljs-number">-1</span>)&#125;<br><span class="hljs-comment">// 虽然可以直接携程 io.Copy(os.Stdout,resp.Body)，但是下面的写法明确表示该函数具备返回值，只不过在这里被主动忽略了。</span><br>_ , _ = io.Copy(os.Stdout, resp.Body)<br>resp.Body.Close()<br></code></pre></td></tr></table></figure>

<p>使用 <code>_,_</code> 表示忽略掉 <code>Copy</code> 函数提供的<strong>所有内容</strong> ( 第一个 <code>int64</code> 值记录了读取的字节数，第二个值表示可能出现的错误 )，在该情景下，赋值符号将使用 <code>=</code> 而不是 <code>:=</code> 。( 详细的原因会在 第二章：关于变量：短变量声明中说明 )</p>
<p>可以从 resp 本身抽取响应报文的其它信息，包括了响应头 ( Header )，状态码 ( StatusCode)，协议版本号 ( Proto )。而协议版本号又被拆分为了协议主版本号 ProtoMajor 和次版本号 ProtoMinor 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">fmt.Print(resp.Header)<br>fmt.Print(resp.StatusCode)<br>fmt.Print(resp.Proto)<br>fmt.Print(resp.ProtoMajor)<br>fmt.Print(resp.ProtoMinor)<br></code></pre></td></tr></table></figure>

<p>在使用完 resp 之后，应当调用 <code>Close()</code> 主动关闭资源。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这里省略的是可能抛出的 error</span><br>_ = resp.Close()<br></code></pre></td></tr></table></figure>

<h2 id="1-10-第一个-Super-Mini-Go-网络服务器"><a href="#1-10-第一个-Super-Mini-Go-网络服务器" class="headerlink" title="1.10 第一个 Super Mini Go 网络服务器"></a>1.10 第一个 Super Mini Go 网络服务器</h2><p>在这节中，仅通过一个库函数 <code>http.HandleFunc(...)</code>  和 <code>http.ListenAndServe(...)</code> 就可以构建一个迷你的 Web 服务器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">http.HandleFunc(<span class="hljs-string">&quot;/hello&quot;</span>,handler)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>,<span class="hljs-literal">nil</span>))<br></code></pre></td></tr></table></figure>

<p>而 handler 则是指定了形参类型的，当库函数 <code>HandlerFunc</code> 接收到请求时调用的另一个函数。<code>HandleFunc</code> 在监听到请求时作何反应，取决于这个 handler 的逻辑。作为一个示例程序，这里的响应仅仅是简单地将用户请求的路径写回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;<br>   _, _ = fmt.Fprintf(w, <span class="hljs-string">&quot;url = %s&quot;</span>, r.URL.Path)<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第二章-基础数据"><a href="#第二章-基础数据" class="headerlink" title="第二章 基础数据"></a>第二章 基础数据</h1><h2 id="2-1-关于声明"><a href="#2-1-关于声明" class="headerlink" title="2.1 关于声明"></a>2.1 关于声明</h2><p>Go 语言中存在 4 种类型的声明，包括了变量 <code>var</code>，函数 <code>func</code>，类型 <code>type</code> 和常量 <code>const</code> ( 不可变 )。</p>
<p>Go 语言中的声明是<strong>大小写敏感</strong>的。变量名称的首字符是否大小写，决定它们是否对外部 ( 指其它包 ) 可见。如果声明的变量以大写字母开头，则它可以被其它包可见，前提是这些声明都是顶层的 ( 后续称这样的变量为包变量) 。</p>
<p>所有函数内部的声明都是<strong>作用域外</strong>不可见的，即便它是大写开头。比如，即使在一个函数 <code>func</code> 内部定义了一个常量 <code>const</code>，该常量也仅可以在函数内部被使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 不对其它包可见，但是对该 .go 文件下的其它地方可见。</span><br><span class="hljs-keyword">var</span> aInt <span class="hljs-keyword">int8</span> = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 对其它包可见</span><br><span class="hljs-keyword">var</span> AInt <span class="hljs-keyword">int8</span> = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 该常量对其它包可见</span><br><span class="hljs-keyword">const</span> Pi <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.1415926</span><br><br><span class="hljs-comment">// 该函数不对其它包可见</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getTuple3</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>&#123;<br>    <br>    <span class="hljs-comment">// 该变量不对外部可见</span><br>    <span class="hljs-keyword">var</span> aDouble <span class="hljs-keyword">float64</span> =<span class="hljs-number">1.00</span><br>    <br>    <span class="hljs-comment">// 该常量不对外部可见</span><br>    <span class="hljs-keyword">const</span> innerPi <span class="hljs-keyword">float32</span> = <span class="hljs-number">3.14</span><br>    fmt.Print(innerPi)<br>    <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-comment">// 该函数对其他包可见</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetTuple2</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-2-关于变量"><a href="#2-2-关于变量" class="headerlink" title="2.2 关于变量"></a>2.2 关于变量</h2><h3 id="2-2-1-变量命名"><a href="#2-2-1-变量命名" class="headerlink" title="2.2.1 变量命名"></a>2.2.1 变量命名</h3><p>Go 语言中的变量名可以由下划线 <code>_</code> ，数字，和字母构成，但是不可以数字开头。Go 语言支持定义一个中文名称的变量，但一般不会这样做。</p>
<p>当然，Go 语言中的关键字是被保留的，不过无需死记硬背。另外，Go 语言中还有一些预保留的名称 ( <code>make</code> 函数，<code>len</code> 函数，<code>new</code> 函数，<code>int</code> 类型 ) ，但是为了避免混淆，也不会起这样的名称。</p>
<h3 id="2-2-2-关于变量"><a href="#2-2-2-关于变量" class="headerlink" title="2.2.2 关于变量"></a>2.2.2 关于变量</h3><p>一个标准的变量声明应当是这样的：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">type</span> = expression<br></code></pre></td></tr></table></figure>

<p>一般情况下，<code>type</code> 和 <code>expression</code> 只要声明其一即可。Go 语言中所有的数据结构都具备零值，因此这不会引发因未初始化而导致的 “<code>NullPointerException</code> “。对于数据，这个零值就是 <code>0</code> ；对于布尔值，零值为 <code>false</code>；对于接口和引用类型，零值为 <code>nil</code> ；对于更复杂的组合类型，零值为内部所有元素的零值。</p>
<p>如果要一次性声明多个同一种数据类型的变量，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明了 3 个 int8 类型的变量</span><br><span class="hljs-keyword">var</span> a,b,c <span class="hljs-keyword">int8</span><br></code></pre></td></tr></table></figure>

<p>如果要匹配方式在一行代码内为不同类型的变量赋不同类型的值，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a,b,c = <span class="hljs-literal">true</span>,<span class="hljs-number">1.00</span>,<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>这种方式又称之为多重赋值 (见后文) 。右侧可以是表达式，只要它的返回值列表能够和声明的变量列表相匹配：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f,err = os.Open(...)<br></code></pre></td></tr></table></figure>

<p>声明一个局部变量有两个选择：标准的变量声明和短变量声明。在格外强调严谨的数据类型的场合，会用到 <code>var</code> 关键字。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// x 默认情况下是 int 类型。</span><br>x := <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 通过 var 显式声明 y 是 int8 类型。</span><br><span class="hljs-keyword">var</span> y <span class="hljs-keyword">int8</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>如果通过短变量声明的方式，那么 <code>x</code> 总是一个 <code>int</code> 类型的数据，而不是一个 <code>int8</code> 类型的数据。</p>
<h3 id="2-2-3-利用多重赋值实现两数交换"><a href="#2-2-3-利用多重赋值实现两数交换" class="headerlink" title="2.2.3 利用多重赋值实现两数交换"></a>2.2.3 利用多重赋值实现两数交换</h3><p>在其它语言中实现两数交换，普遍的逻辑可能是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> a,b = <span class="hljs-number">1</span>,<span class="hljs-number">3</span><br>	a = a + b<br>	b = a - b<br>	a = a - b<br>	fmt.Print(<span class="hljs-string">&quot;A = &quot;</span>,a,<span class="hljs-string">&quot; B = &quot;</span>,b)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但实际上，这在 Go 可以通过多重赋值实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a,b = <span class="hljs-number">1</span>,<span class="hljs-number">3</span><br><span class="hljs-keyword">var</span> b,a = a,b<br></code></pre></td></tr></table></figure>

<p>多重赋值非常适用于同一个变量同时出现在赋值表达式左右两侧的情况。其逻辑是：程序会预先计算出赋值号右侧位置的实际值，然后再一次性为左边的变量赋值，因此这避免了交换变量时的值覆盖问题。</p>
<h3 id="2-2-4-短变量声明"><a href="#2-2-4-短变量声明" class="headerlink" title="2.2.4 短变量声明"></a>2.2.4 短变量声明</h3><p>在之前已经接触了短变量声明的写法，它只能出现在函数内部。注意，不要将 <code>:=</code> 和 <code>=</code> 等同起来，因为短变量声明仍然是声明，指代创建了一个新的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 新声明了一个变量 a，它的值被初始化为 1 。</span><br>a := <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>短变量声明在某种特殊情况下可以被认为是赋值。下面的代码<strong>在至少声明了一个新变量</strong> <code>a</code>  的同时，顺带也为已有的变量 <code>b</code> 和 <code>c</code> 进行了重新赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b,c = <span class="hljs-number">1</span>,<span class="hljs-number">2</span><br><span class="hljs-comment">// 对 a 而言是声明，对 b 和 c 而言则是重新赋值。</span><br>a,b,c := <span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span><br><span class="hljs-comment">//</span><br>fmt.Print(a,b,c)<br></code></pre></td></tr></table></figure>

<p>如果短变量声明的表达式左边没有任何一个新变量，那么它就会被禁用。这些变量只能通过 <code>=</code> 重新赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b,c = <span class="hljs-number">1</span>,<span class="hljs-number">2</span><br>b,c := <span class="hljs-number">4</span>,<span class="hljs-number">5</span><br>fmt.Print(b,c)<br></code></pre></td></tr></table></figure>

<p>这也解释了这段代码将是无法跑通的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">_, _ := fmt.Fprintf(w, <span class="hljs-string">&quot;url = %s&quot;</span>, r.URL.Path)<br></code></pre></td></tr></table></figure>

<h3 id="2-2-5-指针与-new-函数"><a href="#2-2-5-指针与-new-函数" class="headerlink" title="2.2.5 指针与 new 函数"></a>2.2.5 指针与 new 函数</h3><p>对于学习过 C/C++ 而言的人，指针一定不陌生 ( 或者说，恐惧 ) 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// x 指向一个值 1</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// p 指向一个地址，这个地址是 x 的。</span><br><span class="hljs-keyword">var</span> p = &amp;x<br><br><span class="hljs-comment">// p 指向一个地址，这个地址是 x，的，*p 获取了 x 指向的那个值 1。</span><br>fmt.Print(*p)<br></code></pre></td></tr></table></figure>

<p>指针指向一个变量的地址。不是所有的值都具备地址，但是所有的变量都有。使用指针的最大好处就是在不知道变量名的情况下就能够间接读取或更新变量的值。比如在之前的例子中曾调用的 <code>os.Open(...)</code> 函数，它返回的就一个匿名的 <code>*File</code> 指针。通俗地来讲，它将文件的内容提取到了内存的某一处之后，将门牌号留给了主函数。这样，即便是在 <code>os.Open(...)</code> 函数在调用完并出栈之后，主函数仍然能够顺着这个 “门牌号” 找到留下来的文件内容。</p>
<p>下面的函数 <code>f()</code> 总是返回一个指向一个值为 <code>1</code> 的地址的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> *<span class="hljs-title">int</span></span> &#123;<br>   x:=<span class="hljs-number">1</span><br>   <span class="hljs-keyword">return</span> &amp;x <br>&#125;<br><br><span class="hljs-comment">// 由于 f() 返回的是指向 1 的指针，因此即便在 f() 被退栈之后 p 仍然可以访问到这个值。</span><br><span class="hljs-keyword">var</span> p = f()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-comment">// f() 虽然返回的都是指向 1 的地址，但是这两个地址值并不相同。</span><br>   <span class="hljs-comment">// 运行结果将是 false。</span><br>   fmt.Print(f() == f())<br>&#125;<br></code></pre></td></tr></table></figure>

<p>值得注意的是，每次为一个值变量 <code>x</code> 创建一个指针 <code>p</code> ，或者后续将这个指针进行复制，都相当于不断地创建了 <code>x</code> 的 “别名”。比如，<code>*p</code> 就是 <code>x</code> 的别名，更改 <code>*p</code> 就相当于更改变量 <code>x</code> 。别名越多，则意味着 <code>x</code>  越有可能受其它的函数副作用影响而发生更改。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// &quot;声明时带 * 号表示这是一个指向某个数据结构的地址的指针.&quot;</span><br><span class="hljs-keyword">var</span> _ *<span class="hljs-keyword">int8</span><br><br><span class="hljs-comment">// 通过库函数的 new 也可以直接创建出指向某种数据结构的指针。</span><br>_ = <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br></code></pre></td></tr></table></figure>

<h3 id="2-2-6-变量的生存周期"><a href="#2-2-6-变量的生存周期" class="headerlink" title="2.2.6 变量的生存周期"></a>2.2.6 变量的生存周期</h3><p>变量的生命周期指在程序的运行时期，某个变量存在的时间段。这主要针对局部变量而言，因为包级别的变量是在程序运行过程当中 “全程存活” 的。局部变量指在某个语句块内生效 ( 比如函数内的局部变量 ) 。当函数执行完毕时，这些变量将大概率变得 “不可达”。这时它们就会在某一次垃圾回收的过程中被清除掉，来为内存释放空间。</p>
<p>而一旦局部变量的指针将自己的值赋值给外部指针，就会引发 “逃逸” 现象。比如说下面的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> x <span class="hljs-keyword">int8</span> = <span class="hljs-number">1</span><br>	p2Int = &amp;x<br>&#125;<br><br><span class="hljs-keyword">var</span> p2Int *<span class="hljs-keyword">int8</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	f()<br>	<span class="hljs-comment">// 能够正常打印数值</span><br>	<span class="hljs-keyword">if</span> p2Int != <span class="hljs-literal">nil</span> &#123;<br>		fmt.Print(*p2Int)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;error: p2Int 是个空指针&quot;</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>f()</code> 函数没有返回值，但是具备副作用。这是因为函数内部将 <code>x</code> 的地址留给了外部的变量 <code>p2Int</code> 。这样，垃圾回收器就会避免回收掉变量 <code>x</code> 所在的那片内存空间，因为仍然有一个 <code>p2Int</code> 指向它。此时称之为 <code>x</code> 从它的局部域当中 “逃逸” 了。</p>
<h2 id="2-3-类型声明"><a href="#2-3-类型声明" class="headerlink" title="2.3 类型声明"></a>2.3 类型声明</h2><p>类型声明的功能类似于 <code>typedef</code> ，为已有的数据类型起一个新的别名。比如说一个 <code>int8</code> 类型的数据，从语义上它可以代表 “月份”，”星期数”，”年龄”，”分数”。在不至混淆的情形下，可以为这个 <code>int8</code> 起一个新的名字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Age <span class="hljs-keyword">int8</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<br>	<span class="hljs-keyword">var</span> n Age = <span class="hljs-number">24</span><br>	fmt.Printf(<span class="hljs-string">&quot;前辈今年 %d 岁了&quot;</span>,n)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不同的类型声明总是被认为是不同的，即便它们其实都指代同一种数据类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Age <span class="hljs-keyword">int8</span><br><span class="hljs-keyword">type</span> Score <span class="hljs-keyword">int8</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>	<span class="hljs-keyword">var</span> n Age = <span class="hljs-number">24</span><br>	<span class="hljs-keyword">var</span> s Score = <span class="hljs-number">100</span><br>	<br>	<span class="hljs-comment">// 编译错误，因为 s 是 Score 类型，而 n 是 Age 类型。</span><br>	s = n	<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-4-包管理"><a href="#2-4-包管理" class="headerlink" title="2.4 包管理"></a>2.4 包管理</h2><p>Go 以包为单位管理源码，以支持模块化，和代码重用。所有项目的 <code>.go</code> 都保管在一个包内。包的名字和其路径相对应。比如一个包的名字是 <code>awesomeProject/vars</code> ，那么该包的实际路径就是 <code>$GO_PATH/src/awesomeProejct/vars</code> 。</p>
<p>每个包内的声明都是相互独立的，比如说 <code>os.Open(...)</code> 和 <code>me.Open(...)</code> 就是两码事。前文已经提过，程序员可以通过修改声明的首字母大小写来决定它是否对包外可见，因此 Go 不需要诸如 <code>public</code> ，<code>private</code> 之类的权限修饰符。</p>
<p>包的初始化总是从<strong>初始化包级别的变量开始</strong>。默认情况下按照声明顺序进行初始化，但是也要考虑到变量之间的依赖关系。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = b + c<br><span class="hljs-keyword">var</span> b = f()<br><span class="hljs-keyword">var</span> c = <span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">return</span> c + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这种情况下，解决变量 <code>c</code> 才是当务之急。只有 <code>c</code> 初始化之后，<code>b</code> 才能调用函数 <code>f()</code> 进行初始化，最后才是变量 <code>a</code> 。</p>
<p>如果一个包下存在多个 <code>.go</code> 文件，那么编译时 go 工具会率先对一个包的 <code>.go</code> 文件进行排序，然后发送到 <code>go</code> 编译器中进行有序编译。</p>
<p>在有些情况下，包变量的初始化不是简单地赋零值 ( 或其它值 ) ，比如说初始化对某个数据库的连接，并获取连接池。这需要一系列的步骤才能完成。Go 语言提供一个较为特殊的初始化函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">//TODO 初始化代码，设计到复杂初始化的过程可以选择在这里进行。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码的其它地方无法主动地调用名为 <code>init()</code> 的函数。它只会程序初始化时被主动调用。一个 <code>.go</code> 文件可以有任意多个数量的 <code>init()</code> 函数，初始化时按照这些 <code>init()</code> 的声明顺序执行。</p>
<p>包和包之间的初始化顺序也是根据依赖顺序进行的。这样保证了如果包 <code>b</code> 依赖包 <code>a</code> ，则 <code>a</code> 一定以及在 <code>b</code> 之前就被初始化了。在所有的包都被初始化之后，最后初始化项目中名为 <code>main</code> 的包。</p>
<h2 id="2-5-作用域"><a href="#2-5-作用域" class="headerlink" title="2.5 作用域"></a>2.5 作用域</h2><p>作用域是任何编程语言当中都存在的概念。一般都通过语法块 ( 显式地使用 <code>&#123;&#125;</code> 括起来 ) 或者是词法块 ( <code>for</code> ,<code>if</code> 语句中的每一个条件都是单独的作用域 ) 来判断一个变量的作用域。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">&#123;<br>    <span class="hljs-keyword">var</span> f = <span class="hljs-number">100</span><br>    fmt.Print(f)<br>&#125;<br><br><span class="hljs-comment">// f 对外部的语法块不可见</span><br>fmt.Print(f)<br></code></pre></td></tr></table></figure>

<p>第二个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// i 仅在下面的词法块和后面的语句块内可见</span><br><span class="hljs-keyword">if</span> i := getTure();i == <span class="hljs-literal">false</span> &#123;<br>	fmt.Print(i)<br>&#125;<br><br>fmt.Print(i)<br></code></pre></td></tr></table></figure>

<p>当变量出现重名时，对内部块的变量而言，外部块的那个变量并不可见。对于外部块的变量而言，内部块的那个变量所发生的改变也不会影响到自身。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int8</span> = <span class="hljs-number">10</span><br>&#123;<br>   <span class="hljs-keyword">var</span> i <span class="hljs-keyword">int8</span> = <span class="hljs-number">20</span><br>   <span class="hljs-comment">//20</span><br>   <span class="hljs-built_in">println</span>(i)<br>&#125;<br><span class="hljs-comment">//10</span><br><span class="hljs-built_in">println</span>(i)<br></code></pre></td></tr></table></figure>

<p>在使用短变量声明时，尤其要注意这个 “陷阱”：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> hello <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 赋值的是包变量 hello。</span><br>	hello = <span class="hljs-string">&quot;halo&quot;</span><br>	<span class="hljs-built_in">println</span>(hello)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// 这相当于是创建了一个新的 main 内部的局部变量 hello,而不是给包变量 hello 赋值。</span><br>	hello := <span class="hljs-string">&quot;hello&quot;</span><br>	<span class="hljs-built_in">println</span>(hello)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要在 <code>main</code> 函数内使用包变量 <code>hello</code>，那么就不应该在其作用域内通过短变量声明再创建一个同名变量来覆盖它。</p>
<h1 id="第三章-数据类型"><a href="#第三章-数据类型" class="headerlink" title="第三章 数据类型"></a>第三章 数据类型</h1><h2 id="3-1-整数"><a href="#3-1-整数" class="headerlink" title="3.1 整数"></a>3.1 整数</h2><p>Go 语言将整数进行了详细的划分：8 位有符号整数，16 位有符号整数，32 位有符号整数，64 位有符号整数，分别对应 <code>int8</code> ，<code>int16</code>，<code>int32</code>，<code>int64</code> 。以 <code>int8</code> 为例，它可以表示的范围是 -2<sup>7</sup> ~ 2<sup>7</sup> - 1 。</p>
<p>与此同时，整数还可以分为无符号整数，它们和有符号整数的位数相对应，如 <code>uint8</code>，<code>uint16</code>，<code>uint32</code>，<code>uint64</code> 。由于不需要考虑符号位，因此以 <code>uint8</code> 为例，它可以表示的范围是 0 ~ 2<sup>8</sup> 。</p>
<p>注意，如果变量的数值超过了其数据结构能表示的范围，那么计算结果会因为溢出而产生错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> aInt8 <span class="hljs-keyword">int8</span> = <span class="hljs-number">127</span><br><span class="hljs-keyword">var</span> result = aInt8 + <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 符号位溢出，导致运算结果是 -128</span><br>fmt.Print(result)<br></code></pre></td></tr></table></figure>

<p>Go 语言提供了两个不指定位数的整数类型 <code>int</code> 和 <code>uint</code> 。它们有可能是 32 位，也有可能是 64 位，实际位数要取决于各个平台的编译器。可以 <code>unsafe.Sizeof</code> 进行检查：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> aInt <span class="hljs-keyword">int</span><br>fmt.Print(unsafe.Sizeof(aInt))<br></code></pre></td></tr></table></figure>

<p>因此，<code>int</code> 类型的数值不能简单地和 <code>int32</code> 或者是 <code>int64</code> 数值等同起来，它们之间要进行一步显式地转换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> aInt <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> aInt64 <span class="hljs-keyword">int64</span><br><br><span class="hljs-comment">//强制转换</span><br>aInt64 = <span class="hljs-keyword">int64</span>(aInt)<br>fmt.Print(aInt64)<br></code></pre></td></tr></table></figure>

<p>另外，<code>byte</code> 类型可以被认为是 <code>uint8</code> 的同义词。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> aByte <span class="hljs-keyword">byte</span> = <span class="hljs-number">0xFF</span><br><span class="hljs-keyword">var</span> aInt <span class="hljs-keyword">uint8</span><br><br><span class="hljs-comment">// 不需要进行强制转换而直接赋值</span><br>aInt = aByte<br>fmt.Print(aInt)<br></code></pre></td></tr></table></figure>

<h2 id="3-2-浮点数"><a href="#3-2-浮点数" class="headerlink" title="3.2 浮点数"></a>3.2 浮点数</h2><p>Go 语言没有 “double”  一说，而是统一采用了 <code>float</code> 的称谓，分为 <code>float32</code> 和 <code>float64</code> 。十进制数下，<code>float32</code> 的有效数字大约是 6 位，而 <code>float64</code> 的有效数字大约是 15 位。在绝大部分情况下，应该优先选择 <code>float64</code> 类型，以获得尽可能精准的运算结果。</p>
<p>浮点数还以有以下表示法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> aDouble <span class="hljs-keyword">float64</span> = <span class="hljs-number">.05</span>            <span class="hljs-comment">//0.05d</span><br><span class="hljs-keyword">var</span> aDouble2 <span class="hljs-keyword">float64</span> = <span class="hljs-number">1.</span>            <span class="hljs-comment">// 1.00d</span><br><span class="hljs-keyword">var</span> aDouble3 <span class="hljs-keyword">float64</span> = <span class="hljs-number">.0100010001e4</span> <span class="hljs-comment">//100.010001</span><br><br><span class="hljs-comment">// 一般情况，%g 会保留足够精确的位数。</span><br>fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>,aDouble)<br><br><span class="hljs-comment">// %f 表示非指数表示法。</span><br>fmt.Printf(<span class="hljs-string">&quot;%f\n&quot;</span>,aDouble2)<br><br><span class="hljs-comment">// %e 指数表示法，如 e+02 表示 10^2。</span><br>fmt.Printf(<span class="hljs-string">&quot;%e\n&quot;</span>, aDouble3)<br></code></pre></td></tr></table></figure>

<h2 id="3-3-布尔值"><a href="#3-3-布尔值" class="headerlink" title="3.3 布尔值"></a>3.3 布尔值</h2><p>布尔值在 Go 语言中写做 <code>bool</code>，它仅有两种可能，<code>false</code> 或者是 <code>ture</code>。布尔计算可能会引起短路结果：以 <code>expr1 &amp;&amp; expr2</code> 为例，如果 <code>expr1</code> 的结果为 <code>false</code> ，那么这个表达式的整体结果一定是 <code>false</code>，因此程序不会再去计算 <code>expr2</code> 表达式。对于 <code>||</code> ，则是当 <code>expr1</code> 为 <code>false</code> 时，程序才会去计算 <code>expr2</code> 表达式。</p>
<p>总体来说，如果仅通过表达式左边就能确定计算结果的话，那么之后的所有表达式计算都会被忽略掉。此外，Go 语言中的布尔值不会被隐式地转换成数值类型，比如 0 或者 1 。</p>
<h2 id="3-4-字符串与-Unicode"><a href="#3-4-字符串与-Unicode" class="headerlink" title="3.4 字符串与 Unicode"></a>3.4 字符串与 Unicode</h2><p>Go 语言中的字符串类型直接使用关键字 <code>string</code>。任何对某一个字符串的操作只会返回一个新的字符串序列，而不会改变原来的字符串本身。</p>
<p>使用 <code>len</code> 函数获取字符串长度，得到的将不是文本长度，而是该文本所占用字节数。 如果以 <strong>切片</strong> 的形式截取字符串，以直接获取字符串某个位置上的字符，需要深入到 “其底层的字节切片” 中去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> aString <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;你好，我是 Go&quot;</span><br><br><span class="hljs-comment">// 在 UTF-8 编码格式中，一个汉字占 3 个存储字节。</span><br><span class="hljs-comment">// 这个字符串有 4 个汉字，1个全角标点符号，占 5 x 3 = 15 bytes;</span><br><span class="hljs-comment">// 还有一个空格，两个字母，这些 ASCII 符号在 UTF-8 编码格式只占用 1 个字节，因此它们仅占 3 x 1 = 3 bytes;</span><br><span class="hljs-comment">// 因此，这个字符串一共占用 18 bytes.</span><br><span class="hljs-built_in">println</span>(<span class="hljs-built_in">len</span>(aString))<br><span class="hljs-comment">// &quot;好，我是 Go&quot;</span><br><span class="hljs-built_in">println</span>(aString[<span class="hljs-number">3</span>:])<br><span class="hljs-comment">// &quot;好，我是&quot;</span><br><span class="hljs-built_in">println</span>(aString[<span class="hljs-number">3</span>:<span class="hljs-built_in">len</span>(aString) - <span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure>

<p>下面的例子能够体现字符串的不可变性：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">var</span> f = s<br><br><span class="hljs-comment">// s 指向了一个新的引用 &quot;hello,world&quot;，但是原 &quot;hello&quot; 字符串没有变化，因此 f 仍然是安全的。</span><br>s += <span class="hljs-string">&quot;,world&quot;</span><br><br><span class="hljs-built_in">println</span>(s)<br><span class="hljs-comment">// f 仍然输出 &quot;hello&quot;</span><br><span class="hljs-built_in">println</span>(f)<br></code></pre></td></tr></table></figure>

<p>字符串的不可变性使得字符串子串可以安全地共享同一段底层内存，从而避免额外的开销。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">系统中的一段内存<span class="hljs-symbol">:</span><br>h e l l o , w o r l d<br>↑-----------|-------|<br><span class="hljs-built_in">var</span> <span class="hljs-symbol">s1</span>      |<br><span class="hljs-built_in">len</span>=<span class="hljs-number">11</span>      ↑-------|<br>            <span class="hljs-built_in">var</span> <span class="hljs-symbol">s2</span><br><span class="hljs-symbol"></span>            <span class="hljs-built_in">len</span> =<span class="hljs-number">5</span><br><br><span class="hljs-built_in">var</span> <span class="hljs-symbol">s1</span> = <span class="hljs-string">&quot;hello,world&quot;</span><br><span class="hljs-built_in">var</span> <span class="hljs-symbol">s2</span> = <span class="hljs-string">&quot;world&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="3-5-Go-与-Java-如何抽取字符串中的一个汉字？"><a href="#3-5-Go-与-Java-如何抽取字符串中的一个汉字？" class="headerlink" title="3.5 Go 与 Java 如何抽取字符串中的一个汉字？"></a>3.5 Go 与 Java 如何抽取字符串中的一个汉字？</h2><h3 id="3-5-1-Java-方"><a href="#3-5-1-Java-方" class="headerlink" title="3.5.1 Java 方"></a>3.5.1 Java 方</h3><p>Java 的 <code>.class</code> 文件不采用任何额外的编码格式而直接使用 Unicode 码元存储来表示所有的符号，包括 ASCII 符号，汉语，日语，或者是其它东亚国家的语言文字。在 Java 中，一个 <code>char</code> 类型数据占据 2 个字节，而这 2 个字节正好是一个 Unicode 码元的长度。</p>
<p>换句话说，在 JVM 运行期间，一个 2 字节长度 <code>char</code> 足够表示一个汉字了 ( 前提是非生僻字 )。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> a = <span class="hljs-string">&quot;你&quot;</span>;<br>System.out.println(a);<br></code></pre></td></tr></table></figure>

<p>但是，在编译成二进制文件之前，源代码是作为字符文件 ( 或称文本 ) 存在的。由于它们要能够被人类所识别，因此文本对应的字节序列要提前被 IDE 经过 UTF-8 编码 ( 大部分情况下 ) 之后呈现给用户。</p>
<p>如果直接使用二进制格式查看 Java 源文件的字节序列的话，可以发现一个汉字以 3 个字节来存储，这三个字节是一个汉字对应的 Unicode 码元在 UTF-8 编码中的表现形式，而非 Unicode 字符码元本身。</p>
<h3 id="3-5-2-Go-方"><a href="#3-5-2-Go-方" class="headerlink" title="3.5.2 Go 方"></a>3.5.2 Go 方</h3><p>之前的例子已经演示了：如果要尝试从 <code>string</code> 中提取一个汉字，得找到该汉字对应的 <code>byte</code> 切片。由于 Go 语言统一采用 UTF-8 编码而非直接使用 Unicode 码元，因此一个汉字会需要 3 个 <code>byte</code> 长度存储。</p>
<p>在 Java 程序中，可以很轻易地提取出这个字符串的 “第6个字”：”世”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s =  <span class="hljs-string">&quot;hello,世界&quot;</span>;<br>System.out.println(s.charAt(<span class="hljs-number">6</span>));<br></code></pre></td></tr></table></figure>

<p>但是在 Go 程序中，目前的办法只能是通过计算汉字对应的字节序列提取它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;hello,世界&quot;</span>;<br><span class="hljs-comment">// 总长: 6 x 1 + 3 x 2 = 12;</span><br><span class="hljs-comment">// 下标: 0 - 11</span><br><span class="hljs-comment">// 表达 &quot;世&quot; 的字节下标在 6-8 之间</span><br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">6</span>:<span class="hljs-number">9</span>])<br></code></pre></td></tr></table></figure>

<p>在 Go 程序中，用于表达 字符 的数据类型被称之为 <code>rune</code> ( 它是  <code>int32</code> 的别称，因为实际上 UTF-8 最多会用 4 个字节存储一个符号 )，它是一种类似于 Java <code>char</code> 的数据类型。</p>
<p>为了实现查询 “第 x 个字符”，而非 “第 x-y 个字节表示的字符”，不如先将 <code>string</code> 转化成一段 <code>[]rune</code> 切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello，世界&quot;</span><br>r := []<span class="hljs-keyword">rune</span>(s)<br><br><span class="hljs-comment">// 第六个字 &quot;世&quot;。存粹的 r[i] 是编码数字，因此还要转回到 string 再输出.</span><br><span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(r[<span class="hljs-number">6</span>]))<br><span class="hljs-comment">// 第七个字 &quot;界&quot;。存粹的 r[i] 是编码数字，因此还要转回到 string 再输出.</span><br><span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(r[<span class="hljs-number">7</span>]))<br><span class="hljs-comment">// &quot;世界&quot;。不要忘了 arr[a:b] 指的是 [a,b) 区间。</span><br><span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(r[<span class="hljs-number">6</span>:<span class="hljs-number">8</span>]))<br></code></pre></td></tr></table></figure>

<p>如果要像 Java 那样让 Go 去查询字符串的 “字符数” 而非 “字节数”，可以直接通过 <code>len</code> 函数查看转换后的 <code>[]renu</code> 的长度。如果不想因此声明一个新变量，也可以通过引入 <code>utf8</code> 包的方式来解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unicode/utf8&quot;</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello，世界&quot;</span><br><span class="hljs-comment">// 得到的是 8，而非 12。</span><br><span class="hljs-built_in">println</span>(utf8.RuneCountInString(s))<br></code></pre></td></tr></table></figure>

<h2 id="3-6-有关于字符串操作的标准包"><a href="#3-6-有关于字符串操作的标准包" class="headerlink" title="3.6 有关于字符串操作的标准包"></a>3.6 有关于字符串操作的标准包</h2><p>其中有 3 个标准包对字符串操作有很大帮助：</p>
<p><code>strings</code> 包：提供对字符串的搜索，替换，修正，切分，连接等基础功能，这里仅给出一个简单示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hello，世界，hello&quot;</span><br><span class="hljs-comment">// 查询 hello 在字符串 s 中出现的个数。</span><br>_ = strings.Count(s,<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment">// 查询 hello 是否出现在 s 中。</span><br>_ = strings.Contains(s,<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure>

<p><code>strconv</code> 包：专门用于将字符串和其它数据结构进行相互转换。比如这里给出一个在 C 语言比较熟悉的 <code>atoi</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">atoi, err := strconv.Atoi(s)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatalf(err.Error())<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> aInt = atoi<br>    fmt.Printf(<span class="hljs-string">&quot;被转换的int值:%v&quot;</span>,aInt)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其它数据结构对字符串的转化，可以调用各种 <code>PauseXXX</code> 方法。字符串对其它数据结构的转化，可以调用各种 <code>FormatXXX</code> 方法。</p>
<p><code>unicode</code> 包：适用于判断单个字符内容，比如 <code>IsDigit</code>，<code>IsLetter</code>，<code>IsUpper</code> 或者是 <code>IsLower</code> 方法。</p>
<h2 id="3-7-常量与枚举"><a href="#3-7-常量与枚举" class="headerlink" title="3.7 常量与枚举"></a>3.7 常量与枚举</h2><p>变量的修饰符是 <code>var</code>，相对的，常量的修饰符则是 <code>const</code>。显然，常量的值是不可改变的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi = <span class="hljs-number">3.1415</span><br></code></pre></td></tr></table></figure>

<p>如果要声明一组常量，可以使用小括号括起来。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span>(<br>    <span class="hljs-comment">// &lt;常量名&gt; [= 值]</span><br>    Apple = <span class="hljs-number">1</span><br>    Orange = <span class="hljs-number">2</span><br><br>    <span class="hljs-comment">// 复用上一个 Orange 的值。</span><br>    Banana<br>    <br>    <span class="hljs-comment">// 复用上一个 Banana 的值。</span><br>    Malon<br>)	<br></code></pre></td></tr></table></figure>

<p>在该写法中，如果只声明常量名，而不声明值，则该常量复用声明列表中上一个常量的<strong>类型和值</strong>。比如上述代码块的常量 <code>Banana = 2</code> 。</p>
<h3 id="3-7-1-常量生成器-iota"><a href="#3-7-1-常量生成器-iota" class="headerlink" title="3.7.1 常量生成器 iota"></a>3.7.1 常量生成器 iota</h3><p>如果要实现这样一个功能：声明一连串的常量，并且希望程序自动按顺序标识为 <code>0</code>，<code>1</code>，… 以此类推，可以借助常量生成器 <code>iota</code> 来完成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span>(<br>    Sunday = <span class="hljs-literal">iota</span><br>    Monday<br>    Tuesday<br>    Wednesday<br>    Thursday<br>    Friday<br>    Saturday<br>)<br>fmt.Printf(<span class="hljs-string">&quot;Saturday = %v&quot;</span>,Saturday)<br></code></pre></td></tr></table></figure>

<p><code>iota</code> 赋予的是一个<strong>无类型</strong> int 值。就这个例子而言，如果希望这些常量的类型更加接近语义，而重新为其定义为 <code>WeekDay</code> 类型，还可以这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Weekday <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">const</span>(<br>    Sunday Weekday = <span class="hljs-literal">iota</span><br>    Monday<br>    Tuesday<br>    Wednesday<br>    Thursday<br>    Friday<br>    Saturday<br>)<br></code></pre></td></tr></table></figure>

<p>从形式上来看，这个 Weekday 类型可以被认为是一个枚举 ( Enumeration )。</p>
<h3 id="3-7-2-无类型常量"><a href="#3-7-2-无类型常量" class="headerlink" title="3.7.2 无类型常量"></a>3.7.2 无类型常量</h3><p>在 Go 语言中，常量可以从属于某一种详细的数据类型，比如 <code>int64</code>，或者是 <code>float64</code>。但是在大多数情况下，常量可以不属于某一个具体类型。此时它们被称之为无类型 ( <code>untyped</code> ) 常量。无类型常量包含了 6 种：无类型整数，无类型布尔，无类型文字符号 <code>rune</code>，无类型浮点数，无类型复数，无类型字符串。</p>
<p>至于为什么会存在无类型常量，是因为 Go 语言的设计者希望常量总是能够维持一个尽可能高的精度。以圆周率为例，<code>math.Pi</code> 便是一个无类型浮点数。如果 <code>math.Pi</code> 一开始就被设定为 <code>float64</code> ，那么其圆周率的有效数字就被直接限定为了 64 位。</p>
<p>下面再看一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> VeryLarge1= <span class="hljs-number">1e999999</span>			<br><span class="hljs-keyword">const</span> VeryLarge2 = <span class="hljs-number">1e999998</span><br><br><span class="hljs-comment">// 这里发生了一步隐式转换： untyped int =&gt; int8</span><br><span class="hljs-keyword">const</span> plainInt <span class="hljs-keyword">int8</span> = VeryLarge1 / VeryLarge2<br><span class="hljs-built_in">println</span>(plainInt)<br></code></pre></td></tr></table></figure>

<p>其中，两个 <code>VeryLarge</code> 常量都是足够大的数，即便是 <code>int64</code> 也不能将他们完整地保存下来。但是，它们却可以作为无类型整数保存，甚至程序能够正确计算 <code>VeryLarge1 / VeryLarge2</code> 表达式。无类型常量可以表示的数值范围仍然是有限的，但是它们都比通常的整数类型，浮点数类型要大得多。</p>
<p>不管怎样，定义常量的目的还是为了使用它。当无类型常量被赋值给一个变量时，程序将隐式地进行类型转换。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> iConst = <span class="hljs-number">10000000</span><br><span class="hljs-keyword">var</span> aInt32 <span class="hljs-keyword">int32</span> = iConst	<span class="hljs-comment">// untyped int =&gt; int32</span><br></code></pre></td></tr></table></figure>

<p>这时，如果无类型常量是一个像 <code>VeryLarge</code> 那样很夸张的数值，程序就容易因为溢出而报错。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
